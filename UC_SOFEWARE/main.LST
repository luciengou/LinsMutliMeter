C51 COMPILER V9.02   MAIN                                                                  01/05/2015 11:22:37 PAGE 1   


C51 COMPILER V9.02, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c OMF2 BROWSE DEBUG LISTINCLUDE SYMBOLS

line level    source

   1          /***********************************************
   2            PRODUCT FOR NEWCAL MIX_TEMP FUNCTION
   3             CPU : MPC82G516
   4             BEGIN DATE: 2013.11.01
   5             FINISHED  : 2014.01.25
   6             WRITEBY   :JOHNSON LIN
   7             AD111  setup   SET 1001 0000 FOR A0 TYPE 
   8              8CH =  pga =1 ,32767BITS
   9          **************************************************/
  10          #include <MG82FE564.H>
   1      =1  // (System)
   2      =1  sfr ACC       = 0xE0;
   3      =1  sfr B         = 0xF0;
   4      =1  sfr SP        = 0x81;
   5      =1  sfr DPL       = 0x82;
   6      =1  sfr DPH       = 0x83;
   7      =1  sfr PSW       = 0xD0;
   8      =1  
   9      =1  // (Interrupt)
  10      =1  sfr IE        = 0xA8;
  11      =1  sfr EIE1      = 0xAD;
  12      =1  sfr AUXIE     = 0xAD;
  13      =1  sfr XICON     = 0xC0;
  14      =1  sfr IP0L      = 0xB8;
  15      =1  sfr IP        = 0xB8;
  16      =1  sfr IP0H      = 0xB7;
  17      =1  sfr IPH       = 0xB7;
  18      =1  sfr EIP1L     = 0xAE;
  19      =1  sfr AUXIP     = 0xAE;
  20      =1  sfr EIP1H     = 0xAF;
  21      =1  sfr AUXIPH    = 0xAF;
  22      =1  
  23      =1  // (I/O Port)
  24      =1  sfr P0        = 0x80;
  25      =1  sfr P1        = 0x90;
  26      =1  sfr P2        = 0xA0;
  27      =1  sfr P3        = 0xB0;
  28      =1  sfr P4        = 0xE8;
  29      =1  sfr P5        = 0xF8;
  30      =1  sfr P6        = 0xC8;                            // Page F
  31      =1  sfr P0M0      = 0x93;
  32      =1  sfr P0M1      = 0x94;
  33      =1  sfr P1M0      = 0x91;
  34      =1  sfr P1M1      = 0x92;
  35      =1  sfr P2M0      = 0x95;
  36      =1  sfr P2M1      = 0x96;
  37      =1  sfr P3M0      = 0xB1;
  38      =1  sfr P3M1      = 0xB2;
  39      =1  sfr P4M0      = 0xB3;
  40      =1  sfr P4M1      = 0xB4;
  41      =1  sfr P5M0      = 0xB5;
  42      =1  sfr P5M1      = 0xB6;
  43      =1  
  44      =1  // (Timer)
  45      =1  sfr TCON      = 0x88;
C51 COMPILER V9.02   MAIN                                                                  01/05/2015 11:22:37 PAGE 2   

  46      =1  sfr TMOD      = 0x89;
  47      =1  sfr T2CON     = 0xC8;
  48      =1  sfr T2MOD     = 0xC9;
  49      =1  sfr RCAP2L    = 0xCA;
  50      =1  sfr RCAP2H    = 0xCB;
  51      =1  sfr TL0       = 0x8A;
  52      =1  sfr TL1       = 0x8B;
  53      =1  sfr TH0       = 0x8C;
  54      =1  sfr TH1       = 0x8D;
  55      =1  sfr TL2       = 0xCC;
  56      =1  sfr TH2       = 0xCD;
  57      =1  
  58      =1  // (Serial Port)
  59      =1  sfr SCON      = 0x98;
  60      =1  sfr SCON0     = 0x98;
  61      =1  sfr SCON1     = 0x98;                            // Page 1
  62      =1  sfr SBUF      = 0x99;
  63      =1  sfr SBUF0     = 0x99;
  64      =1  sfr SBUF1     = 0x99;                            // Page 1
  65      =1  sfr SADDR     = 0xA9;
  66      =1  sfr SADEN     = 0xB9;
  67      =1  sfr SCFG      = 0x9A;
  68      =1  sfr S1BRT     = 0x9A;
  69      =1  sfr S2BUF     = 0x9A;                            // Page 1
  70      =1  
  71      =1  // (ADC)
  72      =1  sfr ADCON     = 0xC5;
  73      =1  sfr ADCTL     = 0xC5;
  74      =1  sfr ADCV      = 0xC6;
  75      =1  sfr ADCH      = 0xC6;
  76      =1  sfr ADCVL     = 0xBE;
  77      =1  sfr ADCL      = 0xBE;
  78      =1  
  79      =1  // (Keypad Interrupt)
  80      =1  sfr KBCON     = 0xD6;
  81      =1  sfr KBPATN    = 0xD5;
  82      =1  sfr KBMASK    = 0xD7;
  83      =1  
  84      =1  // (SPI)
  85      =1  sfr SPSTAT    = 0x84;
  86      =1  sfr SPCON     = 0x85;
  87      =1  sfr SPDAT     = 0x86;
  88      =1  sfr SPISTAT   = 0x84;
  89      =1  sfr SPICON    = 0x85;
  90      =1  sfr SPIDAT    = 0x86;
  91      =1  sfr SPCTL     = 0x85;
  92      =1  sfr SPICTL    = 0x85;
  93      =1  
  94      =1  // (PCA)
  95      =1  sfr CCON      = 0xD8;
  96      =1  sfr CMOD      = 0xD9;
  97      =1  sfr CL        = 0xE9;
  98      =1  sfr CH        = 0xF9;
  99      =1  sfr CCAPM0    = 0xDA;
 100      =1  sfr CCAPM1    = 0xDB;
 101      =1  sfr CCAPM2    = 0xDC;
 102      =1  sfr CCAPM3    = 0xDD;
 103      =1  sfr CCAPM4    = 0xDE;
 104      =1  sfr CCAPM5    = 0xDF;
 105      =1  sfr CCAP0H    = 0xFA;
 106      =1  sfr CCAP0L    = 0xEA;
 107      =1  sfr CCAP1H    = 0xFB;
C51 COMPILER V9.02   MAIN                                                                  01/05/2015 11:22:37 PAGE 3   

 108      =1  sfr CCAP1L    = 0xEB;
 109      =1  sfr CCAP2H    = 0xFC;
 110      =1  sfr CCAP2L    = 0xEC;
 111      =1  sfr CCAP3H    = 0xFD;
 112      =1  sfr CCAP3L    = 0xED;
 113      =1  sfr CCAP4H    = 0xFE;
 114      =1  sfr CCAP4L    = 0xEE;
 115      =1  sfr CCAP5H    = 0xFF;
 116      =1  sfr CCAP5L    = 0xEF;
 117      =1  sfr PCAPWM0   = 0xF2;
 118      =1  sfr PCAPWM1   = 0xF3;
 119      =1  sfr PCAPWM2   = 0xF4;
 120      =1  sfr PCAPWM3   = 0xF5;
 121      =1  sfr PCAPWM4   = 0xF6;
 122      =1  sfr PCAPWM5   = 0xF7;
 123      =1  
 124      =1  // (Others)
 125      =1  sfr PCON      = 0x87;
 126      =1  sfr PCON0     = 0x87;
 127      =1  sfr PCON1     = 0x97;
 128      =1  sfr EVRCR     = 0x97;
 129      =1  sfr PCON2     = 0xC7;
 130      =1  sfr AUXR      = 0x8E;
 131      =1  sfr AUXR0     = 0x8E;
 132      =1  sfr AUXR1     = 0xA2;
 133      =1  sfr AUXR2     = 0xA6;
 134      =1  sfr STRETCH   = 0x8F;
 135      =1  sfr WDTCR     = 0xE1;
 136      =1  sfr TSTWD     = 0x97;
 137      =1  sfr SFRPI     = 0xAC;
 138      =1  
 139      =1  // (ISP)
 140      =1  sfr ISPCR     = 0xE7;
 141      =1  sfr IFMT      = 0xE5;
 142      =1  sfr IFD       = 0xE2;
 143      =1  sfr IFADRH    = 0xE3;
 144      =1  sfr IFADRL    = 0xE4;
 145      =1  sfr SCMD      = 0xE6;
 146      =1  
 147      =1  // (bits in PSW)
 148      =1  sbit CY       = PSW^7;
 149      =1  sbit AC       = PSW^6;
 150      =1  sbit F0       = PSW^5;
 151      =1  sbit RS1      = PSW^4;
 152      =1  sbit RS0      = PSW^3;
 153      =1  sbit OV       = PSW^2;
 154      =1  sbit F1       = PSW^1;
 155      =1  sbit P        = PSW^0;
 156      =1  
 157      =1  // (bits in IE)
 158      =1  sbit EA       = IE^7;
 159      =1  sbit GF4      = IE^6;
 160      =1  sbit ET2      = IE^5;
 161      =1  sbit ES       = IE^4;
 162      =1  sbit ES0      = IE^4;
 163      =1  sbit ET1      = IE^3;
 164      =1  sbit EX1      = IE^2;
 165      =1  sbit ET0      = IE^1;
 166      =1  sbit EX0      = IE^0;
 167      =1  
 168      =1  // (bits in IP0L)
 169      =1  sbit PX3L     = IP0L^7;
C51 COMPILER V9.02   MAIN                                                                  01/05/2015 11:22:37 PAGE 4   

 170      =1  sbit PX2L     = IP0L^6;
 171      =1  sbit PT2L     = IP0L^5;
 172      =1  sbit PSL      = IP0L^4;
 173      =1  sbit PT1L     = IP0L^3;
 174      =1  sbit PX1L     = IP0L^2;
 175      =1  sbit PT0L     = IP0L^1;
 176      =1  sbit PX0L     = IP0L^0;
 177      =1  
 178      =1  sbit PT2      = IP^5;
 179      =1  sbit PS       = IP^4;
 180      =1  sbit PT1      = IP^3;
 181      =1  sbit PX1      = IP^2;
 182      =1  sbit PT0      = IP^1;
 183      =1  sbit PX0      = IP^0;
 184      =1  
 185      =1  //(bits in SCON0)
 186      =1  sbit FE       = SCON0^7;
 187      =1  sbit SM00     = SCON0^7;
 188      =1  sbit SM10     = SCON0^6;
 189      =1  sbit SM20     = SCON0^5;
 190      =1  sbit REN0     = SCON0^4;
 191      =1  sbit TB80     = SCON0^3;
 192      =1  sbit RB80     = SCON0^2;
 193      =1  sbit TI0      = SCON0^1;
 194      =1  sbit RI0      = SCON0^0;
 195      =1  
 196      =1  sbit SM0      = SCON^7;
 197      =1  sbit SM1      = SCON^6;
 198      =1  sbit SM2      = SCON^5;
 199      =1  sbit REN      = SCON^4;
 200      =1  sbit TB8      = SCON^3;
 201      =1  sbit RB8      = SCON^2;
 202      =1  sbit TI       = SCON^1;
 203      =1  sbit RI       = SCON^0;
 204      =1  
 205      =1  //(bits in SCON1)
 206      =1  sbit SM01     = SCON1^7;
 207      =1  sbit SM11     = SCON1^6;
 208      =1  sbit SM21     = SCON1^5;
 209      =1  sbit REN1     = SCON1^4;
 210      =1  sbit TB81     = SCON1^3;
 211      =1  sbit RB81     = SCON1^2;
 212      =1  sbit TI1      = SCON1^1;
 213      =1  sbit RI1      = SCON1^0;
 214      =1  
 215      =1  // (bits in TCON)
 216      =1  sbit TF1      = TCON^7;
 217      =1  sbit TR1      = TCON^6;
 218      =1  sbit TF0      = TCON^5;
 219      =1  sbit TR0      = TCON^4;
 220      =1  sbit IE1      = TCON^3;
 221      =1  sbit IT1      = TCON^2;
 222      =1  sbit IE0      = TCON^1;
 223      =1  sbit IT0      = TCON^0;
 224      =1  
 225      =1  // (bits in T2CON)
 226      =1  sbit TF2      = T2CON^7;
 227      =1  sbit EXF2     = T2CON^6;
 228      =1  sbit RCLK     = T2CON^5;
 229      =1  sbit TCLK     = T2CON^4;
 230      =1  sbit EXEN2    = T2CON^3;
 231      =1  sbit TR2      = T2CON^2;
C51 COMPILER V9.02   MAIN                                                                  01/05/2015 11:22:37 PAGE 5   

 232      =1  sbit C_T2     = T2CON^1;
 233      =1  sbit CP_RL2   = T2CON^0;
 234      =1  
 235      =1  // (bits in CCON)
 236      =1  sbit CF       = CCON^7;
 237      =1  sbit CR       = CCON^6;
 238      =1  sbit CCF5     = CCON^5;
 239      =1  sbit CCF4     = CCON^4;
 240      =1  sbit CCF3     = CCON^3;
 241      =1  sbit CCF2     = CCON^2;
 242      =1  sbit CCF1     = CCON^1;
 243      =1  sbit CCF0     = CCON^0;
 244      =1  
 245      =1  // (bits in XICON)
 246      =1  sbit PX3      = XICON^7;
 247      =1  sbit IT3H     = XICON^7;
 248      =1  sbit EX3      = XICON^6;
 249      =1  sbit IE3      = XICON^5;
 250      =1  sbit IT3      = XICON^4;
 251      =1  sbit PX2      = XICON^3;
 252      =1  sbit IT2H     = XICON^3;
 253      =1  sbit EX2      = XICON^2;
 254      =1  sbit IE2      = XICON^1;
 255      =1  sbit IT2      = XICON^0;
 256      =1  
 257      =1  // (bits in P0)
 258      =1  sbit P07      = P0^7;
 259      =1  sbit P06      = P0^6;
 260      =1  sbit P05      = P0^5;
 261      =1  sbit P04      = P0^4;
 262      =1  sbit P03      = P0^3;
 263      =1  sbit P02      = P0^2;
 264      =1  sbit P01      = P0^1;
 265      =1  sbit P00      = P0^0;
 266      =1  
 267      =1  // (bits in P1)
 268      =1  sbit P17      = P1^7;
 269      =1  sbit P16      = P1^6;
 270      =1  sbit P15      = P1^5;
 271      =1  sbit P14      = P1^4;
 272      =1  sbit P13      = P1^3;
 273      =1  sbit P12      = P1^2;
 274      =1  sbit P11      = P1^1;
 275      =1  sbit P10      = P1^0;
 276      =1  
 277      =1  // (bits in P2)
 278      =1  sbit P27      = P2^7;
 279      =1  sbit P26      = P2^6;
 280      =1  sbit P25      = P2^5;
 281      =1  sbit P24      = P2^4;
 282      =1  sbit P23      = P2^3;
 283      =1  sbit P22      = P2^2;
 284      =1  sbit P21      = P2^1;
 285      =1  sbit P20      = P2^0;
 286      =1  
 287      =1  // (bits in P3)
 288      =1  sbit P37      = P3^7;
 289      =1  sbit P36      = P3^6;
 290      =1  sbit P35      = P3^5;
 291      =1  sbit P34      = P3^4;
 292      =1  sbit P33      = P3^3;
 293      =1  sbit P32      = P3^2;
C51 COMPILER V9.02   MAIN                                                                  01/05/2015 11:22:37 PAGE 6   

 294      =1  sbit P31      = P3^1;
 295      =1  sbit P30      = P3^0;
 296      =1  
 297      =1  // (bits in P4)
 298      =1  sbit P47      = P4^7;
 299      =1  sbit P46      = P4^6;
 300      =1  sbit P45      = P4^5;
 301      =1  sbit P44      = P4^4;
 302      =1  sbit P43      = P4^3;
 303      =1  sbit P42      = P4^2;
 304      =1  sbit P41      = P4^1;
 305      =1  sbit P40      = P4^0;
 306      =1  
 307      =1  // (bits in P5)
 308      =1  sbit P53      = P5^3;
 309      =1  sbit P52      = P5^2;
 310      =1  sbit P51      = P5^1;
 311      =1  sbit P50      = P5^0;
 312      =1  
 313      =1  // (bits in P6)
 314      =1  sbit P61      = P6^1;
 315      =1  sbit P60      = P6^0;
 316      =1  
 317      =1  // (bits in P1, alternate)
 318      =1  sbit T2EX     = P1^1;
 319      =1  sbit T2       = P1^0;
 320      =1  sbit S2TXD    = P1^3;
 321      =1  sbit S2RXD    = P1^2;
 322      =1  
 323      =1  sbit SPI_CLK  = P1^7;
 324      =1  sbit SPI_MISO = P1^6;
 325      =1  sbit SPI_MOSI = P1^5;
 326      =1  sbit SPI_SS   = P1^4;
 327      =1  
 328      =1  sbit CEX5     = P1^7;
 329      =1  sbit CEX4     = P1^6;
 330      =1  sbit CEX3     = P1^5;
 331      =1  sbit CEX2     = P1^4;
 332      =1  sbit CEX1     = P1^3;
 333      =1  sbit CEX0     = P1^2;
 334      =1  sbit ECI      = P1^1;
 335      =1  
 336      =1  sbit AIN7     = P1^7;
 337      =1  sbit AIN6     = P1^6;
 338      =1  sbit AIN5     = P1^5;
 339      =1  sbit AIN4     = P1^4;
 340      =1  sbit AIN3     = P1^3;
 341      =1  sbit AIN2     = P1^2;
 342      =1  sbit AIN1     = P1^1;
 343      =1  sbit AIN0     = P1^0;
 344      =1  
 345      =1  //(bits in P2, alternate)
 346      =1  sbit KBI7     = P2^7;
 347      =1  sbit KBI6     = P2^6;
 348      =1  sbit KBI5     = P2^5;
 349      =1  sbit KBI4     = P2^4;
 350      =1  sbit KBI3     = P2^3;
 351      =1  sbit KBI2     = P2^2;
 352      =1  sbit KBI1     = P2^1;
 353      =1  sbit KBI0     = P2^0;
 354      =1  
 355      =1  // (bits in P3, alternate)
C51 COMPILER V9.02   MAIN                                                                  01/05/2015 11:22:37 PAGE 7   

 356      =1  sbit RD       = P3^7;
 357      =1  sbit WR       = P3^6;
 358      =1  sbit T1       = P3^5;
 359      =1  sbit T0       = P3^4;
 360      =1  sbit INT1     = P3^3;
 361      =1  sbit INT0     = P3^2;
 362      =1  sbit TXD      = P3^1;
 363      =1  sbit RXD      = P3^0;
 364      =1  sbit T1CKO    = P3^5;
 365      =1  sbit T0CKO    = P3^4;
 366      =1  
 367      =1  // (bits in P4, alternate)
 368      =1  sbit INT2     = P4^3;
 369      =1  sbit INT3     = P4^2;
 370      =1  
 371      =1  sbit ALE      = P4^6;
 372      =1  
 373      =1  // (bits in P6, alternate)
 374      =1  sbit CKO      = P6^0;
 375      =1  sbit XOUT     = P6^0;
 376      =1  sbit XIN      = P6^1;
  11          #include <intrins.h>
   1      =1  /*--------------------------------------------------------------------------
   2      =1  INTRINS.H
   3      =1  
   4      =1  Intrinsic functions for C51.
   5      =1  Copyright (c) 1988-2010 Keil Elektronik GmbH and ARM Germany GmbH
   6      =1  All rights reserved.
   7      =1  --------------------------------------------------------------------------*/
   8      =1  
   9      =1  #ifndef __INTRINS_H__
  10      =1  #define __INTRINS_H__
  11      =1  
  12      =1  extern void          _nop_     (void);
  13      =1  extern bit           _testbit_ (bit);
  14      =1  extern unsigned char _cror_    (unsigned char, unsigned char);
  15      =1  extern unsigned int  _iror_    (unsigned int,  unsigned char);
  16      =1  extern unsigned long _lror_    (unsigned long, unsigned char);
  17      =1  extern unsigned char _crol_    (unsigned char, unsigned char);
  18      =1  extern unsigned int  _irol_    (unsigned int,  unsigned char);
  19      =1  extern unsigned long _lrol_    (unsigned long, unsigned char);
  20      =1  extern unsigned char _chkfloat_(float);
  21      =1  #if !defined (__CX2__)
  22      =1  extern void          _push_    (unsigned char _sfr);
  23      =1  extern void          _pop_     (unsigned char _sfr);
  24      =1  #endif
  25      =1  
  26      =1  #endif
  27      =1  
  12          #include <IO_DEFINE.h>
   1      =1  /***************************************
   2      =1  MEGWIN I/O DEFINE
   3      =1  ***************************************/
   4      =1  #ifndef IO_DEFINE_h_ 
   5      =1  #define IO_DEFINE_h_
   6      =1  
   7      =1  sbit TC_C    = P0^0;    //k=0x00;j=0x01;t=0x02;e=0x03; 
   8      =1  sbit RTD_C   = P0^1;    //r=0x04;s=0x05;b=0x06;n=0x07;
   9      =1  sbit mV_C    = P0^2;
  10      =1  sbit mA_C    = P0^3;     //tc= 000 00xxx;  rtd=000 01xxx;    mV=000 10xxx
  11      =1  sbit mV_OUT  = P0^4;     //mA= 000 11xxx;
  12      =1  sbit mA_OUT  = P0^5;
C51 COMPILER V9.02   MAIN                                                                  01/05/2015 11:22:37 PAGE 8   

  13      =1  sbit UP_KEY   = P0^6;
  14      =1  sbit DOWN_KEY = P0^7;
  15      =1  
  16      =1  sbit LED1_SDA = P1^0;
  17      =1  sbit LED1_SCL = P1^2;
  18      =1  sbit LED1_LE  = P1^1;
  19      =1  sbit LED2_SDA  = P1^3;
  20      =1  sbit LED2_SCL  = P1^4;
  21      =1  sbit LED2_LE   = P1^5;
  22      =1  sbit RTC_SCL   = P1^6;
  23      =1  sbit none2     = P1^7;
  24      =1  
  25      =1  sbit AD_SDA   = P2^0;
  26      =1  sbit AD_SCL   = P2^1;
  27      =1  sbit ALL_SDA  = P2^2;
  28      =1  sbit EEP_SCL  = P2^3;
  29      =1  sbit OUT_SCL  = P2^4;
  30      =1  sbit NONE3    = P2^5;
  31      =1  sbit NONE_4   = P2^6;
  32      =1  sbit NONE_5   = P2^7;
  33      =1  sbit RTC_SDA  = P2^2;
  34      =1  
  35      =1  sbit R485_RX           = P3^0;
  36      =1  sbit R485_TX           = P3^1;
  37      =1  sbit FUNCTION_KEY      = P3^2;
  38      =1  sbit OFFSET_KEY        = P3^3;
  39      =1  sbit BEEP_OUT          = P3^4;   //for relay
  40      =1  sbit R485_DE_RE        = P3^5;
  41      =1  sbit NONE_6            = P3^6;
  42      =1  sbit NONE_7            = P3^7;
  43      =1  //------------------------
  44      =1  sbit EEPROM_SDA = P2^2;
  45      =1  sbit EEPROM_SCL = P2^3;
  46      =1  
  47      =1  sbit Value_SDA  = P2^0;
  48      =1  sbit Value_SCL  = P2^1;
  49      =1  sbit BEEP       = P3^4;  //for relay
  50      =1  
  51      =1  sbit mV_SDA   = P2^2;
  52      =1  sbit mV_SCL   = P2^4;
  53      =1  sbit mA_SDA   = P2^2;
  54      =1  sbit mA_SCL   = P2^4;
  55      =1  
  56      =1  #endif
  13          #include <LED.h>
   1      =1  #ifndef LED_h_ 
   2      =1  #define LED_h_ 
   3      =1  
   4      =1  
   5      =1  void LED_Disp(unsigned char LEDs, unsigned  int disp_value);
   6      =1  void SETUP_LED_Disp(unsigned char SETUP_SELECT, unsigned int disp_value);
   7      =1  void LED_DATA_Write(unsigned char prt,unsigned char D5,unsigned char D4,unsigned char D3,unsigned char D2,
             -unsigned char D1,unsigned char D0);
   8      =1  void DAY_LED_Disp(unsigned char DD,unsigned char HH, unsigned char MM);
   9      =1  void LED_Init(void);
  10      =1  void LED_Cls(void);
  11      =1  void LED_Fill(void);
  12      =1  #endif
  14          #include <AD3421.h>
   1      =1  /************************************************************************
   2      =1  * FileName     : i2c.h
   3      =1  * Description  : Default MPC82G516 to ctrl AD111A0 IC function.
C51 COMPILER V9.02   MAIN                                                                  01/05/2015 11:22:37 PAGE 9   

   4      =1  *
   5      =1  *
   6      =1  * Version control:
   7      =1  ***************************************************************************/
   8      =1  #ifndef __AD3421_H__
   9      =1  #define __AD3421_H__
  10      =1  
  11      =1  
  12      =1  void AD3421_Init(void);
  13      =1  void AD3421_start(void);
  14      =1  void AD3421_stop(void);
  15      =1  void AD3421_write_byte(unsigned char bt);
  16      =1  unsigned char AD3421_read_byte(unsigned char lastbyte);         
  17      =1  void AD3421_write_com(unsigned char dev_id, unsigned char reg_addr);
  18      =1  unsigned char AD3421_read_com(unsigned char dev_id);
  19      =1  void S_Delay(unsigned int n);
  20      =1  unsigned char Get_AD3421_Value(void);
  21      =1  
  22      =1  unsigned int  SetmA(unsigned int mA_Value);
  23      =1  unsigned int  SetmV(unsigned int mV_Value);       
  24      =1  
  25      =1  
  26      =1  void DAC_write(unsigned char ch_id, unsigned int ma);
  27      =1  void Clear_key_delay(void);
  28      =1  unsigned char EEPROM_write(unsigned char reg_addr, unsigned int reg_data);
  29      =1  unsigned char   EEPROM_read_byte(unsigned char reg_addr);
  30      =1  unsigned char KeyScan(void);
  31      =1  unsigned char voicePlay(unsigned char id, unsigned char vol);
  32      =1  unsigned char Get_Key(void);
  33      =1  
  34      =1  #define         TRUE    1
  35      =1  #define         FALSE   0
  36      =1  
  37      =1  #endif 
  15          #include <DAC6571_mV.h>
   1      =1  /************************************************************************
   2      =1  * FileName     : i2c.h
   3      =1  * Description  : Default MPC82G516 to ctrl AD111A0 IC function.
   4      =1  *
   5      =1  *
   6      =1  * Version control:
   7      =1  ***************************************************************************/
   8      =1  #ifndef __DAC6571_mV_H__
   9      =1  #define __DAC6571_mV_H__
  10      =1  
  11      =1  void DAC6571mV_Init(void);
  12      =1  void DAC6571mV_start(void);
  13      =1  void DAC6571mV_stop(void);
  14      =1  void DAC6571mV_write_byte(unsigned char bt);
  15      =1  void mV_Delay(unsigned int n);
  16      =1  void Set_mV(unsigned int mV_V);   
  17      =1  
  18      =1  #define         TRUE    1
  19      =1  #define         FALSE   0
  20      =1  
  21      =1  #endif 
  16          #include <DAC6571_mA.h>
   1      =1  /************************************************************************
   2      =1  * FileName     : i2c.h
   3      =1  * Description  : Default MPC82G516 to ctrl AD111A0 IC function.
   4      =1  *
   5      =1  *
C51 COMPILER V9.02   MAIN                                                                  01/05/2015 11:22:37 PAGE 10  

   6      =1  * Version control:
   7      =1  ***************************************************************************/
   8      =1  #ifndef __DAC6571_mA_H__
   9      =1  #define __DAC6571_mA_H__
  10      =1  
  11      =1  
  12      =1  void DAC6571mA_Init(void);
  13      =1  void DAC6571mA_start(void);
  14      =1  void DAC6571mA_stop(void);
  15      =1  void DAC6571mA_write_byte(unsigned char bt);
  16      =1  void mA_Delay(unsigned int n);
  17      =1  void Set_mA(unsigned int mA_Value);
  18      =1  
  19      =1  #define         TRUE    1
  20      =1  #define         FALSE   0
  21      =1  
  22      =1  #endif 
  17          #include <MCP79411.h>
   1      =1  /********************************
   2      =1  **          RTC.DEVICE     **
   3      =1  *********************************/
   4      =1  #ifndef __RTC3130_H
   5      =1  #define __RTC3130_H
   6      =1  void RTC_Delay(unsigned int i);
   7      =1  void RTC_BitDly(void);  
   8      =1  //void RTC_Init(void);
   9      =1  void RTC_start0(void);  
  10      =1  void RTC_stop0(void);
  11      =1  void RTC_restart0(void);
  12      =1  void RTC_write_byte0(unsigned char bt);
  13      =1  void RTC_write_byte(unsigned char reg_addr,unsigned char reg_data);
  14      =1  void RTC_write_word(unsigned char addr, unsigned int intdata);
  15      =1  unsigned char RTC_read_byte0(void);
  16      =1  unsigned char RTC_read_byte(unsigned char reg_addr);
  17      =1  unsigned int  RTC_read_word(unsigned char addr);
  18      =1  void RTC_WRITE_SET(void);
  19      =1  void RTC_READ_SET(void);
  20      =1  void RTC_ON(void);
  21      =1  void RTC_Write_Default(void);
  22      =1  
  23      =1  #endif
  18          #include <EEPROM.H>
   1      =1  /********************************
   2      =1  **          EEPROM.DEVICE          **
   3      =1  *********************************/
   4      =1  #ifndef __EEPROM_H
   5      =1  #define __EEPROM_H
   6      =1  
   7      =1  void EEPROM_Delay(unsigned int i);
   8      =1  void EEPROM_BitDly(void);
   9      =1  void EEPROM_Init(void);
  10      =1  void EEPROM_start0(void);
  11      =1  void EEPROM_stop0(void);
  12      =1  void EEPROM_restart0(void);
  13      =1  
  14      =1  void EEPROM_write_byte0(unsigned char bt);
  15      =1  void EEPROM_write_byte(unsigned char reg_addr,unsigned char reg_data);
  16      =1  void EEPROM_write_word(unsigned char addr, unsigned int intdata);
  17      =1  
  18      =1  unsigned char EEPROM_read_byte0(void);
  19      =1  unsigned char EEPROM_read_byte(unsigned char reg_addr);
  20      =1  unsigned int  EEPROM_read_word(unsigned char addr);
C51 COMPILER V9.02   MAIN                                                                  01/05/2015 11:22:37 PAGE 11  

  21      =1  void EEPROM_Write_Default(void);
  22      =1  
  23      =1  #endif
  19          #include <STDLIB.H>
   1      =1  /*--------------------------------------------------------------------------
   2      =1  STDLIB.H
   3      =1  
   4      =1  Standard functions.
   5      =1  Copyright (c) 1988-2005 Keil Elektronik GmbH and Keil Software, Inc.
   6      =1  All rights reserved.
   7      =1  --------------------------------------------------------------------------*/
   8      =1  
   9      =1  #ifndef __STDLIB_H__
  10      =1  #define __STDLIB_H__
  11      =1  
  12      =1  #ifndef _SIZE_T
  13      =1   #define _SIZE_T
  14      =1   typedef unsigned int size_t;
  15      =1  #endif
  16      =1  
  17      =1  #ifndef NULL
  18      =1   #define NULL ((void *) 0L)
  19      =1  #endif
  20      =1  
  21      =1  #ifndef _WCHAR_T_DEFINED_
  22      =1  #define _WCHAR_T_DEFINED_
  23      =1  typedef char wchar_t;
  24      =1  #endif
  25      =1  
  26      =1  #ifndef RAND_MAX
  27      =1   #define RAND_MAX  32767u
  28      =1  #endif
  29      =1  
  30      =1  #pragma SAVE
  31      =1  #pragma REGPARMS
  32      =1  
  33      =1  extern int    abs  (int   val);
  34      =1  extern long  labs  (long  val);
  35      =1  
  36      =1  extern float atof (char *s1);
  37      =1  extern long  atol (char *s1);
  38      =1  extern int   atoi (char *s1);
  39      =1  extern int   rand ();
  40      =1  extern void  srand (int);
  41      =1  
  42      =1  extern float         strtod  (char *, char **);
  43      =1  extern long          strtol  (char *, char **, unsigned char);
  44      =1  extern unsigned long strtoul (char *, char **, unsigned char);
  45      =1  
  46      =1  #define _MALLOC_MEM_    xdata
  47      =1  
  48      =1  extern void init_mempool          (void _MALLOC_MEM_ *p, unsigned int size);
  49      =1  extern void _MALLOC_MEM_ *malloc  (unsigned int size);
  50      =1  extern void free                  (void _MALLOC_MEM_ *p);
  51      =1  extern void _MALLOC_MEM_ *realloc (void _MALLOC_MEM_ *p, unsigned int size);
  52      =1  extern void _MALLOC_MEM_ *calloc  (unsigned int size, unsigned int len);
  53      =1  
  54      =1  #pragma RESTORE
  55      =1  
  56      =1  #endif
  20          #include <TYPE_SLOPE.H>
   1      =1  /*************************************
C51 COMPILER V9.02   MAIN                                                                  01/05/2015 11:22:37 PAGE 12  

   2      =1   SLOPE FOR PER TYPE AND GAIN 
   3      =1  
   4      =1  **************************************/
   5      =1  #ifndef SLOPE_h_ 
   6      =1  #define SLOPE_h_ 
   7      =1  
   8      =1  unsigned int Get_K_Slope(unsigned  int kt);
   9      =1  unsigned int Get_J_Slope(unsigned  int jt);
  10      =1  unsigned int Get_T_Slope(unsigned  int ts);
  11      =1  unsigned int Get_E_Slope(unsigned  int et);
  12      =1  unsigned int Get_R_Slope(unsigned  int rt);
  13      =1  unsigned int Get_S_Slope(unsigned  int st);
  14      =1  unsigned int Get_B_Slope(unsigned  int bt);
  15      =1  unsigned int Get_N_Slope(unsigned  int nt); 
  16      =1  unsigned int Get_RTD_Slope(unsigned int rtd);
  17      =1  unsigned int DO_RTD_TYPE(void);
  18      =1  unsigned int Read_AD3421_Value(void);
  19      =1  #endif
  21          
  22          #define   BASE_TEMP             32       //F & C Transfor Data
  23          #define   MAX_TEMP              3240     //F 1800C
  24          #define   MAX_VOLT              2048     //mV
  25          #define   EEP_START             60
  26          #define   EEP_END               2000
  27          #define   JOHNSON       0x5a
  28          #define   LIN           0xa5
  29          
  30          #define   K_TYPE                0               //2466F   54.807mV      P0=0x00
  31          #define   J_TYPE                1               //1368F   42.922mV
  32          #define   T_TYPE            2           //360F    9.286mV
  33          #define   E_TYPE                3               //1440F   61.022mV
  34          #define   R_TYPE                4               //2880F   18.842mV
  35          #define   S_TYPE                5               //2880F   16.771mV
  36          #define   B_TYPE                6               //3240F   13.585mV
  37          #define   N_TYPE            7           //?       ?
  38          
  39          #define TC_FUNCTION             0
  40          #define RTD_FUNCTION    1
  41          #define mV_FUNCTION             2
  42          #define mA_FUNCTION             3
  43          #define SETUP_FUNCTION  4
  44          #define CLEAR_FUNCTION  5
  45          
  46          #define   ON    1
  47          #define   OFF   0
  48          
  49          //timer out work select
  50          #define DISPLAY_SEND_TIME  0     // DISPLAY TIME  
  51          #define ADC_READ_TIME      1     //     ADC_READ_TIME
  52          #define RTC_READ_TIME      2     //     RTC_READ_TIME
  53          #define RTC_SEND_TIME      3     //     RTC_SEND_TIME
  54          #define UART_SEND_TIME     4     //     UART_SEND_TIME
  55          #define MV_SEND_TIME       5     // mV_OUT_ TIME
  56          #define SETUP_TIMEOUT      6     //     FAIL_TIMEOUT
  57          #define TIMEUP_TIME        7     //
  58          
  59          
  60          #define NOMAL_FUNCTION    0
  61          #define MODE_CAL          1
  62          #define C_F_CAL           2
  63          #define TYPE_CAL          3
  64          #define TC_ZERO_CAL       4
C51 COMPILER V9.02   MAIN                                                                  01/05/2015 11:22:37 PAGE 13  

  65          #define TC_SPAN_CAL       5
  66          #define RTD_ZERO_CAL      6
  67          #define RTD_SPAN_CAL      7
  68          #define mV_ZERO_CAL       8
  69          #define mV_SPAN_CAL       9
  70          #define mA_ZERO_CAL       10
  71          #define mA_SPAN_CAL       11
  72          #define ALARM_LO_CAL      12
  73          #define ALARM_HI_CAL      13
  74          #define YEAR_DATE_CAL     14
  75          #define MON_DATE_CAL      15
  76          #define DAY_DATE_CAL      16
  77          #define HOUR_DATE_CAL     17
  78          #define MIN_DATE_CAL      18
  79          #define SEC_DATE_CAL      19
  80          #define PRODUCT_RESET     20
  81          #define  SQWE           0x40            //  SQWE = b6  
  82          #define  MFP_01H        0x00 
  83          #define  OSC_EN         0x80                    // day bit 7
  84          
  85          #define  sec     0x00  
  86          #define  min     0x01 
  87          #define  hour    0x02
  88          #define  week    0x03
  89          #define  day     0x04
  90          #define  month   0x05
  91          #define  year    0x06
  92          #define  ctl     0x07
  93                             
  94          #define  Mode_Select 18    //EEP Address
  95          #define  C_F_Select  19
  96          #define  Type_Select 20
  97          #define  TC_Zero     22   
  98          #define  TC_Span     24
  99          #define  RTD_Zero    26
 100          #define  RTD_Span    28
 101          #define  mV_Zero     30                                                                   
 102          #define  mV_Span     32
 103          #define  mA_Zero     34
 104          #define  mA_Span     36
 105          #define  Alarm_Low   38
 106          #define  Alarm_Hi    40
 107          #define  Year_Date   42
 108          #define  Mon_Date    43
 109          #define  Day_Date    44
 110          #define  Week_Date   45
 111          #define  Hour_Date   46
 112          #define  Min_Date    47
 113          #define  sec_Date    48
 114          #define  Status_flag 50
 115          #define  TC_Span_Per 52
 116          #define  RTD_Span_Per 54
 117          #define  mV_Span_Per 56
 118          #define  mA_Span_Per 58
 119          #define  EEP_ADR     60
 120          //===============================
 121          extern unsigned char key = 0,key_bak = 0;
 122          extern unsigned char AV_COD ;
 123          extern unsigned char NP_COD ;
 124          unsigned char NG_COD,ADD_COD;
 125          unsigned char OVER_COD = 0 ;
 126          idata unsigned char Soft_Timer[8] = {16,16,4,2,59,2,20,30};
C51 COMPILER V9.02   MAIN                                                                  01/05/2015 11:22:37 PAGE 14  

 127          idata unsigned char T0_cnt,T2_cnt, T1_cnt;
 128          idata unsigned int   Data_Value[10] ;
 129          unsigned char MAIN_SW;
 130          unsigned char Work_Type;
 131          unsigned char C_F_Type;
 132          unsigned char TC_Type;
 133          unsigned int  TC_Zero_offset;
 134          unsigned int  TC_Span_offset;
 135          unsigned int  RTD_Zero_offset;
 136          unsigned int  RTD_Span_offset;
 137          unsigned int  mV_Zero_offset;
 138          unsigned int  mV_Span_offset;
 139          unsigned int  mA_Zero_offset;
 140          unsigned int  mA_Span_offset;
 141          unsigned int  alarm_Low_set;
 142          unsigned int  alarm_Hi_set;
 143          unsigned int  TC_Span_Value = 0;
 144          unsigned int  RTD_Span_Value = 0;
 145          unsigned int  mV_Span_Value = 0;
 146          unsigned int  mA_Span_Value = 0;
 147          unsigned char  use_flag;
 148          unsigned char  use_year = 0x14;
 149          unsigned char  use_mon  = 0x01;
 150          unsigned char  use_day  = 0x01;
 151          unsigned char  use_week = 0x03;
 152          unsigned char  use_hour = 0x12;
 153          unsigned char  use_min  = 0x01;
 154          unsigned char  use_sec  = 0x01;
 155          unsigned char  eep_count;
 156          unsigned int   Disp_year;
 157          unsigned char  n_code = 0 ;
 158          unsigned char CAIT = 0x01;
 159          unsigned char Func_Type;
 160          unsigned char AD_Hi;
 161          unsigned char AD_Mid;
 162          unsigned char AD_Lo;
 163          unsigned char AD_Status;
 164          unsigned char PCB_SETUP;
 165          unsigned char Soft_Timer_Enable = 0;
 166          unsigned char Key_backup, ReceiveDate;
 167          
 168          bit f_half_sec;
 169          bit ReceiveFlag = 0;
 170          bit tran = 0 ;
 171          /***************************************
 172                     Port In/Out Setting
 173          *****************************************/
 174          void PORT_Init(void)
 175          {
 176   1              P0M0 = 0xFF;      //00=Qb,01=pull output, 10= input only,11=open drain
 177   1              P0M1 = 0x00;     //P0= ALL INPUT
 178   1              P0   = 0xff;
 179   1      
 180   1              P1M0 = 0x00;     //P1= ALL OUTPUT
 181   1              P1M1 |= 0xFF;     //SETUP P1 ALL LO //  define P1.3 P1.4 P1.5 as push-pull
 182   1          P1   = 0x00;
 183   1      
 184   1              P2M0 = 0x04;     //P2= ALL OUTOUT
 185   1              P2M1 = 0xFF;     //SETUP P2 ALL LO
 186   1              P2   = 0x00;
 187   1      
 188   1          P3M0 = 0xED;         //
C51 COMPILER V9.02   MAIN                                                                  01/05/2015 11:22:37 PAGE 15  

 189   1              P3M1 = 0x13;
 190   1              P3   = 0x2C;
 191   1      }
 192          /*******************************************
 193               interrupt   0
 194          *******************************************/
 195          void ex_int0(void) interrupt 0
 196          {;
 197   1      }
 198          /*******************************************
 199               interrupt   1
 200          *******************************************/
 201          void time0(void) interrupt  1     //   T=1/16 sec 
 202          {
 203   1       unsigned int Value_code;
 204   1              TR0 = 0;
 205   1              T1_cnt++;
 206   1              if ((T1_cnt%8)==0)
 207   1              Value_code = SBUF;
 208   1              TH0 = 0x0B;      //0b
 209   1              TL0 = 0xDC;
 210   1              TR0 = 1;
 211   1      }
 212          
 213          /*******************************************
 214               interrupt   3
 215          *******************************************/
 216          void time1(void) interrupt  3   //    T=1/16 sec 
 217          {
 218   1              TR1 = 0;
 219   1              T0_cnt++;                                                       
 220   1      
 221   1              if (Soft_Timer[DISPLAY_SEND_TIME] != 0)         Soft_Timer[DISPLAY_SEND_TIME]--;
 222   1              if (Soft_Timer[ADC_READ_TIME] != 0)         Soft_Timer[ADC_READ_TIME]--;
 223   1              if ((T0_cnt%8)==0)      
 224   1                {
 225   2      //        if (Soft_Timer[DISPLAY_SEND_TIME] != 0)               Soft_Timer[DISPLAY_SEND_TIME]--;
 226   2                if (Soft_Timer[RTC_READ_TIME] != 0)   Soft_Timer[RTC_READ_TIME]--;
 227   2                  f_half_sec = 1;
 228   2                }
 229   1              if (T0_cnt == 15)
 230   1              {
 231   2                      T0_cnt = 0;
 232   2                      if (Soft_Timer[UART_SEND_TIME] != 0)    Soft_Timer[UART_SEND_TIME]--;
 233   2                      if (Soft_Timer[MV_SEND_TIME] != 0)          Soft_Timer[MV_SEND_TIME]--;
 234   2                      if (Soft_Timer[SETUP_TIMEOUT] != 0)     Soft_Timer[SETUP_TIMEOUT]--;    
 235   2                      if (Soft_Timer[TIMEUP_TIME] != 0)               Soft_Timer[TIMEUP_TIME]--;
 236   2              }               
 237   1              TH1 = 0x0B;
 238   1              TL1 = 0xDC;
 239   1              TR1 = 1;
 240   1       }              
 241          /*******************************************/
 242          void T0_Init(void)
 243          {
 244   1              TR0 = 1;
 245   1              TMOD = 0x11;
 246   1              TH0 = 0x0B;             
 247   1              TL0 = 0xDC;     
 248   1              T0_cnt = 0;
 249   1      }
 250          /*******************************************
C51 COMPILER V9.02   MAIN                                                                  01/05/2015 11:22:37 PAGE 16  

 251              
 252          *******************************************/
 253          void T1_Init(void)
 254          {
 255   1              TR1 = 0;
 256   1              TMOD = 0x11;  
 257   1              TH1 = 0x0B;
 258   1              TL1 = 0xDC;
 259   1              T1_cnt = 0;
 260   1       }
 261          /*******************************************
 262              
 263          *******************************************/
 264          void T2_Init(void)
 265          {
 266   1              TR2 = 1;
 267   1              T2MOD = 0x11;  //11  
 268   1              TH2 = 0x0B;
 269   1              TL2 = 0xDC;
 270   1              T2_cnt = 0;
 271   1      }
 272          /*******************************************
 273              
 274          *******************************************/
 275          void INT0_Init(void)
 276          {
 277   1          INT0 = 1;
 278   1              INT1 = 1;        
 279   1              IE0  = 1;                  
 280   1              IT0  = 1;
 281   1              EX0  = 0;         
 282   1      }
 283          /*******************************************/
 284          void InitUart()    //InitUart use timer2
 285          {
 286   1         SCON |= 0x50;                          /* uart in mode 1 (8 bit), REN=1 50 */
 287   1         T2CON &= 0xF0;               /* EXEN2=0; TR2=0; C/T2#=0; CP/RL2#=0; */
 288   1         T2CON |= 0x30;               /* RCLK = 1; TCLK=1; */
 289   1         TH2=0xFF;                    /* init value */
 290   1         TL2=0xD0;                    /* init value */
 291   1         RCAP2H=0xFF;                 /* reload value, 9600 Bds at 11.059MHz */
 292   1         RCAP2L=0xDC;                /* reload value, 9600 Bds at 11.059MHz */
 293   1         ES = 1;                                                   /* Enable serial interrupt */
 294   1         TR2 = 1;                     /* Timer 2 run */
 295   1      }
 296          /*************************************************/
 297          void serial() interrupt 4
 298          {
 299   1              if(TI==1)
 300   1              {
 301   2               TI = 0 ;
 302   2              }
 303   1              if(RI==1)
 304   1              {
 305   2                 RI=0;
 306   2                 ReceiveDate = SBUF;
 307   2                 ReceiveFlag = 1;
 308   2              }
 309   1       }
 310          /****************************************
 311                    if(tran == 0)
 312                      {
C51 COMPILER V9.02   MAIN                                                                  01/05/2015 11:22:37 PAGE 17  

 313                       tran = 1 ; 
 314                      }              
 315                   else
 316                    { 
 317                      Data_Value = Data_Value >> 8 ;
 318                      tran = 0;
 319                  Soft_Timer[UART_SEND_TIME] = 59 ;
 320                    } 
 321             SBUF = Data_Value;
 322          }
 323          /****************************************/
 324          void delay(unsigned int i)
 325          {
 326   1              unsigned char j;
 327   1              for (; i>0; i--)
 328   1                      for (j=0; j<255; j++);
 329   1      }
 330          /*******************************************
 331              
 332          *******************************************/
 333          void Buzzer(unsigned char status)
 334          {
 335   1              if (status)
 336   1            P2 =      P2 |= 0x20;
 337   1              else
 338   1                P2 = P2 &= ~0x20;
 339   1      }
 340          /*******************************************
 341                CHECK PCB TYPE
 342          *******************************************/
 343          void Check_PCB(void)
 344          {
 345   1                 if(P00 == 0)                //tc
 346   1                   {
 347   2                           Work_Type = 0x00;
 348   2                               Func_Type = 0x00;
 349   2                               PCB_SETUP = 0x01;
 350   2                           if(P04 == 0)           //mV_out
 351   2                             {PCB_SETUP = 0x11 ;}
 352   2                       if(P05 == 0)   //mA_out
 353   2                             {PCB_SETUP = 0x21 ;}
 354   2                               if(use_flag == 0x01) { NG_COD = 1;}
 355   2                       }
 356   1                 else if(P01 == 0)           //rtd
 357   1                       {
 358   2                                Work_Type = 0x01;
 359   2                                Func_Type = 0x01;
 360   2                                  PCB_SETUP = 0x02 ;
 361   2                            if(P04 == 0)      //mV_out
 362   2                              {PCB_SETUP = 0x12 ;}
 363   2                            if(P05 == 0)      //mA_out
 364   2                              {PCB_SETUP = 0x22 ;}
 365   2                                 if(use_flag == 0x02) { NG_COD = 1;}
 366   2                       }
 367   1                else if(P02 == 0)          //mV
 368   1                       {
 369   2                               Work_Type = 0x02 ;
 370   2                               Func_Type = 0x02;
 371   2                                PCB_SETUP = 0x04 ;
 372   2                                if(P04 == 0)  //mV_out
 373   2                              {PCB_SETUP = 0x14 ;}
 374   2                            if(P05 == 0)      //mA_out
C51 COMPILER V9.02   MAIN                                                                  01/05/2015 11:22:37 PAGE 18  

 375   2                              {PCB_SETUP = 0x24 ;}
 376   2                                 if(use_flag == 0x04) { NG_COD = 1;}
 377   2                       } 
 378   1                else if(P03 == 0)             //mA
 379   1                       { 
 380   2                           Work_Type = 0x03 ;
 381   2                               Func_Type = 0x03;
 382   2                                 PCB_SETUP = 0x08 ;
 383   2                               if(P04 == 0)           //mV_out
 384   2                             {PCB_SETUP = 0x18 ;}
 385   2                           if(P05 == 0)       //mA_out
 386   2                             {PCB_SETUP = 0x28 ;}
 387   2                               if(use_flag == 0x08) { NG_COD = 1;}  
 388   2                       }
 389   1      }
 390          /***********************************************/
 391          unsigned int TEMP_F_TO_C(unsigned int tc_tmp)
 392          {
 393   1       unsigned int ttmp;
 394   1      
 395   1                if(NP_COD == 0)
 396   1                  {
 397   2                   if(tc_tmp >= 320)
 398   2                    {
 399   3                          if(AV_COD == 0)
 400   3                            {
 401   4                              ttmp = (tc_tmp-320)/1.8;
 402   4                            }
 403   3                        else
 404   3                           {
 405   4                                  ttmp = (tc_tmp+320)/1.8; 
 406   4                   }
 407   3                    }
 408   2                  else
 409   2                    {
 410   3                         if(AV_COD == 1)
 411   3                               {
 412   4                         ttmp = (320+tc_tmp)/1.8;
 413   4                   }
 414   3                         else
 415   3                           {
 416   4                                ttmp = (320-tc_tmp)/1.8;
 417   4                               AV_COD = 1 ;
 418   4                               }
 419   3                       }
 420   2                 }
 421   1                else
 422   1                 {
 423   2                      if(tc_tmp >= 32)
 424   2                    {
 425   3                          if(AV_COD == 0)
 426   3                            {
 427   4                              ttmp = (tc_tmp-32)/1.8;
 428   4                            }
 429   3                        else
 430   3                           {
 431   4                                  ttmp = (tc_tmp+32)/1.8; 
 432   4                   }
 433   3                    }
 434   2                  else
 435   2                    {
 436   3                         if(AV_COD == 1)
C51 COMPILER V9.02   MAIN                                                                  01/05/2015 11:22:37 PAGE 19  

 437   3                               {
 438   4                         ttmp = (32+tc_tmp)/1.8;
 439   4                   }
 440   3                         else
 441   3                           {
 442   4                                ttmp = (32-tc_tmp)/1.8;
 443   4                                AV_COD = 1 ;
 444   4                               }
 445   3                        }
 446   2      
 447   2             } 
 448   1             return(ttmp);
 449   1      }
 450          /**********************************************/
 451          void Volt_Ctrl(void)
 452          {
 453   1      }
 454          /***********************************************/
 455          unsigned char Get_Key(void)
 456          {
 457   1        if(FUNCTION_KEY == 1 && OFFSET_KEY == 1 && UP_KEY == 1 && DOWN_KEY == 1) 
 458   1          {
 459   2               key_bak  =  0;
 460   2               key = 0 ; 
 461   2              }
 462   1        else if(FUNCTION_KEY == 0 )
 463   1          {
 464   2                if(key_bak == 0)
 465   2                 {
 466   3                   key_bak = 1 ;
 467   3                   key = key |= 0x01 ;
 468   3                 }
 469   2                else
 470   2                 {
 471   3                      key = key &= 0xfe ;
 472   3                 }
 473   2               }
 474   1         else if(OFFSET_KEY == 0)
 475   1           {
 476   2               if(key_bak == 0)
 477   2                 {
 478   3                   key = key |= 0x02 ;
 479   3                   key_bak = 1; 
 480   3                 }
 481   2                else
 482   2                 {
 483   3                      key = key &= 0xfd ;
 484   3                 }
 485   2               }
 486   1         else if(UP_KEY == 0)
 487   1          {
 488   2               if(key_bak == 0)
 489   2                 {
 490   3                   key = key |= 0x04 ;
 491   3                   key_bak = 1; 
 492   3                 }
 493   2                else
 494   2                 {
 495   3                      key = key &= 0xfb ;
 496   3                 }
 497   2               }
 498   1         else if(DOWN_KEY == 0)
C51 COMPILER V9.02   MAIN                                                                  01/05/2015 11:22:37 PAGE 20  

 499   1          {
 500   2               if(key_bak == 0)
 501   2                 {
 502   3                   key = key |= 0x08;
 503   3                   key_bak = 1; 
 504   3                 }
 505   2                else
 506   2                 {
 507   3                      key = key &= 0xf7 ;
 508   3                 }
 509   2               }
 510   1       
 511   1         return key;
 512   1      }
 513          /************************************************/
 514          unsigned  int DO_TC_TYPE(void)
 515          {
 516   1          unsigned int Code_Value,TC_Value;
 517   1               unsigned char key;
 518   1      
 519   1            key = Get_Key();
 520   1               
 521   1                if(key == 0x01)
 522   1                {
 523   2                   Func_Type = 4;
 524   2                }
 525   1         else
 526   1          {
 527   2                      if (Soft_Timer[ADC_READ_TIME] == 0) 
 528   2                         {
 529   3                            Soft_Timer[ADC_READ_TIME] = 16;
 530   3                                Code_Value =  Read_AD3421_Value();
 531   3                
 532   3                               if((NG_COD == 1)&&(AV_COD == 1))
 533   3                                 {
 534   4                                                if( Code_Value >= TC_Zero_offset)
 535   4                                                  {
 536   5                                                   Code_Value = Code_Value - TC_Zero_offset;
 537   5                                                      }
 538   4                                                 else
 539   4                                                  {
 540   5                                                       Code_Value = TC_Zero_offset -Code_Value;
 541   5                                                       AV_COD = 0;
 542   5                                                      }
 543   4                                      }
 544   3                                else if((NG_COD == 1)&&(AV_COD == 0))
 545   3                                  {
 546   4                                         Code_Value = Code_Value + TC_Zero_offset;   // ?
 547   4                                  }           
 548   3                        else if((NG_COD == 0)&&(AV_COD == 1))
 549   3                                  {
 550   4                                         Code_Value = Code_Value + TC_Zero_offset;
 551   4                                  }   
 552   3                                else if((NG_COD == 0)&&(AV_COD == 0))
 553   3                                  {
 554   4                                             if( Code_Value >= TC_Zero_offset)
 555   4                                                  {
 556   5                                                   Code_Value = Code_Value - TC_Zero_offset;
 557   5                                                      }
 558   4                                                 else
 559   4                                                  {
 560   5                                                       Code_Value = TC_Zero_offset - Code_Value;
C51 COMPILER V9.02   MAIN                                                                  01/05/2015 11:22:37 PAGE 21  

 561   5                                                   AV_COD = 1 ;
 562   5                                                      }
 563   4                                      } 
 564   3                                         if(ADD_COD == 1 )   //Code_Value < 0xc8ca)   //ADD_COD == 1)
 565   3                                               { Code_Value = Code_Value -(Code_Value/TC_Span_Value); }
 566   3                                        else
 567   3                                               { Code_Value = Code_Value + (Code_Value/TC_Span_Value);}  
 568   3      //                                        Code_Value = 0xc8ca ;  //   1200.0 
 569   3                                              if(OVER_COD == 1) Code_Value = 0xffff;
 570   3                          if (TC_Type == K_TYPE)
 571   3                    {
 572   4                          TC_Value  = Get_K_Slope(Code_Value);
 573   4      
 574   4                                      if (C_F_Type == 0) TC_Value = TEMP_F_TO_C(TC_Value);
 575   4                        }
 576   3                  else if (TC_Type == J_TYPE)
 577   3                    {
 578   4                          TC_Value = Get_J_Slope(Code_Value);
 579   4                                      if (C_F_Type == 0) TC_Value = TEMP_F_TO_C(TC_Value); 
 580   4                        }
 581   3                  else if (TC_Type == T_TYPE)
 582   3                    {
 583   4                          TC_Value = Get_T_Slope(Code_Value);
 584   4                                      if (C_F_Type == 0) TC_Value = TEMP_F_TO_C(TC_Value); 
 585   4                        }
 586   3                  else if (TC_Type == E_TYPE)
 587   3                    {
 588   4                         TC_Value = Get_E_Slope(Code_Value); 
 589   4                                 if (C_F_Type == 0) TC_Value = TEMP_F_TO_C(TC_Value);
 590   4                        }
 591   3                  else if (TC_Type == R_TYPE)
 592   3                    {
 593   4                                  NP_COD = 1;
 594   4                          TC_Value = Get_R_Slope(Code_Value); 
 595   4                                      if (C_F_Type == 0)  TC_Value = TEMP_F_TO_C(TC_Value);
 596   4                        }
 597   3                  else if (TC_Type == S_TYPE)
 598   3                    {
 599   4                                   NP_COD = 1;
 600   4                          TC_Value = Get_S_Slope(Code_Value);
 601   4                                      if (C_F_Type == 0)      TC_Value = TEMP_F_TO_C(TC_Value); 
 602   4                        }
 603   3      /*
 604   3                  else if (TC_Type == B_TYPE)
 605   3                    {
 606   3                                  NP_COD = 1;
 607   3      //                  Code_Value  = Code_Value*(Code_Value/(TC_Span_offset- TC_Zero_offset));
 608   3                          TC_Value = Get_B_Slope(Code_Value); 
 609   3                                      if (C_F_Type == 0)      TC_Value = TEMP_F_TO_C(TC_Value);
 610   3                        }
 611   3                 else if (TC_Type == N_TYPE)
 612   3                    {
 613   3                                   NP_COD = 1;
 614   3      //                  Code_Value  = Code_Value*(Code_Value/(TC_Span_offset- TC_Zero_offset));
 615   3                          TC_Value = Get_N_Slope(Code_Value); 
 616   3                                      if (C_F_Type == 0)      TC_Value = TEMP_F_TO_C(TC_Value);
 617   3                        }
 618   3      */
 619   3                        }
 620   2                  if (Soft_Timer[RTC_READ_TIME] == 0)
 621   2                     {
 622   3                               RTC_READ_SET();
C51 COMPILER V9.02   MAIN                                                                  01/05/2015 11:22:37 PAGE 22  

 623   3                               Soft_Timer[RTC_READ_TIME] = 8;
 624   3                         }
 625   2                  if (Soft_Timer[DISPLAY_SEND_TIME] == 0)
 626   2                    {
 627   3                           Soft_Timer[DISPLAY_SEND_TIME] = 16;        
 628   3                                 LED_Disp(1,TC_Value);
 629   3      
 630   3                          if ((TC_Value > alarm_Low_set)&&(TC_Value < alarm_Hi_set))
 631   3                        { BEEP_OUT = 1; }
 632   3                              else
 633   3                                { BEEP_OUT = 0; }
 634   3                        }
 635   2      //                else if (Soft_Timer[DISPLAY_SEND_TIME] == 8)
 636   2      //            {
 637   2      //                   DAY_LED_Disp(use_day,use_hour,use_min);
 638   2      //                }
 639   2                  if (Soft_Timer[MV_SEND_TIME] == 0)
 640   2                   {
 641   3                         if( P04 == 0) Set_mV(TC_Value);
 642   3                         if( P05 == 0) Set_mA(TC_Value);
 643   3                         Soft_Timer[MV_SEND_TIME] = 16;
 644   3                       }
 645   2                  if (Soft_Timer[UART_SEND_TIME] == 0)
 646   2                   {
 647   3                        if(tran == 0)
 648   3                          {
 649   4                              SBUF = TC_Value ;
 650   4                               tran = 1 ;
 651   4                               Soft_Timer[UART_SEND_TIME] = 1;
 652   4                     }
 653   3                   else
 654   3                    { 
 655   4                      SBUF = TC_Value >> 8 ;
 656   4                      tran = 0;
 657   4                              Soft_Timer[UART_SEND_TIME] = 59 ;
 658   4                        }
 659   3                      TI = 1;
 660   3                }
 661   2              }
 662   1          return  TC_Value;
 663   1      }
 664          /***********************************************
 665          RTD=  2 27.6    40      48      56      58
 666          131072                                  
 667          3200 2600 1950    950  40
 668          1300 2200  3250  4100    5000 5750      6450
 669          7350 7950  8700  9300  9900     10500    11150
 670          11700 12300     12850   13400 
 671          *************************************************/
 672          unsigned int DO_RTD_TYPE(void)
 673          {
 674   1        unsigned int RTD_Value; 
 675   1        unsigned char key;     
 676   1      
 677   1            key = Get_Key();
 678   1               
 679   1                if(key == 0x01)
 680   1                {
 681   2                   Func_Type =  4;
 682   2                }
 683   1              else
 684   1                {
C51 COMPILER V9.02   MAIN                                                                  01/05/2015 11:22:37 PAGE 23  

 685   2                      if (Soft_Timer[ADC_READ_TIME] == 0) 
 686   2                         {
 687   3                               Soft_Timer[ADC_READ_TIME] = 16;
 688   3      
 689   3                                RTD_Value = Read_AD3421_Value();
 690   3      
 691   3                               if((NG_COD == 1)&&(AV_COD == 1))
 692   3                                 {
 693   4                                                if( RTD_Value >= RTD_Zero_offset)
 694   4                                                  {
 695   5                                                   RTD_Value = RTD_Value - RTD_Zero_offset;
 696   5                                                      }
 697   4                                                 else
 698   4                                                  {
 699   5                                                       RTD_Value = RTD_Zero_offset -RTD_Value;
 700   5                                                       AV_COD = 0;
 701   5                                                      }
 702   4                                      }
 703   3                                else if((NG_COD == 1)&&(AV_COD == 0))
 704   3                                  {
 705   4                                                   RTD_Value = RTD_Value + RTD_Zero_offset;
 706   4                                  }                   
 707   3                                else if((NG_COD == 0)&&(AV_COD == 1))
 708   3                                  {
 709   4                                                   RTD_Value = RTD_Value + RTD_Zero_offset;
 710   4                                  }   
 711   3                                else if((NG_COD == 0)&&(AV_COD == 0))
 712   3                                  {
 713   4                                             if( RTD_Value >= RTD_Zero_offset)
 714   4                                                  {
 715   5                                                   RTD_Value = RTD_Value - RTD_Zero_offset;
 716   5                                                      }
 717   4                                                 else
 718   4                                                  {
 719   5                                                       RTD_Value = RTD_Zero_offset -RTD_Value;
 720   5                                                   AV_COD = 1 ;
 721   5                                                      }
 722   4                                      }
 723   3                                         if(RTD_Span_offset > 0x44e4)
 724   3                                               {  RTD_Value = RTD_Value +(RTD_Value/RTD_Span_Value);}
 725   3                                        else
 726   3                                               {  RTD_Value = RTD_Value - (RTD_Value/RTD_Span_Value);}
 727   3      
 728   3       //                                        RTD_Value = 0x44e4 ; // 800.0
 729   3      
 730   3                                       if(OVER_COD == 1) RTD_Value = 0xffff;
 731   3                    RTD_Value = Get_RTD_Slope(RTD_Value);
 732   3       
 733   3                       if (C_F_Type == 0)     RTD_Value = TEMP_F_TO_C(RTD_Value);
 734   3                     }
 735   2               if (Soft_Timer[DISPLAY_SEND_TIME] == 0)
 736   2                {
 737   3                         LED_Disp(1,RTD_Value);
 738   3                         Soft_Timer[DISPLAY_SEND_TIME] = 16 ;
 739   3      
 740   3                               if ((RTD_Value > alarm_Low_set)&&(RTD_Value < alarm_Hi_set))
 741   3                        { BEEP_OUT = 1; }
 742   3                              else
 743   3                                { BEEP_OUT = 0; }
 744   3                        }
 745   2      //               else if (Soft_Timer[DISPLAY_SEND_TIME] == 8)
 746   2      //            {
C51 COMPILER V9.02   MAIN                                                                  01/05/2015 11:22:37 PAGE 24  

 747   2      //                   DAY_LED_Disp(use_day,use_hour,use_min);
 748   2      //                }
 749   2                  if (Soft_Timer[MV_SEND_TIME] == 0)
 750   2                    {
 751   3                         if( P04 == 0) Set_mV(RTD_Value);
 752   3                         if( P05 == 0) Set_mA(RTD_Value);
 753   3      
 754   3                         Soft_Timer[MV_SEND_TIME] = 2;
 755   3                        }
 756   2                  if (Soft_Timer[RTC_READ_TIME] == 0)
 757   2                   {
 758   3                         RTC_READ_SET();
 759   3                         Soft_Timer[RTC_READ_TIME] = 8 ;
 760   3                       }
 761   2                  if (Soft_Timer[UART_SEND_TIME] == 0)
 762   2                    {
 763   3                         if(tran == 0)
 764   3                          {
 765   4                              SBUF = RTD_Value ;
 766   4                               tran = 1 ;
 767   4                               Soft_Timer[UART_SEND_TIME] = 1;
 768   4                     }
 769   3                   else
 770   3                    { 
 771   4                      SBUF = RTD_Value >> 8 ;
 772   4                      tran = 0;
 773   4                              Soft_Timer[UART_SEND_TIME] = 59 ;
 774   4                        }
 775   3                      TI = 1;
 776   3                 }
 777   2          }
 778   1         return RTD_Value;
 779   1      }
 780          /***********************************************
 781          
 782          ************************************************/
 783          unsigned  int DO_mV_TYPE(void)
 784          {
 785   1           unsigned int mV_Value;
 786   1               unsigned char key;
 787   1      
 788   1            key = Get_Key();
 789   1               
 790   1                if(key == 0x01)
 791   1                  {
 792   2                    Func_Type = 4;
 793   2                  }
 794   1                else 
 795   1                  {
 796   2                       if (Soft_Timer[ADC_READ_TIME] == 0) 
 797   2                        {
 798   3                          Soft_Timer[ADC_READ_TIME] = 16;
 799   3      
 800   3                          mV_Value = Read_AD3421_Value();
 801   3      
 802   3                               
 803   3                               if((NG_COD == 1)&&(AV_COD == 1))
 804   3                                 {
 805   4                                                if( mV_Value > mV_Zero_offset)                
 806   4                                                  {
 807   5                                                   mV_Value = mV_Value - mV_Zero_offset;
 808   5                                                      }
C51 COMPILER V9.02   MAIN                                                                  01/05/2015 11:22:37 PAGE 25  

 809   4                                                 else
 810   4                                                  {
 811   5                                                       mV_Value = mV_Zero_offset -mV_Value;
 812   5                                                       AV_COD = 0;
 813   5                                                      }
 814   4                                      }
 815   3                                else if((NG_COD == 1)&&(AV_COD == 0))
 816   3                                  {
 817   4                                                   mV_Value = mV_Value + mV_Zero_offset;
 818   4                                  }                   
 819   3                                else if((NG_COD == 0)&&(AV_COD == 1))
 820   3                                  {
 821   4                                                   mV_Value = mV_Value + mV_Zero_offset;
 822   4                                  }   
 823   3                                else if((NG_COD == 0)&&(AV_COD == 0))
 824   3                                  {
 825   4                                             if( mV_Value >= mV_Zero_offset)
 826   4                                                  {
 827   5                                                   mV_Value = mV_Value - mV_Zero_offset;
 828   5                                                      }
 829   4                                                 else
 830   4                                                  {
 831   5                                                       mV_Value = mV_Zero_offset -mV_Value;
 832   5                                                   AV_COD = 1 ;
 833   5                                                      }
 834   4                                      }
 835   3                                         if(mV_Span_offset > 0x0c80)
 836   3                                               { mV_Value = mV_Value + (mV_Value/mV_Span_Value); }
 837   3                                        else
 838   3                                               { mV_Value = mV_Value - (mV_Value/mV_Span_Value); }
 839   3      
 840   3      //                                      mV_Value = 0x7d00 ;
 841   3      //                                              mV_Value = 0 ;
 842   3                       
 843   3                                      mV_Value = mV_Value/3.2;
 844   3      //                      mV_Value = mV_Value/5.29;
 845   3                              if(OVER_COD == 1) mV_Value = 0xffff;     
 846   3                       }
 847   2                 if (Soft_Timer[DISPLAY_SEND_TIME] == 0)
 848   2                   {
 849   3                          LED_Disp(1,mV_Value);
 850   3                          Soft_Timer[DISPLAY_SEND_TIME] = 8 ;
 851   3      
 852   3                               if ((mV_Value > alarm_Low_set)&&(mV_Value < alarm_Hi_set))
 853   3                        { BEEP_OUT = 1; }
 854   3                              else
 855   3                                { BEEP_OUT = 0; }
 856   3                   }
 857   2                 if (Soft_Timer[MV_SEND_TIME] == 0)
 858   2                   {
 859   3                         if( P04 == 0)  Set_mV(mV_Value);
 860   3                         if( P05 == 0)  Set_mA(mV_Value);
 861   3      
 862   3                         Soft_Timer[MV_SEND_TIME] = 2;
 863   3                       }
 864   2                if (Soft_Timer[RTC_READ_TIME] == 0)
 865   2                  {
 866   3                        RTC_READ_SET();
 867   3                        Soft_Timer[RTC_READ_TIME] = 8 ;
 868   3                      }
 869   2                 if (Soft_Timer[UART_SEND_TIME] == 0)
 870   2                   {
C51 COMPILER V9.02   MAIN                                                                  01/05/2015 11:22:37 PAGE 26  

 871   3                         if(tran == 0)
 872   3                          {
 873   4                              SBUF = mV_Value ;
 874   4                               tran = 1 ;
 875   4                               Soft_Timer[UART_SEND_TIME] = 1;
 876   4                     }
 877   3                   else
 878   3                    { 
 879   4                      SBUF = mV_Value >> 8 ;
 880   4                      tran = 0;
 881   4                              Soft_Timer[UART_SEND_TIME] = 59 ;
 882   4                        }
 883   3                      TI = 1;
 884   3                       }
 885   2                }
 886   1               return mV_Value ;
 887   1      }
 888          /***********************************************
 889          
 890          *************************************************/
 891          unsigned int DO_mA_TYPE(void)
 892          {
 893   1           unsigned int mA_Value;
 894   1               unsigned char key;
 895   1      
 896   1            key = Get_Key();
 897   1               
 898   1                if(key == 0x01)
 899   1                  {
 900   2                    Func_Type = 4 ;
 901   2                  }
 902   1                else 
 903   1                  {
 904   2                       if (Soft_Timer[ADC_READ_TIME] == 0) 
 905   2                         {
 906   3                                   Soft_Timer[ADC_READ_TIME] = 16;
 907   3      
 908   3                                       mA_Value = Read_AD3421_Value();
 909   3      
 910   3                               if((NG_COD == 1)&&(AV_COD == 1))
 911   3                                 {
 912   4                                                if( mA_Value >= mA_Zero_offset)
 913   4                                                  {
 914   5                                                   mA_Value = mA_Value - mA_Zero_offset;
 915   5                                                      }
 916   4                                                 else
 917   4                                                  {
 918   5                                                       mA_Value = mA_Zero_offset -mA_Value;
 919   5                                                       AV_COD = 0;
 920   5                                                      }
 921   4                                      }
 922   3                                else if((NG_COD == 1)&&(AV_COD == 0))
 923   3                                  {
 924   4                                                   mA_Value = mA_Value + mA_Zero_offset;
 925   4                                  }                   
 926   3                                else if((NG_COD == 0)&&(AV_COD == 1))
 927   3                                  {
 928   4                                                   mA_Value = mA_Value + mA_Zero_offset;
 929   4                                  }   
 930   3                                else if((NG_COD == 0)&&(AV_COD == 0))
 931   3                                  {
 932   4                                             if( mA_Value >= mA_Zero_offset)
C51 COMPILER V9.02   MAIN                                                                  01/05/2015 11:22:37 PAGE 27  

 933   4                                                  {
 934   5                                                   mA_Value = mA_Value - mA_Zero_offset;
 935   5                                                      }
 936   4                                                 else
 937   4                                                  {
 938   5                                                       mA_Value = mA_Zero_offset -mA_Value;
 939   5                                                   AV_COD = 1 ;
 940   5                                                      }
 941   4                                      }
 942   3                                         if(mA_Span_offset >  0x1900)
 943   3                                               { mA_Value = mA_Value + (mA_Value/mA_Span_Value); }
 944   3                                        else
 945   3                                               { mA_Value = mA_Value - (mA_Value/mA_Span_Value); }
 946   3      
 947   3                                       mA_Value = mA_Value/3.2 ;
 948   3      
 949   3                                       if(OVER_COD == 1) mA_Value = 0xffff;
 950   3                        }
 951   2                 if (Soft_Timer[DISPLAY_SEND_TIME] == 0)
 952   2                   {
 953   3                          LED_Disp(1,mA_Value);
 954   3                          Soft_Timer[DISPLAY_SEND_TIME] = 16 ;
 955   3      
 956   3                               if ((mA_Value > alarm_Low_set)&&(mA_Value < alarm_Hi_set))
 957   3                        { BEEP_OUT = 1; }
 958   3                              else
 959   3                                { BEEP_OUT = 0; }
 960   3                   }
 961   2                 if (Soft_Timer[MV_SEND_TIME] == 0)
 962   2                   {
 963   3                         if( P04 == 0)  Set_mV(mA_Value);
 964   3                         if( P05 == 0)  Set_mA(mA_Value);
 965   3      
 966   3                         Soft_Timer[MV_SEND_TIME] = 2;
 967   3                       }
 968   2                 if (Soft_Timer[RTC_READ_TIME] == 0)
 969   2                  {
 970   3                        RTC_READ_SET();
 971   3                        Soft_Timer[RTC_READ_TIME] = 8 ;
 972   3                      }
 973   2                 if (Soft_Timer[UART_SEND_TIME] == 0)
 974   2                   {
 975   3                         if(tran == 0)
 976   3                          {
 977   4                              SBUF = mA_Value ;
 978   4                               tran = 1 ;
 979   4                               Soft_Timer[UART_SEND_TIME] = 1;
 980   4                     }
 981   3                   else
 982   3                    { 
 983   4                      SBUF = mA_Value >> 8 ;
 984   4                      tran = 0;
 985   4                              Soft_Timer[UART_SEND_TIME] = 59 ;
 986   4                        }
 987   3                      TI = 1;
 988   3                       }
 989   2               }
 990   1        return mA_Value;
 991   1      }
 992          /*************************************************/
 993          unsigned int Read_AD3421_Value(void)
 994          {
C51 COMPILER V9.02   MAIN                                                                  01/05/2015 11:22:37 PAGE 28  

 995   1         unsigned int  AD3421_Value;
 996   1         unsigned char ssta;
 997   1      
 998   1                       ssta = Get_AD3421_Value();
 999   1                if (ssta == 0)
1000   1                  {
1001   2                               AD_Hi =  AD_Hi & 0x03;
1002   2                    if(AD_Hi >= 2)
1003   2                         {
1004   3                            AV_COD = 1;
1005   3                                AD3421_Value = AD_Hi & 0x03;    
1006   3                                AD3421_Value = AD3421_Value << 8 ;
1007   3                                AD3421_Value = AD3421_Value + AD_Mid ;
1008   3                                AD3421_Value = AD3421_Value << 7 ;
1009   3                                AD_Lo = AD_Lo >> 1;
1010   3                                AD3421_Value = AD3421_Value + AD_Lo ;  
1011   3                                AD3421_Value = ~ AD3421_Value; 
1012   3                                if( AD3421_Value >= 0xf000){OVER_COD = 1;} else{OVER_COD = 0;}
1013   3                         }
1014   2                        else
1015   2                         {
1016   3                                AV_COD = 0;
1017   3                                AD3421_Value = AD_Hi & 0x03;    
1018   3                                AD3421_Value = AD3421_Value << 8 ;
1019   3                                AD3421_Value = AD3421_Value + AD_Mid ;
1020   3                                AD3421_Value = AD3421_Value << 7 ;
1021   3                                AD_Lo = AD_Lo >> 1;
1022   3                                AD3421_Value = AD3421_Value + AD_Lo;
1023   3                                if( AD3421_Value >= 0xf000){OVER_COD = 1;} else{OVER_COD = 0;}
1024   3                         }
1025   2      //                 AV_COD = 0;                          //tt
1026   2      //                 AD3421_Value = 0x7d00 ;              //tt
1027   2                 }
1028   1         return AD3421_Value;
1029   1      }
1030          /*************************************************/     
1031          void DO_SETUP_TYPE(void)
1032          {
1033   1              unsigned char set_key = 0, times = 0, Itemm = 0,hin= 0,lon=0; 
1034   1              unsigned char item_key,confrom_key, up_key,don_key;
1035   1              unsigned int  value_cal = 0;
1036   1              
1037   1      
1038   1                    SETUP_LED_Disp(Itemm,value_cal);
1039   1      
1040   1                         while (CAIT)
1041   1                                  {
1042   2                                                set_key = Get_Key();
1043   2      
1044   2                                                            if((set_key & 0x01) == 1)
1045   2                                                              { item_key = 1 ;}
1046   2                                                             else
1047   2                                                              { item_key = 0 ;}
1048   2      
1049   2                                                            if((set_key & 0x02) == 2)
1050   2                                                              {confrom_key = 1 ;}
1051   2                                                             else
1052   2                                                              { confrom_key = 0 ;}
1053   2      
1054   2                                                            if((set_key & 0x04) == 4)
1055   2                                                              { up_key = 1 ;}
1056   2                                                             else
C51 COMPILER V9.02   MAIN                                                                  01/05/2015 11:22:37 PAGE 29  

1057   2                                                              { up_key = 0 ;}
1058   2      
1059   2                                                if((set_key & 0x08) == 8)
1060   2                                                              { don_key = 1 ;}
1061   2                                                              else
1062   2                                                              { don_key = 0 ;}
1063   2      
1064   2                                                         if (item_key == 1) 
1065   2                                                           {
1066   3                                                                Itemm ++;
1067   3                                                                times=0;
1068   3                                                               }
1069   2                                                         if (Itemm > 0x13)
1070   2                                                               {
1071   3                                                                   Itemm = 0; 
1072   3                                                                       CAIT = 0;
1073   3                                                               } 
1074   2                                                        if(up_key == 1)   value_cal++;
1075   2                                                        if(don_key == 1)  value_cal--;
1076   2      
1077   2      
1078   2                              if ((Itemm >= TC_ZERO_CAL)&&(Itemm <= mA_SPAN_CAL))
1079   2                                   {
1080   3                                                 if (Soft_Timer[ADC_READ_TIME] == 0) 
1081   3                                                   {
1082   4                                                        Soft_Timer[ADC_READ_TIME] = 4 ;
1083   4                                                     Data_Value[n_code] = Read_AD3421_Value();
1084   4                                                                  if(n_code < 8)
1085   4                                                                        {n_code++;}
1086   4                                                                        else
1087   4                                                                         {
1088   5                                                                          Data_Value[9] = (Data_Value[7]+Data_Value[6]+Data_Value[5]+Data_Value[4]+Data_Value[3]+Data_Va
             -lue[2]+Data_Value[1]+Data_Value[0])/8 ;
1089   5                                                                              n_code = 0 ;
1090   5                                                                         }
1091   4                                                        }
1092   3                                                  else
1093   3                                                    {
1094   4                                                            Data_Value[9] = Data_Value[n_code] ;
1095   4                                                        }
1096   3                                                }
1097   2                              if (Itemm == MODE_CAL)                  //tc,rtd,mV,mA
1098   2                                {
1099   3                                                          SETUP_LED_Disp(Itemm,Work_Type);
1100   3      
1101   3                                                                 Work_Type = Work_Type + value_cal;
1102   3                                                                   value_cal = 0;
1103   3                                                                if(Work_Type >= 4)
1104   3                                                                  {
1105   4                                                                       Work_Type = 0;
1106   4                                                                       value_cal = 0;
1107   4                                                                      }        
1108   3                                                                if(confrom_key == 1)
1109   3                                                                  { 
1110   4                                                                        EEPROM_write_byte(Mode_Select,Work_Type);
1111   4                                                                        SETUP_LED_Disp(22,0);
1112   4                                                                        delay(2500);
1113   4                                                                        times ++;
1114   4                                                                      }
1115   3                                              }
1116   2                                      else if (Itemm == C_F_CAL)
1117   2                                  {
C51 COMPILER V9.02   MAIN                                                                  01/05/2015 11:22:37 PAGE 30  

1118   3                                               if (Work_Type >= 2) {Itemm = Itemm + 1;}
1119   3                                              else{   SETUP_LED_Disp(Itemm,C_F_Type);
1120   4                                                                C_F_Type = C_F_Type + value_cal;
1121   4                                                                  value_cal = 0;
1122   4                                                             
1123   4                                                                 if(C_F_Type >= 2 )
1124   4                                                                         {
1125   5                                                                          C_F_Type = 0 ;
1126   5                                                                          value_cal = 0;
1127   5                                                                         }
1128   4                                                                 if(confrom_key == 1)
1129   4                                                                  { 
1130   5                                                                         EEPROM_write_byte(C_F_Select,C_F_Type);  //C,F
1131   5                                                                         times ++; SETUP_LED_Disp(22,0);delay(2500);
1132   5                                                                      }
1133   4                                                         }
1134   3                                              }
1135   2                               else if (Itemm == TYPE_CAL)
1136   2                                  {
1137   3                                                  if (Work_Type != 0)
1138   3                                                        {     Itemm = Itemm + 1;}
1139   3                                                      else{   TC_Type = TC_Type + value_cal; 
1140   4                                                                        value_cal = 0;
1141   4                                                                if (TC_Type >= 6)
1142   4                                                                  {
1143   5                                                                    TC_Type = 0 ;
1144   5                                                                        value_cal = 0;
1145   5                                                                  }              
1146   4                                                                   SETUP_LED_Disp(Itemm,TC_Type);
1147   4      
1148   4                                                                      if(confrom_key == 1)
1149   4                                                                   {
1150   5                                                                         EEPROM_write_byte(Type_Select,TC_Type);  //K,J,T,E,R,B,S,N
1151   5                                                                         times ++; SETUP_LED_Disp(22,0);delay(2500);
1152   5                                                                       }
1153   4                                                           }
1154   3                                               }              
1155   2                                      else if (Itemm == TC_ZERO_CAL)
1156   2                                                {
1157   3                                                 if (Work_Type != 0){ Itemm = Itemm + 1;}
1158   3                                               else{
1159   4                                                         if( AV_COD == 1){ NG_COD = 1;}else{ NG_COD = 0;}
1160   4      
1161   4                                                                  SETUP_LED_Disp(Itemm, Data_Value[9]);
1162   4      
1163   4                                                                 if(confrom_key == 1)
1164   4                                                                  {
1165   5                                                                       TC_Zero_offset =  Data_Value[9] ;
1166   5      
1167   5                                                                       EEPROM_write_word(TC_Zero,TC_Zero_offset); 
1168   5                                                                         delay(50);
1169   5                                                                       if( NG_COD == 1){ EEPROM_write_byte(Status_flag,(use_flag|0x01));}
1170   5                                                                       else { EEPROM_write_byte(Status_flag,(use_flag&0xfe));}
1171   5                                                                       times ++; SETUP_LED_Disp(22,0);delay(2500);
1172   5                                                                      }
1173   4                                                         }
1174   3                                                 }
1175   2                            else if (Itemm == TC_SPAN_CAL)
1176   2                                    {
1177   3                                                  if (Work_Type != 0) { Itemm = Itemm + 1; }
1178   3                                                      else
1179   3                                                       {
C51 COMPILER V9.02   MAIN                                                                  01/05/2015 11:22:37 PAGE 31  

1180   4                                                                SETUP_LED_Disp(Itemm,Data_Value[9]);
1181   4                                                                if(confrom_key == 1)
1182   4                                                                  {
1183   5                                                                       TC_Span_offset = Data_Value[9];
1184   5      
1185   5                                                                       EEPROM_write_word(TC_Span,TC_Span_offset);  
1186   5      
1187   5                                                                       if( NG_COD == 1)
1188   5                                                                         { if ((TC_Span_offset + TC_Zero_offset) > 0xc8ca )
1189   6                                                                              { TC_Span_Value = ((TC_Span_offset + TC_Zero_offset)/((TC_Span_offset + TC_Zero_offset)-0x
             -c8ca));
1190   7                                                                                      use_flag = use_flag|0x10;}
1191   6                                                                               else
1192   6                                                                                  { TC_Span_Value = ((TC_Span_offset + TC_Zero_offset)/(0xc8ca - (TC_Span_offset + TC_Zero_offs
             -et)));
1193   7                                                                                      use_flag = use_flag&0xef;}
1194   6                                                                         }
1195   5                                                                       else
1196   5                                                                         { if ((TC_Span_offset - TC_Zero_offset) > 0xc8ca )
1197   6                                                                              { TC_Span_Value = ((TC_Span_offset - TC_Zero_offset)/((TC_Span_offset - TC_Zero_offset)-0x
             -c8ca));
1198   7                                                                                       use_flag = use_flag|0x10;}
1199   6                                                                               else
1200   6                                                                                  { TC_Span_Value = ((TC_Span_offset - TC_Zero_offset)/(0xc8ca - (TC_Span_offset - TC_Zero_offs
             -et)));
1201   7                                                                                       use_flag = use_flag&0xef;}
1202   6                                                                         }
1203   5                                                                          EEPROM_write_word(TC_Span_Per,TC_Span_Value);
1204   5                                                                              delay(50);
1205   5                                                                              EEPROM_write_byte(Status_flag,use_flag);
1206   5                                                                       times ++; SETUP_LED_Disp(22,0);delay(2500);
1207   5                                                              }
1208   4                                                        }
1209   3                                                 }
1210   2                            else if (Itemm == RTD_ZERO_CAL)
1211   2                                    {
1212   3                                                  if (Work_Type != 1) {       Itemm = Itemm + 1;}
1213   3                                                      else{
1214   4                                                               if( AV_COD == 1){ NG_COD = 1;}else{ NG_COD = 0;}
1215   4                                                                SETUP_LED_Disp(Itemm,Data_Value[9]);
1216   4                                                                if(confrom_key == 1)
1217   4                                                                  {
1218   5                                                                        RTD_Zero_offset = Data_Value[9] ;
1219   5                                                                       EEPROM_write_word(RTD_Zero,RTD_Zero_offset);  //rtd
1220   5                                                                        delay(50);
1221   5                                                                       if( NG_COD == 1){ EEPROM_write_byte(Status_flag,(use_flag|0x02));}
1222   5                                                                       else { EEPROM_write_byte(Status_flag,(use_flag&0xfd));}
1223   5                                                                       times ++; SETUP_LED_Disp(22,0);delay(2500);
1224   5                                                                      }
1225   4                                                          }
1226   3                                                }
1227   2                                 else if (Itemm == RTD_SPAN_CAL)
1228   2                                    {
1229   3                                                  if (Work_Type != 1) {Itemm = Itemm + 1;}
1230   3                                                      else{    
1231   4                                                                SETUP_LED_Disp(Itemm,Data_Value[9]);
1232   4                                                                if(confrom_key == 1)
1233   4                                                                  {
1234   5                                                                       RTD_Span_offset = Data_Value[9] ;
1235   5                                                                       EEPROM_write_word(RTD_Span,RTD_Span_offset);  //rtd
1236   5      
1237   5                                                                       if( NG_COD == 1)
C51 COMPILER V9.02   MAIN                                                                  01/05/2015 11:22:37 PAGE 32  

1238   5                                                                         { if ((RTD_Span_offset + RTD_Zero_offset) > 0x44e4 )
1239   6                                                                              { RTD_Span_Value = ((RTD_Span_offset + RTD_Zero_offset)/((RTD_Span_offset + RTD_Zero_offse
             -t)-0x44e4));}
1240   6                                                                               else
1241   6                                                                                 { RTD_Span_Value = ((RTD_Span_offset + RTD_Zero_offset)/(0x44e4 - (RTD_Span_offset + RTD_Zero_
             -offset)));}
1242   6                                                                         }
1243   5                                                                       else
1244   5                                                                         { if ((RTD_Span_offset - RTD_Zero_offset) > 0x44e4 )
1245   6                                                                              { RTD_Span_Value = ((RTD_Span_offset - RTD_Zero_offset)/((RTD_Span_offset - RTD_Zero_offse
             -t)-0x44e4));}
1246   6                                                                               else
1247   6                                                                                  { RTD_Span_Value = ((RTD_Span_offset - RTD_Zero_offset)/(0x44e4 - (RTD_Span_offset - RTD_Zero
             -_offset)));}
1248   6                                                                         }
1249   5                                                                          EEPROM_write_word(RTD_Span_Per,RTD_Span_Value);
1250   5                                                                       times ++;      SETUP_LED_Disp(22,0);delay(2500);
1251   5                                                                      }
1252   4                                                         }
1253   3                                               }
1254   2                                  else if (Itemm == mV_ZERO_CAL)
1255   2                                     {
1256   3                                                  if (Work_Type != 2)   {     Itemm = Itemm + 1;}
1257   3                                                      else{
1258   4                                                               if( AV_COD == 1){ NG_COD = 1;}else{ NG_COD = 0;}
1259   4                                                                SETUP_LED_Disp(Itemm,Data_Value[9]);
1260   4                                                                if(confrom_key == 1)
1261   4                                                                  {
1262   5                                                                       mV_Zero_offset = Data_Value[9] ;
1263   5                                                                       EEPROM_write_word(mV_Zero,mV_Zero_offset);  
1264   5                                                                        delay(50);
1265   5                                                                       if( NG_COD == 1){ EEPROM_write_byte(Status_flag,(use_flag|0x04));}
1266   5                                                                       else { EEPROM_write_byte(Status_flag,(use_flag&0xfb));}
1267   5                                                                       times ++; SETUP_LED_Disp(22,0);        delay(2500);
1268   5                                                                      }
1269   4                                                         }
1270   3                                                }
1271   2                                  else if (Itemm == mV_SPAN_CAL)
1272   2                                       {
1273   3                                                         if (Work_Type != 2) {        Itemm = Itemm + 1;}
1274   3                                                        else{ 
1275   4                                                                SETUP_LED_Disp(Itemm,Data_Value[9]);
1276   4                                                                if(confrom_key == 1)
1277   4                                                                  {
1278   5                                                                        mV_Span_offset = Data_Value[9] ;
1279   5      
1280   5                                                                       EEPROM_write_word(mV_Span,mV_Span_offset);  
1281   5      
1282   5                                                                       if( NG_COD == 1)
1283   5                                                                         { if ((mV_Span_offset + mV_Zero_offset) > 0x7d00 )            
1284   6                                                                              { mV_Span_Value = ((mV_Span_offset + mV_Zero_offset)/((mV_Span_offset + mV_Zero_offset)-0x
             -7d00));}
1285   6                                                                               else
1286   6                                                                                  { mV_Span_Value = ((mV_Span_offset + mV_Zero_offset)/(0x7d00 - (mV_Span_offset + mV_Zero_offs
             -et)));}
1287   6                                                                         }
1288   5                                                                       else
1289   5                                                                         { if ((mV_Span_offset - mV_Zero_offset) > 0x7d00)
1290   6                                                                              { mV_Span_Value = ((mV_Span_offset - mV_Zero_offset)/((mV_Span_offset - mV_Zero_offset)-0x
             -7d00));}
1291   6                                                                               else
1292   6                                                                                  { mV_Span_Value = ((mV_Span_offset - mV_Zero_offset)/(0x7d00 - (mV_Span_offset - mV_Zero_offs
C51 COMPILER V9.02   MAIN                                                                  01/05/2015 11:22:37 PAGE 33  

             -et)));}
1293   6                                                                         }
1294   5                                                                          EEPROM_write_word(mV_Span_Per,mV_Span_Value);
1295   5                                                                       times ++;      SETUP_LED_Disp(22,0);delay(2500);
1296   5                                                                      }
1297   4                                                         }
1298   3                                               }
1299   2                                 else if (Itemm == mA_ZERO_CAL)
1300   2                                     {
1301   3                                                   if (Work_Type != 3)  {     Itemm = Itemm + 1;}
1302   3                                                      else{
1303   4                                                                if( AV_COD == 1){ NG_COD = 1;}else{ NG_COD = 0;}
1304   4                                                                SETUP_LED_Disp(Itemm,Data_Value[9]);
1305   4                                                                if(confrom_key == 1)
1306   4                                                                  {
1307   5                                         delay(50);
1308   5                                                                       mA_Zero_offset = Data_Value[9];
1309   5                                                                       EEPROM_write_word(mA_Zero,mA_Zero_offset);  
1310   5                                                                         delay(50);
1311   5                                                                      if( NG_COD == 1){ EEPROM_write_byte(Status_flag,(use_flag|0x08));}
1312   5                                                                       else { EEPROM_write_byte(Status_flag,(use_flag&0xf7));}
1313   5                                                                       times ++; SETUP_LED_Disp(22,0);delay(2500);
1314   5                                                                      }
1315   4                                                         }
1316   3                                               }
1317   2                                  else if (Itemm == mA_SPAN_CAL)
1318   2                                      {
1319   3                                                        if (Work_Type != 3)  {Itemm = Itemm + 1;}
1320   3                                                      else{
1321   4                                                               SETUP_LED_Disp(Itemm,Data_Value[9] );
1322   4                                                                if(confrom_key == 1)
1323   4                                                                  {
1324   5                                                                       mA_Span_offset = Data_Value[9] ; 
1325   5                                                                       EEPROM_write_word(mA_Span,mA_Span_offset);  
1326   5                                                                       delay(50);
1327   5                                                                       if( NG_COD == 1)
1328   5                                                                         { if ((mA_Span_offset + mA_Zero_offset) > 0x1900 )   
1329   6                                                                              { mA_Span_Value = ((mA_Span_offset + mA_Zero_offset)/((mA_Span_offset + mA_Zero_offset)- 0
             -x1900));}
1330   6                                                                               else
1331   6                                                                                  { mA_Span_Value = ((mA_Span_offset + mA_Zero_offset)/( 0x1900 - (mA_Span_offset + mA_Zero_off
             -set)));}
1332   6                                                                         }
1333   5                                                                       else
1334   5                                                                         { if ((mA_Span_offset - mA_Zero_offset) > 0x1900 )
1335   6                                                                              { mA_Span_Value = ((mA_Span_offset - mA_Zero_offset)/((mA_Span_offset - mA_Zero_offset)- 0
             -x1900));}
1336   6                                                                               else
1337   6                                                                                  { mA_Span_Value = ((mA_Span_offset - mA_Zero_offset)/( 0x1900 - (mA_Span_offset - mA_Zero_off
             -set)));}
1338   6                                                                         }
1339   5                                                                               EEPROM_write_word(mA_Span_Per,mA_Span_Value);
1340   5                                                                           times ++; SETUP_LED_Disp(22,0);    delay(2500);
1341   5                                                                      }
1342   4                                                         }
1343   3                                                 }
1344   2                                               
1345   2                                 else if (Itemm == ALARM_LO_CAL)
1346   2                                       {
1347   3                                     alarm_Low_set = alarm_Low_set + value_cal*10 ;
1348   3                                                                                value_cal = 0;
1349   3                                                                SETUP_LED_Disp(Itemm,alarm_Low_set);
C51 COMPILER V9.02   MAIN                                                                  01/05/2015 11:22:37 PAGE 34  

1350   3                                                                if((up_key == 1)||(don_key == 1))
1351   3                                                                  {
1352   4                                                                   if(alarm_Low_set > 9999){value_cal = 0;alarm_Low_set = 0;}
1353   4                                                                       if(confrom_key == 1)
1354   4                                                                    {
1355   5                                                              EEPROM_write_word(Alarm_Low,alarm_Low_set);  //alarm
1356   5                                                                              times ++; SETUP_LED_Disp(22,0);delay(2500);
1357   5                                                                        } 
1358   4                                                                  }
1359   3                                                      }
1360   2                                   else if (Itemm == ALARM_HI_CAL)
1361   2                                      { 
1362   3                                                                 alarm_Hi_set = alarm_Hi_set + value_cal*10 ;
1363   3                                                                  value_cal = 0;
1364   3                                                                 SETUP_LED_Disp(Itemm,alarm_Hi_set);
1365   3                                                                if((up_key == 1)||(don_key == 1))
1366   3                                                                  {
1367   4                                                                        if(alarm_Hi_set > 9999){value_cal = 0;alarm_Hi_set = 0;}
1368   4      
1369   4                                                                        if(confrom_key == 1)
1370   4                                                                    {
1371   5                                                              EEPROM_write_word(Alarm_Hi,alarm_Hi_set);  //alarm
1372   5                                                                              times ++; SETUP_LED_Disp(22,0);delay(2500);
1373   5                                                                        }
1374   4                                                                  }
1375   3                                                      }
1376   2                                   else if (Itemm == YEAR_DATE_CAL)
1377   2                                      {   
1378   3                                                         if(value_cal >= 200)
1379   3                                                           {
1380   4                                                                 if(use_year == 0) {use_year = 0x99; value_cal = 0 ;}
1381   4                                                                 else
1382   4                                                                  { if((use_year&0x0f) == 0){use_year = (((use_year-0x10)&0xf0)|0x09); value_cal = 0 ; }
1383   5                                                                        else { use_year = use_year -0x01; value_cal = 0 ;}
1384   5                                                                  }
1385   4                                                               }
1386   3                                                              else
1387   3                                                               {
1388   4                                                                if(value_cal == 1) 
1389   4                                                                 {
1390   5                                                                    if(use_year >= 0x9a) { use_year = 0; value_cal = 0;}
1391   5                                                                       else{if((use_year&0x0f) == 0x09) {use_year = ((use_year+0x10)&0xf0);value_cal = 0; } 
1392   6                                                                            else { use_year = use_year + 0x01; value_cal = 0;} } 
1393   5                                                             } 
1394   4                                                                }     
1395   3                                                        SETUP_LED_Disp(Itemm,use_year + 0x2000);
1396   3                                                                                                                                               
1397   3                                                               if(confrom_key == 1)
1398   3                                                                 {
1399   4                                                                    RTC_write_byte(6,use_year);
1400   4                                                                      EEPROM_write_byte(Year_Date,use_year); 
1401   4                                                                              times ++;SETUP_LED_Disp(22,0);delay(2500);
1402   4                                                                 }
1403   3                                                           
1404   3                                                 }
1405   2                                 else if (Itemm == MON_DATE_CAL)
1406   2                                     {
1407   3                                                     if(value_cal >= 200)
1408   3                                                           {
1409   4                                                                 if(use_mon <= 0x01){use_mon = 0x12; value_cal = 0 ;}
1410   4                                                            else
1411   4                                                                 { if((use_mon&0x0f) == 0) {use_mon = (((use_mon-0x10)&0xf0)|0x09); value_cal = 0 ; }
C51 COMPILER V9.02   MAIN                                                                  01/05/2015 11:22:37 PAGE 35  

1412   5                                                                           else{use_mon = use_mon - 0x01; value_cal = 0 ;}
1413   5                                                                 }
1414   4                                                               }
1415   3                                                        else
1416   3                                                               {
1417   4                                                                if(value_cal == 1) 
1418   4                                                                  {
1419   5                                                                        if(use_mon == 0x12){use_mon = 0x01; value_cal = 0 ;}
1420   5                                                                       else {if((use_mon&0x0f) == 0x09) {use_mon = ((use_mon+0x10)&0xf0); value_cal = 0;}
1421   6                                                                          else { use_mon = use_mon + 0x01; value_cal = 0 ;}}
1422   5                                                                      }
1423   4                                                               }
1424   3                                                                SETUP_LED_Disp(Itemm,use_mon);
1425   3      
1426   3                                                               if(confrom_key == 1)
1427   3                                                                 {
1428   4                                                                   RTC_write_byte(5,use_mon);
1429   4                                                                       EEPROM_write_byte(Mon_Date,use_mon);
1430   4                                                                       times ++;  SETUP_LED_Disp(22,0);delay(2500);
1431   4                                                                 }
1432   3                                                      }
1433   2                                 else if (Itemm == DAY_DATE_CAL)                      //add week setup
1434   2                                    {
1435   3                                                       if(value_cal >= 200)
1436   3                                                         {
1437   4                                                           if((use_day == 1)&&(use_mon == 0x02)&&(use_year%4 == 0)) { use_day = 0x29 ;  value_cal = 0 ; }
1438   4                                                          else if((use_day == 1)&&(use_mon == 0x02)&&(use_year%4 != 0)) { use_day = 0x28 ; value_cal = 0 ;
             - }
1439   4                                                          else if((use_day == 1)&&((use_mon == 1)||(use_mon == 3)||(use_mon == 5)||(use_mon == 7)||(use_mo
             -n == 0x08)||(use_mon ==0x10)||(use_mon == 0x12))) { use_day =0x31;value_cal = 0;}
1440   4                                                          else if((use_day == 1)&&((use_mon == 4)||(use_mon == 6)||(use_mon == 0x09)||(use_mon == 0x11))) 
             -{ use_day = 0x30 ;  value_cal = 0 ; }
1441   4                                                              else if((use_day&0x0f) == 0) {use_day = (((use_day-0x10)&0xf0)|0x09);value_cal = 0;}
1442   4                                                               else {use_day = use_day -1; value_cal = 0;}
1443   4                                                        }
1444   3                                                 else
1445   3                                                       {
1446   4                                                       if(value_cal == 1)
1447   4                                                         {
1448   5                                                               if((use_mon == 2)&&(use_year%4 == 0)&&(use_day == 0x29)) { use_day = 1; value_cal = 0;}
1449   5                                                              else if((use_mon == 2)&&(use_year%4 != 0)&&(use_day == 0x28)) { use_day = 1; value_cal = 0;}
1450   5                                                              else if(((use_mon == 1)||(use_mon == 3)||(use_mon == 5)||(use_mon == 7)||(use_mon == 8)||(use_mon =
             -= 0x10)||(use_mon == 0x12))&&(use_day == 0x31)) { use_day = 1;value_cal = 0;}
1451   5                                                              else if(((use_mon == 4)||(use_mon == 6)||(use_mon == 9)||(use_mon == 0x11))&&(use_day == 0x30)) { u
             -se_day = 1; value_cal = 0;}
1452   5                                                              else if((use_day&0x0f) == 0x09) {use_day = ((use_day + 0x10)&0xf0); value_cal = 0;}
1453   5                                                                 else{use_day = use_day + 1; value_cal = 0;}                 
1454   5                                                         }
1455   4                                                       }
1456   3                                               SETUP_LED_Disp(Itemm,use_day);
1457   3      
1458   3                                                       if(confrom_key == 1)
1459   3                                                         {
1460   4                                                           RTC_write_byte(4,use_day);
1461   4                                                               EEPROM_write_byte(Day_Date,use_day);
1462   4                                                                       times ++;      SETUP_LED_Disp(22,0);delay(2500);
1463   4                                                         }
1464   3                                              }
1465   2                                else if (Itemm == HOUR_DATE_CAL)
1466   2                                   {
1467   3                                                        if(value_cal >= 200)
1468   3                                                         {
C51 COMPILER V9.02   MAIN                                                                  01/05/2015 11:22:37 PAGE 36  

1469   4                                                          if (use_hour == 0){use_hour = 0x23; value_cal = 0;}
1470   4                                                          else 
1471   4                                                               { if((use_hour&0x0f) == 0x00) {use_hour = ((use_hour-0x10)&0xf0)|0x09; value_cal = 0;}  
1472   5                                                                 else {use_hour = use_hour - 0x01; value_cal = 0;}
1473   5                                                               }
1474   4                                                         }
1475   3                                                       else
1476   3                                                         {
1477   4                                                          if(value_cal == 1)
1478   4                                                           {
1479   5                                                                 if(use_hour == 0x23) {use_hour = 0; value_cal = 0;}
1480   5                                                                 else
1481   5                                                                  { if((use_hour&0x0f) == 0x09) {use_hour = (use_hour+0x10)&0xf0; value_cal = 0;}
1482   6                                                                        else {use_hour = use_hour + 0x01; value_cal = 0;}
1483   6                                                                      }    
1484   5                                                               }
1485   4                                                          }
1486   3                                                         SETUP_LED_Disp(Itemm,use_hour);
1487   3                                                         if(confrom_key == 1)
1488   3                                                               {
1489   4                                                                   RTC_write_byte(2,use_hour);
1490   4                                                                      EEPROM_write_byte(Hour_Date,use_hour);
1491   4                                                                       times ++;      SETUP_LED_Disp(22,0);delay(2500);
1492   4                                                               }
1493   3                                               }
1494   2                             else if (Itemm == MIN_DATE_CAL)
1495   2                                   {
1496   3                                                   if(value_cal >= 200)
1497   3                                                         {
1498   4                                                           if(use_min == 0) { use_min = 0x59; value_cal = 0;}
1499   4                                                              else 
1500   4                                                               {
1501   5                                                                  if((use_min&0x0f) == 0) {use_min = ((use_min - 0x10)&0xf0)|0x09; value_cal = 0;} 
1502   5                                                                 else { use_min = use_min - 0x01; value_cal = 0;}
1503   5                                                               }
1504   4                                                        }
1505   3                                                      else
1506   3                                                        {     
1507   4                                                           if (value_cal == 1) 
1508   4                                                                 {
1509   5                                                                    if(use_min == 0x59) {use_min = 0; value_cal = 0;}
1510   5                                                                        else
1511   5                                                                         {  if((use_min&0x0f) == 0x09) {use_min = (use_min+0x10)&0xf0; value_cal = 0;}
1512   6                                                                            else { use_min = use_min + 0x01; value_cal = 0;}
1513   6                                                                         }
1514   5                                                                 }
1515   4                                                        }
1516   3                                          SETUP_LED_Disp(Itemm,use_min );
1517   3                                                        if(confrom_key == 1)
1518   3                                                          {
1519   4                                                                   RTC_write_byte(1,use_min );
1520   4                                                                       EEPROM_write_byte(Min_Date,use_min);
1521   4                                                                       times ++;SETUP_LED_Disp(22,0); delay(2500);
1522   4                                                              }
1523   3                                            }
1524   2                                          else if (Itemm >= PRODUCT_RESET)
1525   2                                                 { 
1526   3                                                                Itemm = 0 ;
1527   3                                                                CAIT  = 0 ;
1528   3                                                 }
1529   2                                       }
1530   1                      Check_PCB();                    
C51 COMPILER V9.02   MAIN                                                                  01/05/2015 11:22:37 PAGE 37  

1531   1      }
1532          //*******************************
1533          void RTC_ON(void)
1534          { 
1535   1         use_week = RTC_read_byte(0x03);
1536   1         RTC_write_byte(0x07,SQWE);
1537   1         RTC_write_byte(0x03,use_week|0x08);    
1538   1                                   
1539   1          if((use_week&OSC_EN) == OSC_EN) {;}       // if oscillator = already running, do nothing. 
1540   1          else
1541   1               { 
1542   2             RTC_write_byte(0x06,use_year)   ;     // initialize YEAR  register           
1543   2             RTC_write_byte(0x05,use_mon)    ;     // initialize MONTH register  
1544   2             RTC_write_byte(0x04,use_day)    ;     // initialize DATE  register  
1545   2             RTC_write_byte(0x03,use_week|0x08);
1546   2             RTC_write_byte(0x02,use_hour)   ;     // initialize HOUR  register  
1547   2             RTC_write_byte(0x01,use_min)    ;     // initialize MIN   register  
1548   2             RTC_write_byte(0x00,use_sec|0x80) ;
1549   2               } 
1550   1       
1551   1      }
1552          /************************************************/
1553          void RTC_WRITE_SET(void)
1554          {
1555   1      
1556   1         RTC_write_byte(0x00,(use_sec|0x80));
1557   1      
1558   1         RTC_write_byte(0x01,use_min);
1559   1      
1560   1         RTC_write_byte(0x02,use_hour);
1561   1      
1562   1         RTC_write_byte(0x03,use_week|0x08);
1563   1      
1564   1         RTC_write_byte(0x04,use_day);
1565   1      
1566   1         RTC_write_byte(0x05,use_mon);
1567   1      
1568   1         RTC_write_byte(0x06,use_year);
1569   1      
1570   1         RTC_write_byte(0x07,0x40);
1571   1      }
1572          /*****************************************/
1573          void RTC_READ_SET(void)
1574          { 
1575   1       use_sec  = RTC_read_byte(0x00)&0x7f ;
1576   1       use_min  = RTC_read_byte(0x01) ;
1577   1       use_hour = RTC_read_byte(0x02) ;
1578   1       use_week = RTC_read_byte(0x03)&0x07 ;
1579   1       use_day  = RTC_read_byte(0x04);
1580   1       use_mon  = RTC_read_byte(0x05);
1581   1       use_year = RTC_read_byte(0x06);
1582   1      
1583   1       if((use_mon&0x03) == 0x01)
1584   1       { 
1585   2         EEPROM_write_byte(Year_Date,use_year);
1586   2         EEPROM_write_byte(Mon_Date, use_mon);
1587   2         EEPROM_write_byte(Day_Date, use_day);
1588   2         EEPROM_write_byte(Week_Date, use_week);
1589   2         EEPROM_write_byte(Hour_Date,use_hour);
1590   2         EEPROM_write_byte(Min_Date, use_min);
1591   2         EEPROM_write_byte(sec_Date, use_sec);
1592   2       }
C51 COMPILER V9.02   MAIN                                                                  01/05/2015 11:22:37 PAGE 38  

1593   1      }
1594          //*******************************
1595          void EEPROM_WriteDefault(void)
1596          {
1597   1          Check_PCB();
1598   1          EEPROM_write_byte(Mode_Select,Work_Type); //setup mode
1599   1          EEPROM_write_byte(C_F_Select, 0);  //c
1600   1              EEPROM_write_byte(Type_Select,0);  //Type define k=0.j=1,t=2
1601   1      
1602   1              EEPROM_write_word(TC_Zero, 0);  
1603   1              EEPROM_write_word(TC_Span, 1400);
1604   1              EEPROM_write_word(RTD_Zero, 0);
1605   1              EEPROM_write_word(RTD_Span, 850);
1606   1              EEPROM_write_word(mV_Zero, 0);
1607   1              EEPROM_write_word(mV_Span, 5000);
1608   1              EEPROM_write_word(mA_Zero, 40); 
1609   1          EEPROM_write_word(mA_Span, 200);
1610   1              EEPROM_write_word(Alarm_Low, 0);
1611   1              EEPROM_write_word(Alarm_Hi, 5000);
1612   1      
1613   1          EEPROM_write_byte(Year_Date,0x14);
1614   1          EEPROM_write_byte(Mon_Date, 0x01);
1615   1          EEPROM_write_byte(Day_Date, 0x01);
1616   1              EEPROM_write_byte(Week_Date,0x03);
1617   1          EEPROM_write_byte(Hour_Date,0x12);
1618   1          EEPROM_write_byte(Min_Date, 0x01);
1619   1              EEPROM_write_byte(sec_Date, 0x01);
1620   1              EEPROM_write_byte(Status_flag, 0);
1621   1              EEPROM_write_word(TC_Span_Per, 1);
1622   1              EEPROM_write_word(RTD_Span_Per, 1);
1623   1              EEPROM_write_word(mV_Span_Per, 1);
1624   1              EEPROM_write_word(mA_Span_Per, 1);
1625   1              EEPROM_write_word(EEP_ADR, 60);         //eep start code
1626   1          RTC_ON();
1627   1      }
1628          /*****************************************************/
1629          void DO_RESET_TYPE(void)
1630          {
1631   1           EEPROM_WriteDefault();
1632   1           LED_Fill();                                     //  LED all light
1633   1               Work_Type = EEPROM_read_byte(Mode_Select);
1634   1               C_F_Type = EEPROM_read_byte(C_F_Select);
1635   1               TC_Type = EEPROM_read_byte(Type_Select);       //Type define k=0.j=1,t=2
1636   1               TC_Zero_offset = EEPROM_read_word(TC_Zero);    
1637   1               TC_Span_offset = EEPROM_read_word(TC_Span);
1638   1               RTD_Zero_offset = EEPROM_read_word(RTD_Zero);
1639   1               RTD_Span_offset = EEPROM_read_word(RTD_Span);
1640   1               mA_Zero_offset = EEPROM_read_word(mA_Zero);
1641   1               mA_Span_offset = EEPROM_read_word(mA_Span);
1642   1      
1643   1               mV_Zero_offset = EEPROM_read_word(mV_Zero);    
1644   1           mV_Span_offset = EEPROM_read_word(mV_Span);
1645   1               alarm_Low_set = EEPROM_read_word(Alarm_Low);
1646   1               alarm_Hi_set = EEPROM_read_word(Alarm_Hi);
1647   1           use_year = EEPROM_read_word(Year_Date);
1648   1      
1649   1           use_mon =  EEPROM_read_byte(Mon_Date);
1650   1           use_day =  EEPROM_read_byte(Day_Date);
1651   1               use_week = EEPROM_read_byte(Week_Date);
1652   1           use_hour = EEPROM_read_byte(Hour_Date);
1653   1           use_min =  EEPROM_read_byte(Min_Date);
1654   1               use_sec =  EEPROM_read_byte(sec_Date);
C51 COMPILER V9.02   MAIN                                                                  01/05/2015 11:22:37 PAGE 39  

1655   1               use_flag =     EEPROM_read_byte(Status_flag);
1656   1               TC_Span_Value = EEPROM_read_word(TC_Span_Per);
1657   1               RTD_Span_Value = EEPROM_read_word(RTD_Span_Per);
1658   1               mV_Span_Value = EEPROM_read_word(mV_Span_Per);
1659   1               mA_Span_Value = EEPROM_read_word(mA_Span_Per);
1660   1               eep_count = EEPROM_read_byte(EEP_ADR);
1661   1      }
1662          /***********************************
1663          ****      System_Start          ****
1664          ***********************************/ 
1665          main(void)
1666          {
1667   1         TR0 = 0;
1668   1         TMOD = TMOD |= 0x01;
1669   1         TH0  = 0xDC; //use timer0 to delay 5ms
1670   1         TL0  = 0;
1671   1         TF0  = 0; 
1672   1      
1673   1         IFMT = 0x07 ; //#AUXRA_Rd ;set read AUXRA command
1674   1         SCMD = 0x46; //h
1675   1         SCMD = 0xB9; //h
1676   1         IFD  = IFD |= 0x08; //;
1677   1         IFMT = 0x06;  // #AUXRA_Wr ;set write AUXRA command
1678   1         SCMD = 0x46; // #46h
1679   1         SCMD = 0xB9; //h
1680   1         TR0  = 1 ;  //;timer0 run
1681   1         while( ~TF0 ) 
1682   1            {   }
1683   1         TF0 = 0;  //
1684   1         TR0  = 0; //;timer0 stop
1685   1         IFMT = 0x07 ; //#AUXRA_Rd ;set read AUXRA command
1686   1         SCMD = 0x46 ; //h
1687   1         SCMD = 0xB9 ; //h
1688   1         IFD  = IFD |= 0x03 ;
1689   1         IFMT = 0x06; // #AUXRA_Wr ;set write AUXRA command
1690   1         SCMD = 0x46; // h
1691   1         SCMD = 0xB9; //h
1692   1         IFMT = 0x07; //#AUXRA_Rd ;set read AUXRA command
1693   1         SCMD = 0x46; //h
1694   1         SCMD = 0xB9; //h
1695   1         IFD = IFD &= 0xFB; //
1696   1         IFMT = 0x06; //, #AUXRA_Wr ;set write AUXRA command
1697   1         SCMD = 0x46; //h
1698   1         SCMD = 0x0B9; //h
1699   1      
1700   1              PORT_Init();
1701   1              RTC_SCL = 1;
1702   1              RTC_SDA = 1;
1703   1              EEPROM_Init();
1704   1              LED_Init();
1705   1              T0_Init();
1706   1              T1_Init();
1707   1              AD3421_Init();
1708   1              InitUart();
1709   1          Set_mA(0);
1710   1          LED_Fill();
1711   1              Set_mV(0);
1712   1              Buzzer(OFF);
1713   1              Soft_Timer_Enable = 0;
1714   1      
1715   1              if((EEPROM_read_byte(0) != 'N')||(EEPROM_read_byte(1) != 'E')||(EEPROM_read_byte(2) != 'W')||(EEPROM_read
             -_byte(3) != JOHNSON)||(EEPROM_read_byte(4) != LIN))
C51 COMPILER V9.02   MAIN                                                                  01/05/2015 11:22:37 PAGE 40  

1716   1           {
1717   2                      EEPROM_write_byte(0, 'N');      
1718   2                      EEPROM_write_byte(1, 'E');
1719   2                      EEPROM_write_byte(2, 'W');
1720   2                      EEPROM_write_byte(3, JOHNSON);  
1721   2                      EEPROM_write_byte(4, LIN);
1722   2                      RTC_ON();       
1723   2                      EEPROM_WriteDefault();
1724   2           }
1725   1             LED_Fill(); 
1726   1                 Work_Type = EEPROM_read_byte(Mode_Select);           
1727   1                 C_F_Type = EEPROM_read_byte(C_F_Select);
1728   1                 TC_Type  = EEPROM_read_byte(Type_Select);       //Type define k=0.j=1,t=2
1729   1                 TC_Zero_offset = EEPROM_read_word(TC_Zero);  
1730   1                 TC_Span_offset = EEPROM_read_word(TC_Span);
1731   1                 RTD_Zero_offset = EEPROM_read_word(RTD_Zero);
1732   1                 RTD_Span_offset = EEPROM_read_word(RTD_Span);
1733   1                 mV_Zero_offset = EEPROM_read_word(mV_Zero);
1734   1                 mV_Span_offset = EEPROM_read_word(mV_Span);
1735   1      
1736   1                 mA_Zero_offset = EEPROM_read_word(mA_Zero);  
1737   1             mA_Span_offset = EEPROM_read_word(mA_Span);
1738   1                 alarm_Low_set = EEPROM_read_word(Alarm_Low);
1739   1                 alarm_Hi_set = EEPROM_read_word(Alarm_Hi);
1740   1             use_year = EEPROM_read_byte(Year_Date);
1741   1             use_mon = EEPROM_read_byte(Mon_Date);
1742   1             use_day = EEPROM_read_byte(Day_Date);
1743   1             use_hour = EEPROM_read_byte(Hour_Date);
1744   1             use_min = EEPROM_read_byte(Min_Date);
1745   1                 use_sec = EEPROM_read_byte(sec_Date);
1746   1                 use_flag =   EEPROM_read_byte(Status_flag);
1747   1      
1748   1                 TC_Span_Value = EEPROM_read_word(TC_Span_Per);
1749   1                 RTD_Span_Value = EEPROM_read_word(RTD_Span_Per);
1750   1                 mV_Span_Value = EEPROM_read_word(mV_Span_Per);
1751   1                 mA_Span_Value = EEPROM_read_word(mA_Span_Per);
1752   1                 eep_count = EEPROM_read_byte(EEP_ADR);
1753   1                 Disp_year = use_year+0x2000;
1754   1                 RTC_ON();
1755   1        
1756   1      
1757   1               ET0 = 1;
1758   1               TR0 = 1;
1759   1               ET1 = 1;
1760   1               TR1 = 1;
1761   1               EA  = 1;
1762   1               MAIN_SW = 1 ;
1763   1      
1764   1           Check_PCB();
1765   1      
1766   1              if(Work_Type == 0)
1767   1                { if(use_flag & 0x01) NG_COD = 1 ;}
1768   1              else if(Work_Type == 1)
1769   1                { if(use_flag & 0x02) NG_COD = 1 ;}
1770   1              else if(Work_Type == 2)
1771   1                { if(use_flag &0x04)  NG_COD = 1 ;}
1772   1              else if(Work_Type == 3)
1773   1                { if(use_flag & 0x08) NG_COD = 1 ;}
1774   1      
1775   1      //***************************************
1776   1              while (1)
1777   1              {
C51 COMPILER V9.02   MAIN                                                                  01/05/2015 11:22:37 PAGE 41  

1778   2                      switch (Func_Type)
1779   2                        {
1780   3                              case TC_FUNCTION:
1781   3                          if(Work_Type == 0)
1782   3                            { if(use_flag & 0x10) {ADD_COD = 1;}else{ADD_COD = 0;}}
1783   3                                      DO_TC_TYPE();
1784   3                                      break;
1785   3      
1786   3                              case RTD_FUNCTION:
1787   3                              DO_RTD_TYPE();
1788   3                                      break;
1789   3      
1790   3                              case mV_FUNCTION:
1791   3                                      DO_mV_TYPE();
1792   3                                      break;
1793   3      
1794   3                              case mA_FUNCTION:
1795   3                                  DO_mA_TYPE();
1796   3                                      break;
1797   3                              
1798   3                              case SETUP_FUNCTION:
1799   3                                              CAIT = 1 ;
1800   3                                      DO_SETUP_TYPE();
1801   3                              
1802   3                                      break;
1803   3      
1804   3                              case CLEAR_FUNCTION:
1805   3                                      DO_RESET_TYPE();
1806   3                                      break;
1807   3                     }
1808   2               }
1809   1      /************************************************ 
1810   1      #define K_TYPE          0               1370C /2466F   54.807mV    57876        P0=0x00
1811   1      #define J_TYPE          1                760C /1368F   42.922mV    45188
1812   1      #define T_TYPE          2                200C /360F    9.286mV     9806
1813   1      #define E_TYPE          3               800C  /1440F   61.022mV    64439
1814   1      #define R_TYPE          4               1600C /2880F   18.842mV    19837
1815   1      #define S_TYPE          5               1600C /2880F   16.771mV    17657
1816   1      #define B_TYPE          6               1800C /3240F   13.585mV    14346
1817   1      #define N_TYPE      7           //?       ?
1818   1      sbit TC_SW1    = P0^0;  //k=0x00;j=0x01;t=0x02;e=0x03; 
1819   1      sbit TC_SW2    = P0^1;  //r=0x04;s=0x05;b=0x06;n=0x07;
1820   1      sbit TC_SW3    = P0^2;
1821   1      sbit TYPE_SW1  = P0^3;  //tc= 000 00xxx; rtd=000 01xxx; mV=000 10xxx; mA= 000 11xxx;
1822   1      sbit TYPE_SW2  = P0^4;                                   18577                  32000             32000
1823   1      sbit TYPE_SW3  = P0^5;
1824   1      */
1825   1      }
C51 COMPILER V9.02   MAIN                                                                  01/05/2015 11:22:37 PAGE 42  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


R485_RX. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B0H  1
CCF2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DAH  1
TB80 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009BH  1
PCAPWM4. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F6H  1
P1M0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0091H  1
P0M1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0094H  1
_RTC_read_byte . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
CCF3 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DBH  1
TB81 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009BH  1
PCAPWM5. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F7H  1
P2M0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0095H  1
P1M1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0092H  1
P0 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0080H  1
f_half_sec . . . . . . . . . . . . . .  PUBLIC   DATA   BIT      0000H  1
AD_Mid . . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0000H  1
ADD_COD. . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0001H  1
R485_TX. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B1H  1
CCF4 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DCH  1
SM00 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009FH  1
P3M0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B1H  1
P2M1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0096H  1
P1 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0090H  1
CCF5 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DDH  1
SM01 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009FH  1
SM10 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009EH  1
P4M0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B3H  1
P3M1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B2H  1
P2 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A0H  1
Soft_Timer . . . . . . . . . . . . . .  PUBLIC   IDATA  ARRAY    0000H  8
DO_RTD_TYPE. . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  RTD_Value. . . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
  key. . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
SM11 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009EH  1
SM20 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009DH  1
ISPCR. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E7H  1
P5M0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B5H  1
P4M1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B4H  1
P3 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B0H  1
XICON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C0H  1
EEPROM_WriteDefault. . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
serial . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
mA_Span_Value. . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0002H  2
EEPROM_SDA . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A2H  1
DOWN_KEY . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0087H  1
T0 . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B4H  1
SM21 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009DH  1
AC . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D6H  1
EVRCR. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0097H  1
P5M1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B6H  1
P4 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E8H  1
_TEMP_F_TO_C . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  tc_tmp . . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
  ttmp . . . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0002H  2
Key_backup . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0004H  1
T1 . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B5H  1
SPCON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0085H  1
P5 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F8H  1
C51 COMPILER V9.02   MAIN                                                                  01/05/2015 11:22:37 PAGE 43  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


EIE1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00ADH  1
_Buzzer. . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  status . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
TC_Zero_offset . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0005H  2
T2 . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0090H  1
EA . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AFH  1
SFRPI. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00ACH  1
WDTCR. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E1H  1
P6 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C8H  1
mV_SCL . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A4H  1
KBI0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A0H  1
SPI_MOSI . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0095H  1
SPI_MISO . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0096H  1
mA_OUT . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0085H  1
KBI1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A1H  1
SPCTL. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0085H  1
KBI2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A2H  1
AIN0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0090H  1
CF . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DFH  1
AUXIP. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00AEH  1
KBI3 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A3H  1
AIN1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0091H  1
KBI4 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A4H  1
AIN2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0092H  1
FE . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009FH  1
CH . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F9H  1
KBI5 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A5H  1
AIN3 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0093H  1
KBI6 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A6H  1
AIN4 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0094H  1
EEPROM_SCL . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A3H  1
RTD_C. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0081H  1
KBI7 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A7H  1
AIN5 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0095H  1
IE . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A8H  1
mA_Span_offset . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0007H  2
AIN6 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0096H  1
CL . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E9H  1
Read_AD3421_Value. . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  AD3421_Value . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
  ssta . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
_RTC_write_byte. . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
AIN7 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0097H  1
CEX0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0092H  1
CCAP0H . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FAH  1
ADCH . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C6H  1
_delay . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0004H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0006H  2
  j. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0005H  1
size_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
CEX1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0093H  1
CCAP1H . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FBH  1
IP0H . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B7H  1
INT0_Init. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
Func_Type. . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0009H  1
ALL_SDA. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A2H  1
CEX2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0094H  1
C51 COMPILER V9.02   MAIN                                                                  01/05/2015 11:22:37 PAGE 44  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


CCAP2H . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FCH  1
OFFSET_KEY . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B3H  1
CEX3 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0095H  1
CCAP3H . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FDH  1
CEX4 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0096H  1
CR . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DEH  1
CCAP4H . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FEH  1
CCAP0L . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EAH  1
ADCL . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BEH  1
RD . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B7H  1
CEX5 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0097H  1
EXF2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CEH  1
REN0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009CH  1
CCAP5H . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FFH  1
CCAP1L . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EBH  1
CCAPM0 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DAH  1
IP0L . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B8H  1
Check_PCB. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
AD_Hi. . . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   000AH  1
REN1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009CH  1
CCAP2L . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00ECH  1
CCAPM1 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DBH  1
IT2H . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C3H  1
ES . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ACH  1
TSTWD. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0097H  1
CCAP3L . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EDH  1
CCAPM2 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DCH  1
mV_Span_Value. . . . . . . . . . . . .  PUBLIC   DATA   U_INT    000BH  2
IT3H . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C7H  1
CCAP4L . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EEH  1
CCAPM3 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DDH  1
IP . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B8H  1
CCAP5L . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EFH  1
CCAPM4 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DEH  1
RI . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0098H  1
CCAPM5 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DFH  1
TC_Type. . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   000DH  1
INT0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B2H  1
CY . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D7H  1
DO_RESET_TYPE. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
mA_Zero_offset . . . . . . . . . . . .  PUBLIC   DATA   U_INT    000EH  2
BEEP . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B4H  1
mV_OUT . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0084H  1
INT1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B3H  1
TI . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0099H  1
EEP_SCL. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A3H  1
INT2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EBH  1
Volt_Ctrl. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
INT3 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EAH  1
ADCV . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C6H  1
STRETCH. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008FH  1
AD_Lo. . . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0010H  1
PT0L . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B9H  1
CAIT . . . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0011H  1
PT1L . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BBH  1
RCAP2H . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CBH  1
RTC_SDA. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A2H  1
C51 COMPILER V9.02   MAIN                                                                  01/05/2015 11:22:37 PAGE 45  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


PS . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BCH  1
PT2L . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BDH  1
SP . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0081H  1
mV_Span_offset . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0012H  2
T2EX . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0091H  1
CMOD . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D9H  1
CCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D8H  1
SCFG . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009AH  1
RTC_WRITE_SET. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
PX0L . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B8H  1
OV . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D2H  1
Disp_year. . . . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0014H  2
PX1L . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BAH  1
RCAP2L . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CAH  1
main . . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
PX2L . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BEH  1
SPI_CLK. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0097H  1
PX3L . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BFH  1
SCMD . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E6H  1
WR . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B6H  1
C_T2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C9H  1
Work_Type. . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0016H  1
DO_SETUP_TYPE. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  set_key. . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0000H  1
  times. . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0001H  1
  Itemm. . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0002H  1
  hin. . . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0003H  1
  lon. . . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0004H  1
  item_key . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0005H  1
  confrom_key. . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0006H  1
  up_key . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0007H  1
  don_key. . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0008H  1
  value_cal. . . . . . . . . . . . . .  AUTO     DATA   U_INT    0009H  2
T0_cnt . . . . . . . . . . . . . . . .  PUBLIC   IDATA  U_CHAR   0008H  1
SPISTAT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0084H  1
T1_cnt . . . . . . . . . . . . . . . .  PUBLIC   IDATA  U_CHAR   0009H  1
Get_Key. . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
T2_cnt . . . . . . . . . . . . . . . .  PUBLIC   IDATA  U_CHAR   000AH  1
_Get_E_Slope . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
RTC_SCL. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0096H  1
RCLK . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CDH  1
Soft_Timer_Enable. . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0017H  1
DO_TC_TYPE . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Code_Value . . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
  TC_Value . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0002H  2
  key. . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
TCLK . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CCH  1
P00. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0080H  1
IFADRH . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E3H  1
MAIN_SW. . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0018H  1
P10. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0090H  1
P01. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0081H  1
IFMT . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E5H  1
PCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0087H  1
SBUF . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0099H  1
mV_Zero_offset . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0019H  2
_Get_J_Slope . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
C51 COMPILER V9.02   MAIN                                                                  01/05/2015 11:22:37 PAGE 46  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


P20. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A0H  1
P11. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0091H  1
P02. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0082H  1
_Get_K_Slope . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
Get_AD3421_Value . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
P30. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B0H  1
P21. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A1H  1
P12. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0092H  1
P03. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0083H  1
FUNCTION_KEY . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B2H  1
P40. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00E8H  1
P31. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B1H  1
P22. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A2H  1
P13. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0093H  1
P04. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0084H  1
IFADRL . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E4H  1
SCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0098H  1
InitUart . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
RTC_READ_SET . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
P50. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00F8H  1
P41. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00E9H  1
P32. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B2H  1
P23. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A3H  1
P14. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0094H  1
P05. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0085H  1
TMOD . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0089H  1
TCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0088H  1
P60. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C8H  1
P51. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00F9H  1
P42. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EAH  1
P33. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B3H  1
P24. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A4H  1
P15. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0095H  1
P06. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0086H  1
tran . . . . . . . . . . . . . . . . .  PUBLIC   DATA   BIT      0001H  1
P61. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C9H  1
P52. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00FAH  1
P43. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EBH  1
P34. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B4H  1
P25. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A5H  1
P16. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0096H  1
P07. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0087H  1
P53. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00FBH  1
P44. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ECH  1
P35. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B5H  1
P26. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A6H  1
P17. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0097H  1
Value_SDA. . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A0H  1
P45. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EDH  1
P36. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B6H  1
P27. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A7H  1
_Get_R_Slope . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
TC_C . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0080H  1
P46. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EEH  1
P37. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B7H  1
ex_int0. . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
_Get_S_Slope . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
C51 COMPILER V9.02   MAIN                                                                  01/05/2015 11:22:37 PAGE 47  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


P47. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EFH  1
KBMASK . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D7H  1
_Get_T_Slope . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_Set_mA. . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_SETUP_LED_Disp. . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
OUT_SCL. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A4H  1
PORT_Init. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
AD_SDA . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A0H  1
IE0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0089H  1
LED_Fill . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
IE1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008BH  1
RTD_Span_Value . . . . . . . . . . . .  PUBLIC   DATA   U_INT    001BH  2
LED1_SDA . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0090H  1
IE2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C1H  1
EEPROM_Init. . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
LED2_SDA . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0093H  1
IE3. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C5H  1
GF4. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AEH  1
AUXR . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008EH  1
B. . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F0H  1
KBPATN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D5H  1
Value_SCL. . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A1H  1
ReceiveFlag. . . . . . . . . . . . . .  PUBLIC   DATA   BIT      0002H  1
CP_RL2 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C8H  1
NONE_4 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A6H  1
DO_mA_TYPE . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  mA_Value . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
  key. . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
NONE_5 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A7H  1
AD3421_Init. . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
NONE_6 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B6H  1
SPIDAT . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0086H  1
ACC. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E0H  1
ReceiveDate. . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   001DH  1
eep_count. . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   001EH  1
_LED_Disp. . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
NONE_7 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B7H  1
AD_SCL . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A1H  1
ES0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ACH  1
PCB_SETUP. . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   001FH  1
ET0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A9H  1
key. . . . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0020H  1
LED1_SCL . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0092H  1
TF0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008DH  1
ET1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ABH  1
use_flag . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0021H  1
RTD_Span_offset. . . . . . . . . . . .  PUBLIC   DATA   U_INT    0022H  2
LED2_SCL . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0094H  1
TF1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008FH  1
RI0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0098H  1
ET2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ADH  1
NG_COD . . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0024H  1
LED_Init . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
TF2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CFH  1
RI1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0098H  1
RB8. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009AH  1
TH0. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008CH  1
C51 COMPILER V9.02   MAIN                                                                  01/05/2015 11:22:37 PAGE 48  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


IT0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0088H  1
TI0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0099H  1
EX0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A8H  1
TH1. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008DH  1
AV_COD . . . . . . . . . . . . . . . .  EXTERN   DATA   U_CHAR   -----  1
IT1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008AH  1
TI1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0099H  1
TB8. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009BH  1
EX1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AAH  1
SPICON . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0085H  1
TH2. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CDH  1
IT2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C0H  1
EX2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C2H  1
P. . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D0H  1
alarm_Hi_set . . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0025H  2
IT3. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C4H  1
EX3. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C6H  1
SM0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009FH  1
TL0. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008AH  1
_Set_mV. . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
mA_C . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0083H  1
XOUT . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C8H  1
ECI. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0091H  1
SM1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009EH  1
SPICTL . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0085H  1
TL1. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008BH  1
AUXIPH . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00AFH  1
alarm_Low_set. . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0027H  2
ALE. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EEH  1
SM2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009DH  1
TL2. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CCH  1
_Get_RTD_Slope . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
IFD. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E2H  1
PT0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B9H  1
NP_COD . . . . . . . . . . . . . . . .  EXTERN   DATA   U_CHAR   -----  1
R485_DE_RE . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B5H  1
PT1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BBH  1
RS0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D3H  1
TR0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008CH  1
PT2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BDH  1
RS1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D4H  1
TR1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008EH  1
TR2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CAH  1
PX0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B8H  1
EIP1H. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00AFH  1
RTD_Zero_offset. . . . . . . . . . . .  PUBLIC   DATA   U_INT    0029H  2
PX1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BAH  1
key_bak. . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   002BH  1
PX2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C3H  1
DO_mV_TYPE . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  mV_Value . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
  key. . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
PX3. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C7H  1
Data_Value . . . . . . . . . . . . . .  PUBLIC   IDATA  ARRAY    000BH  20
EIP1L. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00AEH  1
DPH. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0083H  1
use_week . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   002CH  1
C51 COMPILER V9.02   MAIN                                                                  01/05/2015 11:22:37 PAGE 49  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


CKO. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C8H  1
_EEPROM_read_byte. . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
DPL. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0082H  1
time0. . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Value_code . . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
PCON0. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0087H  1
SPSTAT . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0084H  1
SBUF0. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0099H  1
IPH. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B7H  1
time1. . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
use_year . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   002DH  1
T0CKO. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B4H  1
PCON1. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0097H  1
SBUF1. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0099H  1
T1CKO. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B5H  1
EXEN2. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CBH  1
PCON2. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C7H  1
S2BUF. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009AH  1
NONE3. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A5H  1
none2. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0097H  1
SCON0. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0098H  1
REN. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009CH  1
SCON1. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0098H  1
mV_C . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0082H  1
ADCON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C5H  1
RTC_ON . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
mA_SDA . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A2H  1
T2MOD. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C9H  1
T2CON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C8H  1
_EEPROM_read_word. . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
ADCTL. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C5H  1
n_code . . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   002EH  1
use_sec. . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   002FH  1
ADCVL. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BEH  1
TC_Span_Value. . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0030H  2
wchar_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  CHAR     -----  1
SADEN. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B9H  1
AD_Status. . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0032H  1
C_F_Type . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0033H  1
S1BRT. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009AH  1
use_day. . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0034H  1
RXD. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B0H  1
KBCON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D6H  1
use_hour . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0035H  1
UP_KEY . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0086H  1
XIN. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C9H  1
PSL. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BCH  1
SADDR. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A9H  1
_EEPROM_write_byte . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
TXD. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B1H  1
mA_SCL . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A4H  1
AUXR0. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008EH  1
AUXR1. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A2H  1
SPI_SS . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0094H  1
AUXR2. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A6H  1
use_min. . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0036H  1
OVER_COD . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0037H  1
C51 COMPILER V9.02   MAIN                                                                  01/05/2015 11:22:37 PAGE 50  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


S2RXD. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0092H  1
F0 . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D5H  1
BEEP_OUT . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B4H  1
S2TXD. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0093H  1
F1 . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D1H  1
TC_Span_offset . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0038H  2
_EEPROM_write_word . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
LED1_LE. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0091H  1
LED2_LE. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0095H  1
T0_Init. . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
use_mon. . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   003AH  1
PCAPWM0. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F2H  1
PSW. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D0H  1
T1_Init. . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
PCAPWM1. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F3H  1
T2_Init. . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
mV_SDA . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A2H  1
CCF0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D8H  1
RB80 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009AH  1
PCAPWM2. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F4H  1
CCF1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D9H  1
RB81 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009AH  1
PCAPWM3. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F5H  1
SPDAT. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0086H  1
P0M0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0093H  1
AUXIE. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00ADH  1


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6483    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     59      29
   IDATA SIZE       =     31    ----
   BIT SIZE         =      3    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
