C51 COMPILER V9.02   MAIN                                                                  03/30/2015 14:00:36 PAGE 1   


C51 COMPILER V9.02, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c OMF2 BROWSE DEBUG LISTINCLUDE SYMBOLS PREPRINT

line level    source

   1          /***********************************************
   2            PRODUCT FOR NEWCAL MIX_TEMP FUNCTION
   3             CPU : MPC82G516
   4             BEGIN DATE: 2013.11.01
   5             FINISHED  : 2014.01.25
   6             WRITEBY   :JOHNSON LIN
   7             AD111  setup   SET 1001 0000 FOR A0 TYPE 
   8              8CH =  pga =1 ,32767BITS
   9          **************************************************/
  10          #include <MG82FE564.H>
   1      =1  // (System)
   2      =1  sfr ACC       = 0xE0;
   3      =1  sfr B         = 0xF0;
   4      =1  sfr SP        = 0x81;
   5      =1  sfr DPL       = 0x82;
   6      =1  sfr DPH       = 0x83;
   7      =1  sfr PSW       = 0xD0;
   8      =1  
   9      =1  // (Interrupt)
  10      =1  sfr IE        = 0xA8;
  11      =1  sfr EIE1      = 0xAD;
  12      =1  sfr AUXIE     = 0xAD;
  13      =1  sfr XICON     = 0xC0;
  14      =1  sfr IP0L      = 0xB8;
  15      =1  sfr IP        = 0xB8;
  16      =1  sfr IP0H      = 0xB7;
  17      =1  sfr IPH       = 0xB7;
  18      =1  sfr EIP1L     = 0xAE;
  19      =1  sfr AUXIP     = 0xAE;
  20      =1  sfr EIP1H     = 0xAF;
  21      =1  sfr AUXIPH    = 0xAF;
  22      =1  
  23      =1  // (I/O Port)
  24      =1  sfr P0        = 0x80;
  25      =1  sfr P1        = 0x90;
  26      =1  sfr P2        = 0xA0;
  27      =1  sfr P3        = 0xB0;
  28      =1  sfr P4        = 0xE8;
  29      =1  sfr P5        = 0xF8;
  30      =1  sfr P6        = 0xC8;                            // Page F
  31      =1  sfr P0M0      = 0x93;
  32      =1  sfr P0M1      = 0x94;
  33      =1  sfr P1M0      = 0x91;
  34      =1  sfr P1M1      = 0x92;
  35      =1  sfr P2M0      = 0x95;
  36      =1  sfr P2M1      = 0x96;
  37      =1  sfr P3M0      = 0xB1;
  38      =1  sfr P3M1      = 0xB2;
  39      =1  sfr P4M0      = 0xB3;
  40      =1  sfr P4M1      = 0xB4;
  41      =1  sfr P5M0      = 0xB5;
  42      =1  sfr P5M1      = 0xB6;
  43      =1  
  44      =1  // (Timer)
  45      =1  sfr TCON      = 0x88;
C51 COMPILER V9.02   MAIN                                                                  03/30/2015 14:00:36 PAGE 2   

  46      =1  sfr TMOD      = 0x89;
  47      =1  sfr T2CON     = 0xC8;
  48      =1  sfr T2MOD     = 0xC9;
  49      =1  sfr RCAP2L    = 0xCA;
  50      =1  sfr RCAP2H    = 0xCB;
  51      =1  sfr TL0       = 0x8A;
  52      =1  sfr TL1       = 0x8B;
  53      =1  sfr TH0       = 0x8C;
  54      =1  sfr TH1       = 0x8D;
  55      =1  sfr TL2       = 0xCC;
  56      =1  sfr TH2       = 0xCD;
  57      =1  
  58      =1  // (Serial Port)
  59      =1  sfr SCON      = 0x98;
  60      =1  sfr SCON0     = 0x98;
  61      =1  sfr SCON1     = 0x98;                            // Page 1
  62      =1  sfr SBUF      = 0x99;
  63      =1  sfr SBUF0     = 0x99;
  64      =1  sfr SBUF1     = 0x99;                            // Page 1
  65      =1  sfr SADDR     = 0xA9;
  66      =1  sfr SADEN     = 0xB9;
  67      =1  sfr SCFG      = 0x9A;
  68      =1  sfr S1BRT     = 0x9A;
  69      =1  sfr S2BUF     = 0x9A;                            // Page 1
  70      =1  
  71      =1  // (ADC)
  72      =1  sfr ADCON     = 0xC5;
  73      =1  sfr ADCTL     = 0xC5;
  74      =1  sfr ADCV      = 0xC6;
  75      =1  sfr ADCH      = 0xC6;
  76      =1  sfr ADCVL     = 0xBE;
  77      =1  sfr ADCL      = 0xBE;
  78      =1  
  79      =1  // (Keypad Interrupt)
  80      =1  sfr KBCON     = 0xD6;
  81      =1  sfr KBPATN    = 0xD5;
  82      =1  sfr KBMASK    = 0xD7;
  83      =1  
  84      =1  // (SPI)
  85      =1  sfr SPSTAT    = 0x84;
  86      =1  sfr SPCON     = 0x85;
  87      =1  sfr SPDAT     = 0x86;
  88      =1  sfr SPISTAT   = 0x84;
  89      =1  sfr SPICON    = 0x85;
  90      =1  sfr SPIDAT    = 0x86;
  91      =1  sfr SPCTL     = 0x85;
  92      =1  sfr SPICTL    = 0x85;
  93      =1  
  94      =1  // (PCA)
  95      =1  sfr CCON      = 0xD8;
  96      =1  sfr CMOD      = 0xD9;
  97      =1  sfr CL        = 0xE9;
  98      =1  sfr CH        = 0xF9;
  99      =1  sfr CCAPM0    = 0xDA;
 100      =1  sfr CCAPM1    = 0xDB;
 101      =1  sfr CCAPM2    = 0xDC;
 102      =1  sfr CCAPM3    = 0xDD;
 103      =1  sfr CCAPM4    = 0xDE;
 104      =1  sfr CCAPM5    = 0xDF;
 105      =1  sfr CCAP0H    = 0xFA;
 106      =1  sfr CCAP0L    = 0xEA;
 107      =1  sfr CCAP1H    = 0xFB;
C51 COMPILER V9.02   MAIN                                                                  03/30/2015 14:00:36 PAGE 3   

 108      =1  sfr CCAP1L    = 0xEB;
 109      =1  sfr CCAP2H    = 0xFC;
 110      =1  sfr CCAP2L    = 0xEC;
 111      =1  sfr CCAP3H    = 0xFD;
 112      =1  sfr CCAP3L    = 0xED;
 113      =1  sfr CCAP4H    = 0xFE;
 114      =1  sfr CCAP4L    = 0xEE;
 115      =1  sfr CCAP5H    = 0xFF;
 116      =1  sfr CCAP5L    = 0xEF;
 117      =1  sfr PCAPWM0   = 0xF2;
 118      =1  sfr PCAPWM1   = 0xF3;
 119      =1  sfr PCAPWM2   = 0xF4;
 120      =1  sfr PCAPWM3   = 0xF5;
 121      =1  sfr PCAPWM4   = 0xF6;
 122      =1  sfr PCAPWM5   = 0xF7;
 123      =1  
 124      =1  // (Others)
 125      =1  sfr PCON      = 0x87;
 126      =1  sfr PCON0     = 0x87;
 127      =1  sfr PCON1     = 0x97;
 128      =1  sfr EVRCR     = 0x97;
 129      =1  sfr PCON2     = 0xC7;
 130      =1  sfr AUXR      = 0x8E;
 131      =1  sfr AUXR0     = 0x8E;
 132      =1  sfr AUXR1     = 0xA2;
 133      =1  sfr AUXR2     = 0xA6;
 134      =1  sfr STRETCH   = 0x8F;
 135      =1  sfr WDTCR     = 0xE1;
 136      =1  sfr TSTWD     = 0x97;
 137      =1  sfr SFRPI     = 0xAC;
 138      =1  
 139      =1  // (ISP)
 140      =1  sfr ISPCR     = 0xE7;
 141      =1  sfr IFMT      = 0xE5;
 142      =1  sfr IFD       = 0xE2;
 143      =1  sfr IFADRH    = 0xE3;
 144      =1  sfr IFADRL    = 0xE4;
 145      =1  sfr SCMD      = 0xE6;
 146      =1  
 147      =1  // (bits in PSW)
 148      =1  sbit CY       = PSW^7;
 149      =1  sbit AC       = PSW^6;
 150      =1  sbit F0       = PSW^5;
 151      =1  sbit RS1      = PSW^4;
 152      =1  sbit RS0      = PSW^3;
 153      =1  sbit OV       = PSW^2;
 154      =1  sbit F1       = PSW^1;
 155      =1  sbit P        = PSW^0;
 156      =1  
 157      =1  // (bits in IE)
 158      =1  sbit EA       = IE^7;
 159      =1  sbit GF4      = IE^6;
 160      =1  sbit ET2      = IE^5;
 161      =1  sbit ES       = IE^4;
 162      =1  sbit ES0      = IE^4;
 163      =1  sbit ET1      = IE^3;
 164      =1  sbit EX1      = IE^2;
 165      =1  sbit ET0      = IE^1;
 166      =1  sbit EX0      = IE^0;
 167      =1  
 168      =1  // (bits in IP0L)
 169      =1  sbit PX3L     = IP0L^7;
C51 COMPILER V9.02   MAIN                                                                  03/30/2015 14:00:36 PAGE 4   

 170      =1  sbit PX2L     = IP0L^6;
 171      =1  sbit PT2L     = IP0L^5;
 172      =1  sbit PSL      = IP0L^4;
 173      =1  sbit PT1L     = IP0L^3;
 174      =1  sbit PX1L     = IP0L^2;
 175      =1  sbit PT0L     = IP0L^1;
 176      =1  sbit PX0L     = IP0L^0;
 177      =1  
 178      =1  sbit PT2      = IP^5;
 179      =1  sbit PS       = IP^4;
 180      =1  sbit PT1      = IP^3;
 181      =1  sbit PX1      = IP^2;
 182      =1  sbit PT0      = IP^1;
 183      =1  sbit PX0      = IP^0;
 184      =1  
 185      =1  //(bits in SCON0)
 186      =1  sbit FE       = SCON0^7;
 187      =1  sbit SM00     = SCON0^7;
 188      =1  sbit SM10     = SCON0^6;
 189      =1  sbit SM20     = SCON0^5;
 190      =1  sbit REN0     = SCON0^4;
 191      =1  sbit TB80     = SCON0^3;
 192      =1  sbit RB80     = SCON0^2;
 193      =1  sbit TI0      = SCON0^1;
 194      =1  sbit RI0      = SCON0^0;
 195      =1  
 196      =1  sbit SM0      = SCON^7;
 197      =1  sbit SM1      = SCON^6;
 198      =1  sbit SM2      = SCON^5;
 199      =1  sbit REN      = SCON^4;
 200      =1  sbit TB8      = SCON^3;
 201      =1  sbit RB8      = SCON^2;
 202      =1  sbit TI       = SCON^1;
 203      =1  sbit RI       = SCON^0;
 204      =1  
 205      =1  //(bits in SCON1)
 206      =1  sbit SM01     = SCON1^7;
 207      =1  sbit SM11     = SCON1^6;
 208      =1  sbit SM21     = SCON1^5;
 209      =1  sbit REN1     = SCON1^4;
 210      =1  sbit TB81     = SCON1^3;
 211      =1  sbit RB81     = SCON1^2;
 212      =1  sbit TI1      = SCON1^1;
 213      =1  sbit RI1      = SCON1^0;
 214      =1  
 215      =1  // (bits in TCON)
 216      =1  sbit TF1      = TCON^7;
 217      =1  sbit TR1      = TCON^6;
 218      =1  sbit TF0      = TCON^5;
 219      =1  sbit TR0      = TCON^4;
 220      =1  sbit IE1      = TCON^3;
 221      =1  sbit IT1      = TCON^2;
 222      =1  sbit IE0      = TCON^1;
 223      =1  sbit IT0      = TCON^0;
 224      =1  
 225      =1  // (bits in T2CON)
 226      =1  sbit TF2      = T2CON^7;
 227      =1  sbit EXF2     = T2CON^6;
 228      =1  sbit RCLK     = T2CON^5;
 229      =1  sbit TCLK     = T2CON^4;
 230      =1  sbit EXEN2    = T2CON^3;
 231      =1  sbit TR2      = T2CON^2;
C51 COMPILER V9.02   MAIN                                                                  03/30/2015 14:00:36 PAGE 5   

 232      =1  sbit C_T2     = T2CON^1;
 233      =1  sbit CP_RL2   = T2CON^0;
 234      =1  
 235      =1  // (bits in CCON)
 236      =1  sbit CF       = CCON^7;
 237      =1  sbit CR       = CCON^6;
 238      =1  sbit CCF5     = CCON^5;
 239      =1  sbit CCF4     = CCON^4;
 240      =1  sbit CCF3     = CCON^3;
 241      =1  sbit CCF2     = CCON^2;
 242      =1  sbit CCF1     = CCON^1;
 243      =1  sbit CCF0     = CCON^0;
 244      =1  
 245      =1  // (bits in XICON)
 246      =1  sbit PX3      = XICON^7;
 247      =1  sbit IT3H     = XICON^7;
 248      =1  sbit EX3      = XICON^6;
 249      =1  sbit IE3      = XICON^5;
 250      =1  sbit IT3      = XICON^4;
 251      =1  sbit PX2      = XICON^3;
 252      =1  sbit IT2H     = XICON^3;
 253      =1  sbit EX2      = XICON^2;
 254      =1  sbit IE2      = XICON^1;
 255      =1  sbit IT2      = XICON^0;
 256      =1  
 257      =1  // (bits in P0)
 258      =1  sbit P07      = P0^7;
 259      =1  sbit P06      = P0^6;
 260      =1  sbit P05      = P0^5;
 261      =1  sbit P04      = P0^4;
 262      =1  sbit P03      = P0^3;
 263      =1  sbit P02      = P0^2;
 264      =1  sbit P01      = P0^1;
 265      =1  sbit P00      = P0^0;
 266      =1  
 267      =1  // (bits in P1)
 268      =1  sbit P17      = P1^7;
 269      =1  sbit P16      = P1^6;
 270      =1  sbit P15      = P1^5;
 271      =1  sbit P14      = P1^4;
 272      =1  sbit P13      = P1^3;
 273      =1  sbit P12      = P1^2;
 274      =1  sbit P11      = P1^1;
 275      =1  sbit P10      = P1^0;
 276      =1  
 277      =1  // (bits in P2)
 278      =1  sbit P27      = P2^7;
 279      =1  sbit P26      = P2^6;
 280      =1  sbit P25      = P2^5;
 281      =1  sbit P24      = P2^4;
 282      =1  sbit P23      = P2^3;
 283      =1  sbit P22      = P2^2;
 284      =1  sbit P21      = P2^1;
 285      =1  sbit P20      = P2^0;
 286      =1  
 287      =1  // (bits in P3)
 288      =1  sbit P37      = P3^7;
 289      =1  sbit P36      = P3^6;
 290      =1  sbit P35      = P3^5;
 291      =1  sbit P34      = P3^4;
 292      =1  sbit P33      = P3^3;
 293      =1  sbit P32      = P3^2;
C51 COMPILER V9.02   MAIN                                                                  03/30/2015 14:00:36 PAGE 6   

 294      =1  sbit P31      = P3^1;
 295      =1  sbit P30      = P3^0;
 296      =1  
 297      =1  // (bits in P4)
 298      =1  sbit P47      = P4^7;
 299      =1  sbit P46      = P4^6;
 300      =1  sbit P45      = P4^5;
 301      =1  sbit P44      = P4^4;
 302      =1  sbit P43      = P4^3;
 303      =1  sbit P42      = P4^2;
 304      =1  sbit P41      = P4^1;
 305      =1  sbit P40      = P4^0;
 306      =1  
 307      =1  // (bits in P5)
 308      =1  sbit P53      = P5^3;
 309      =1  sbit P52      = P5^2;
 310      =1  sbit P51      = P5^1;
 311      =1  sbit P50      = P5^0;
 312      =1  
 313      =1  // (bits in P6)
 314      =1  sbit P61      = P6^1;
 315      =1  sbit P60      = P6^0;
 316      =1  
 317      =1  // (bits in P1, alternate)
 318      =1  sbit T2EX     = P1^1;
 319      =1  sbit T2       = P1^0;
 320      =1  sbit S2TXD    = P1^3;
 321      =1  sbit S2RXD    = P1^2;
 322      =1  
 323      =1  sbit SPI_CLK  = P1^7;
 324      =1  sbit SPI_MISO = P1^6;
 325      =1  sbit SPI_MOSI = P1^5;
 326      =1  sbit SPI_SS   = P1^4;
 327      =1  
 328      =1  sbit CEX5     = P1^7;
 329      =1  sbit CEX4     = P1^6;
 330      =1  sbit CEX3     = P1^5;
 331      =1  sbit CEX2     = P1^4;
 332      =1  sbit CEX1     = P1^3;
 333      =1  sbit CEX0     = P1^2;
 334      =1  sbit ECI      = P1^1;
 335      =1  
 336      =1  sbit AIN7     = P1^7;
 337      =1  sbit AIN6     = P1^6;
 338      =1  sbit AIN5     = P1^5;
 339      =1  sbit AIN4     = P1^4;
 340      =1  sbit AIN3     = P1^3;
 341      =1  sbit AIN2     = P1^2;
 342      =1  sbit AIN1     = P1^1;
 343      =1  sbit AIN0     = P1^0;
 344      =1  
 345      =1  //(bits in P2, alternate)
 346      =1  sbit KBI7     = P2^7;
 347      =1  sbit KBI6     = P2^6;
 348      =1  sbit KBI5     = P2^5;
 349      =1  sbit KBI4     = P2^4;
 350      =1  sbit KBI3     = P2^3;
 351      =1  sbit KBI2     = P2^2;
 352      =1  sbit KBI1     = P2^1;
 353      =1  sbit KBI0     = P2^0;
 354      =1  
 355      =1  // (bits in P3, alternate)
C51 COMPILER V9.02   MAIN                                                                  03/30/2015 14:00:36 PAGE 7   

 356      =1  sbit RD       = P3^7;
 357      =1  sbit WR       = P3^6;
 358      =1  sbit T1       = P3^5;
 359      =1  sbit T0       = P3^4;
 360      =1  sbit INT1     = P3^3;
 361      =1  sbit INT0     = P3^2;
 362      =1  sbit TXD      = P3^1;
 363      =1  sbit RXD      = P3^0;
 364      =1  sbit T1CKO    = P3^5;
 365      =1  sbit T0CKO    = P3^4;
 366      =1  
 367      =1  // (bits in P4, alternate)
 368      =1  sbit INT2     = P4^3;
 369      =1  sbit INT3     = P4^2;
 370      =1  
 371      =1  sbit ALE      = P4^6;
 372      =1  
 373      =1  // (bits in P6, alternate)
 374      =1  sbit CKO      = P6^0;
 375      =1  sbit XOUT     = P6^0;
 376      =1  sbit XIN      = P6^1;
  11          #include <IO_DEFINE.h>
   1      =1  #ifndef IO_DEFINE_h_ 
   2      =1  #define IO_DEFINE_h_
   3      =1  
   4      =1  sbit TC_C    = P0^0;    //k=0x00;j=0x01;t=0x02;e=0x03; 
   5      =1  sbit RTD_C   = P0^1;    //r=0x04;s=0x05;b=0x06;n=0x07;
   6      =1  sbit mV_C    = P0^2;
   7      =1  sbit mA_C    = P0^3;     //tc= 000 00xxx;  rtd=000 01xxx;    mV=000 10xxx
   8      =1  sbit mV_OUT  = P0^4;     //mA= 000 11xxx;
   9      =1  sbit mA_OUT  = P0^5;
  10      =1  sbit UP_KEY   = P0^6;
  11      =1  sbit DOWN_KEY = P0^7;
  12      =1  
  13      =1  sbit LED1_SDA = P1^0;
  14      =1  sbit LED1_SCL = P1^2;
  15      =1  sbit LED1_LE  = P1^1;
  16      =1  sbit LED2_SDA  = P1^3;
  17      =1  sbit LED2_SCL  = P1^4;
  18      =1  sbit LED2_LE   = P1^5;
  19      =1  sbit RTC_SCL   = P1^6;
  20      =1  sbit non3      = P1^7;
  21      =1  
  22      =1  sbit AD_SDA   = P2^0;
  23      =1  sbit AD_SCL   = P2^1;
  24      =1  sbit ALL_SDA  = P2^2;
  25      =1  sbit EEP_SCL  = P2^3;
  26      =1  sbit OUT_SCL  = P2^4;
  27      =1  sbit TEMP    = P2^5;
  28      =1  sbit NONE_4   = P2^6;
  29      =1  sbit NONE_5   = P2^7;
  30      =1  sbit RTC_SDA  = P2^2;
  31      =1  
  32      =1  sbit R485_RX           = P3^0;
  33      =1  sbit R485_TX           = P3^1;
  34      =1  sbit FUNCTION_KEY      = P3^2;
  35      =1  sbit OFFSET_KEY        = P3^3;
  36      =1  sbit BEEP_OUT          = P3^4;   //for relay
  37      =1  sbit R485_DE_RE        = P3^5;
  38      =1  sbit NONE_6            = P3^6;
  39      =1  sbit NONE_7            = P3^7;
  40      =1  //------------------------
C51 COMPILER V9.02   MAIN                                                                  03/30/2015 14:00:36 PAGE 8   

  41      =1  sbit EEPROM_SDA = P2^2;
  42      =1  sbit EEPROM_SCL = P2^3;
  43      =1  
  44      =1  sbit Value_SDA  = P2^0;
  45      =1  sbit Value_SCL  = P2^1;
  46      =1  sbit BEEP       = P3^4;  //for relay
  47      =1  
  48      =1  sbit mV_SDA   = P2^2;
  49      =1  sbit mV_SCL   = P2^4;
  50      =1  sbit mA_SDA   = P2^2;
  51      =1  sbit mA_SCL   = P2^4;
  52      =1  
  53      =1  #endif
  12          #include <LED.h>
   1      =1  #ifndef LED_h_ 
   2      =1  #define LED_h_ 
   3      =1  
   4      =1  
   5      =1  void LED_Disp(unsigned char LEDs, unsigned  int disp_value);
   6      =1  void SETUP_LED_Disp(unsigned char SETUP_SELECT, unsigned int disp_value);
   7      =1  void LED_DATA_Write(unsigned char prt,unsigned char D5,unsigned char D4,unsigned char D3,unsigned char D2,
             -unsigned char D1,unsigned char D0);
   8      =1  void DAY_LED_Disp(unsigned char DD,unsigned char HH, unsigned char MM);
   9      =1  void LED_Init(void);
  10      =1  void LED_Cls(void);
  11      =1  void LED_Fill(void);
  12      =1  #endif
  13          #include <AD3421.h>
   1      =1  /************************************************************************
   2      =1  * FileName     : i2c.h
   3      =1  * Description  : Default MPC82G516 to ctrl AD111A0 IC function.
   4      =1  *
   5      =1  *
   6      =1  * Version control:
   7      =1  ***************************************************************************/
   8      =1  #ifndef __AD3421_H__
   9      =1  #define __AD3421_H__
  10      =1  
  11      =1  
  12      =1  void AD3421_Init(void);
  13      =1  void AD3421_start(void);
  14      =1  void AD3421_stop(void);
  15      =1  void AD3421_write_byte(unsigned char bt);
  16      =1  unsigned char AD3421_read_byte(unsigned char lastbyte);         
  17      =1  void AD3421_write_com(unsigned char dev_id, unsigned char reg_addr);
  18      =1  unsigned char AD3421_read_com(unsigned char dev_id);
  19      =1  void S_Delay(unsigned int n);
  20      =1  unsigned char Get_AD3421_Value(void);
  21      =1  
  22      =1  unsigned int  SetmA(unsigned int mA_Value);
  23      =1  unsigned int  SetmV(unsigned int mV_Value);       
  24      =1  
  25      =1  
  26      =1  void DAC_write(unsigned char ch_id, unsigned int ma);
  27      =1  void Clear_key_delay(void);
  28      =1  unsigned char EEPROM_write(unsigned char reg_addr, unsigned int reg_data);
  29      =1  unsigned char   EEPROM_read_byte(unsigned char reg_addr);
  30      =1  unsigned char KeyScan(void);
  31      =1  unsigned char voicePlay(unsigned char id, unsigned char vol);
  32      =1  unsigned char Get_Key(void);
  33      =1  
  34      =1  #define         TRUE    1
C51 COMPILER V9.02   MAIN                                                                  03/30/2015 14:00:36 PAGE 9   

  35      =1  #define         FALSE   0
  36      =1  
  37      =1  #endif 
  14          #include <DAC6571_mV.h>
   1      =1  /************************************************************************
   2      =1  * FileName     : i2c.h
   3      =1  * Description  : Default MPC82G516 to ctrl AD111A0 IC function.
   4      =1  *
   5      =1  *
   6      =1  * Version control:
   7      =1  ***************************************************************************/
   8      =1  #ifndef __DAC6571_mV_H__
   9      =1  #define __DAC6571_mV_H__
  10      =1  
  11      =1  void DAC6571mV_Init(void);
  12      =1  void DAC6571mV_start(void);
  13      =1  void DAC6571mV_stop(void);
  14      =1  void DAC6571mV_write_byte(unsigned char bt);
  15      =1  void mV_Delay(unsigned int n);
  16      =1  void Set_mV(unsigned int mV_V);   
  17      =1  
  18      =1  #define         TRUE    1
  19      =1  #define         FALSE   0
  20      =1  
  21      =1  #endif 
  15          #include <DAC6571_mA.h>
   1      =1  /************************************************************************
   2      =1  * FileName     : i2c.h
   3      =1  * Description  : Default MPC82G516 to ctrl AD111A0 IC function.
   4      =1  *
   5      =1  *
   6      =1  * Version control:
   7      =1  ***************************************************************************/
   8      =1  #ifndef __DAC6571_mA_H__
   9      =1  #define __DAC6571_mA_H__
  10      =1  
  11      =1  
  12      =1  void DAC6571mA_Init(void);
  13      =1  void DAC6571mA_start(void);
  14      =1  void DAC6571mA_stop(void);
  15      =1  void DAC6571mA_write_byte(unsigned char bt);
  16      =1  void mA_Delay(unsigned int n);
  17      =1  void Set_mA(unsigned int mA_Value);
  18      =1  
  19      =1  #define         TRUE    1
  20      =1  #define         FALSE   0
  21      =1  
  22      =1  #endif 
  16          #include <MCP79411.h>
   1      =1  /********************************
   2      =1  **          RTC.DEVICE     **
   3      =1  *********************************/
   4      =1  #ifndef __mcp79411_H_
   5      =1  #define __mcp79411_H_
   6      =1  
   7      =1  void RTC_Delay(unsigned int i);
   8      =1  void RTC_BitDly(void);  
   9      =1  //void RTC_Init(void);
  10      =1  void RTC_start0(void);  
  11      =1  void RTC_stop0(void);
  12      =1  void RTC_restart0(void);
  13      =1  void RTC_write_byte0(unsigned char bt);
C51 COMPILER V9.02   MAIN                                                                  03/30/2015 14:00:36 PAGE 10  

  14      =1  void RTC_write_byte(unsigned char reg_addr,unsigned char reg_data);
  15      =1  void RTC_write_word(unsigned char addr, unsigned int intdata);
  16      =1  unsigned char RTC_read_byte0(void);
  17      =1  unsigned char RTC_read_byte(unsigned char reg_addr);
  18      =1  unsigned int  RTC_read_word(unsigned char addr);
  19      =1  void RTC_WRITE_SET(void);
  20      =1  void RTC_READ_SET(void);
  21      =1  void RTC_ON(void);
  22      =1  void RTC_Write_Default(void);
  23      =1  
  24      =1  #endif
  17          #include <EEPROM.H>
   1      =1  /********************************
   2      =1  **          EEPROM.DEVICE          **
   3      =1  *********************************/
   4      =1  #ifndef __EEPROM_H
   5      =1  #define __EEPROM_H
   6      =1  
   7      =1  void EEPROM_Delay(unsigned int i);
   8      =1  void EEPROM_BitDly(void);
   9      =1  void EEPROM_Init(void);
  10      =1  void EEPROM_start0(void);
  11      =1  void EEPROM_stop0(void);
  12      =1  void EEPROM_restart0(void);
  13      =1  
  14      =1  void EEPROM_write_byte0(unsigned char bt);
  15      =1  void EEPROM_write_byte(unsigned char reg_addr,unsigned char reg_data);
  16      =1  void EEPROM_write_word(unsigned char addr, unsigned int intdata);
  17      =1  
  18      =1  unsigned char EEPROM_read_byte0(void);
  19      =1  unsigned char EEPROM_read_byte(unsigned char reg_addr);
  20      =1  unsigned int  EEPROM_read_word(unsigned char addr);
  21      =1  void EEPROM_Write_Default(void);
  22      =1  
  23      =1  #endif
  18          #include <STDLIB.H>
   1      =1  /*--------------------------------------------------------------------------
   2      =1  STDLIB.H
   3      =1  
   4      =1  Standard functions.
   5      =1  Copyright (c) 1988-2005 Keil Elektronik GmbH and Keil Software, Inc.
   6      =1  All rights reserved.
   7      =1  --------------------------------------------------------------------------*/
   8      =1  
   9      =1  #ifndef __STDLIB_H__
  10      =1  #define __STDLIB_H__
  11      =1  
  12      =1  #ifndef _SIZE_T
  13      =1   #define _SIZE_T
  14      =1  
  15      =1  typedef unsigned int size_t;
  16      =1  #endif
  17      =1  
  18      =1  #ifndef NULL
  19      =1   #define NULL ((void *) 0L)
  20      =1  #endif
  21      =1  
  22      =1  #ifndef _WCHAR_T_DEFINED_
  23      =1  #define _WCHAR_T_DEFINED_
  24      =1  
  25      =1  typedef char wchar_t;
  26      =1  #endif
C51 COMPILER V9.02   MAIN                                                                  03/30/2015 14:00:36 PAGE 11  

  27      =1  
  28      =1  #ifndef RAND_MAX
  29      =1   #define RAND_MAX  32767u
  30      =1  #endif
  31      =1  
  32      =1  #pragma SAVE
  33      =1  #pragma REGPARMS
  34      =1  
  35      =1  extern int    abs  (int   val);
  36      =1  extern long  labs  (long  val);
  37      =1  
  38      =1  extern float atof (char *s1);
  39      =1  extern long  atol (char *s1);
  40      =1  extern int   atoi (char *s1);
  41      =1  extern int   rand ();
  42      =1  extern void  srand (int);
  43      =1  
  44      =1  extern float         strtod  (char *, char **);
  45      =1  extern long          strtol  (char *, char **, unsigned char);
  46      =1  extern unsigned long strtoul (char *, char **, unsigned char);
  47      =1  
  48      =1  #define _MALLOC_MEM_    xdata
  49      =1  
  50      =1  extern void init_mempool          (void _MALLOC_MEM_ *p, unsigned int size);
  51      =1  extern void _MALLOC_MEM_ *malloc  (unsigned int size);
  52      =1  extern void free                  (void _MALLOC_MEM_ *p);
  53      =1  extern void _MALLOC_MEM_ *realloc (void _MALLOC_MEM_ *p, unsigned int size);
  54      =1  extern void _MALLOC_MEM_ *calloc  (unsigned int size, unsigned int len);
  55      =1  
  56      =1  #pragma RESTORE
  57      =1  
  58      =1  #endif
  19          #include <TYPE_SLOPE.H>
   1      =1  /*************************************
   2      =1   SLOPE FOR PER TYPE AND GAIN 
   3      =1  
   4      =1  **************************************/
   5      =1  #ifndef SLOPE_h_ 
   6      =1  #define SLOPE_h_ 
   7      =1  
   8      =1  unsigned int Get_K_Slope(unsigned  int kt);
   9      =1  unsigned int Get_J_Slope(unsigned  int jt);
  10      =1  unsigned int Get_T_Slope(unsigned  int ts);
  11      =1  unsigned int Get_E_Slope(unsigned  int et);
  12      =1  unsigned int Get_R_Slope(unsigned  int rt);
  13      =1  unsigned int Get_S_Slope(unsigned  int st);
  14      =1  unsigned int Get_B_Slope(unsigned  int bt);
  15      =1  unsigned int Get_N_Slope(unsigned  int nt); 
  16      =1  unsigned int Get_RTD_Slope(unsigned int rtd);
  17      =1  unsigned int DO_RTD_TYPE(void);
  18      =1  unsigned int Read_AD3421_Value(void);
  19      =1  unsigned int Check_Type_Offset(unsigned int ss);
  20      =1  #endif
  20          
  21          #define   BASE_TEMP             32       //F & C Transfor Data
  22          #define   MAX_TEMP              3240     //F 1800C
  23          #define   MAX_VOLT              2048     //mV
  24          #define   EEP_START             60
  25          #define   EEP_END               2000
  26          #define   JOHNSON       0x5a
  27          #define   LIN           0xa5
  28          
C51 COMPILER V9.02   MAIN                                                                  03/30/2015 14:00:36 PAGE 12  

  29          #define   K_TYPE                0               //2466F   54.807mV      P0=0x00
  30          #define   J_TYPE                1               //1368F   42.922mV
  31          #define   T_TYPE            2           //360F    9.286mV
  32          #define   E_TYPE                3               //1440F   61.022mV
  33          #define   R_TYPE                4               //2880F   18.842mV
  34          #define   S_TYPE                5               //2880F   16.771mV
  35          #define   B_TYPE                6               //3240F   13.585mV
  36          #define   N_TYPE            7           //?       ?
  37          
  38          #define TC_FUNCTION             0
  39          #define RTD_FUNCTION    1
  40          #define mV_FUNCTION             2
  41          #define mA_FUNCTION             3
  42          #define SETUP_FUNCTION  4
  43          #define CLEAR_FUNCTION  5
  44          
  45          #define   ON    1
  46          #define   OFF   0
  47          
  48          //timer out work select
  49          #define DISPLAY_SEND_TIME  0     // DISPLAY TIME  
  50          #define ADC_READ_TIME      1     //     ADC_READ_TIME
  51          #define RTC_READ_TIME      2     //     RTC_READ_TIME
  52          #define RTC_SEND_TIME      3     //     RTC_SEND_TIME
  53          #define UART_SEND_TIME     4     //     UART_SEND_TIME
  54          #define MV_SEND_TIME       5     // mV_OUT_ TIME
  55          #define SETUP_TIMEOUT      6     //     FAIL_TIMEOUT
  56          #define TIMEUP_TIME        7     //
  57          #define TEMP_TIME          8     //
  58          
  59          #define NOMAL_FUNCTION    0
  60          #define MODE_CAL          1
  61          #define C_F_CAL           2
  62          #define TYPE_CAL          3
  63          #define TC_ZERO_CAL       4
  64          #define TC_SPAN_CAL       5
  65          #define RTD_ZERO_CAL      6
  66          #define RTD_SPAN_CAL      7
  67          #define mV_ZERO_CAL       8
  68          #define mV_SPAN_CAL       9
  69          #define mA_ZERO_CAL       10
  70          #define mA_SPAN_CAL       11
  71          #define ALARM_LO_CAL      12
  72          #define ALARM_HI_CAL      13
  73          #define YEAR_DATE_CAL     14
  74          #define MON_DATE_CAL      15
  75          #define DAY_DATE_CAL      16
  76          #define HOUR_DATE_CAL     17
  77          #define MIN_DATE_CAL      18
  78          //#define SEC_DATE_CAL      19
  79          #define PRODUCT_RESET     19
  80          #define  SQWE           0x40            //  SQWE = b6  
  81          #define  MFP_01H        0x00 
  82          #define  OSC_EN         0x80                    // day bit 7
  83          
  84          #define  sec     0x00  
  85          #define  min     0x01 
  86          #define  hour    0x02
  87          #define  week    0x03
  88          #define  day     0x04
  89          #define  month   0x05
  90          #define  year    0x06
C51 COMPILER V9.02   MAIN                                                                  03/30/2015 14:00:36 PAGE 13  

  91          #define  ctl     0x07
  92                             
  93          #define  Mode_Select 18    //EEP Address
  94          #define  C_F_Select  19
  95          #define  Type_Select 20
  96          #define  TC_Zero     22   
  97          #define  TC_Span     24
  98          #define  RTD_Zero    26
  99          #define  RTD_Span    28
 100          #define  mV_Zero     30                                                                   
 101          #define  mV_Span     32
 102          #define  mA_Zero     34
 103          #define  mA_Span     36
 104          #define  Alarm_Low   38
 105          #define  Alarm_Hi    40
 106          #define  Year_Date   42
 107          #define  Mon_Date    43
 108          #define  Day_Date    44
 109          #define  Week_Date   45
 110          #define  Hour_Date   46
 111          #define  Min_Date    47
 112          #define  sec_Date    48
 113          #define  Status_flag 50
 114          #define  TC_Span_Per 52
 115          #define  RTD_Span_Per 54
 116          #define  mV_Span_Per 56
 117          #define  mA_Span_Per 58
 118          
 119          #define  EEP_ADR     64
 120          //===============================
 121          extern unsigned char key = 0,key_bak = 0;
 122          extern unsigned char AV_COD ;
 123          extern unsigned char NP_COD ;
 124          unsigned char NG_COD,ADD_COD;
 125          unsigned char OVER_COD = 0 ;
 126          idata unsigned char Soft_Timer[9] = {16,16,4,2,59,2,20,30,2};
 127          idata unsigned char T0_cnt,T2_cnt, T1_cnt;
 128          idata unsigned char Temp_Flag = 3 ;
 129          idata unsigned int   Data_Value[10] ;
 130          unsigned int  Temp_sp = 0 ;
 131          unsigned char MAIN_SW;
 132          unsigned char Work_Type;
 133          unsigned char C_F_Type;
 134          unsigned char TC_Type;
 135          unsigned int  TC_Zero_offset;
 136          unsigned int  TC_Span_offset;
 137          unsigned int  RTD_Zero_offset;
 138          unsigned int  RTD_Span_offset;
 139          unsigned int  mV_Zero_offset;
 140          unsigned int  mV_Span_offset;
 141          unsigned int  mA_Zero_offset;
 142          unsigned int  mA_Span_offset;
 143          unsigned int  alarm_Low_set;
 144          unsigned int  alarm_Hi_set;
 145          unsigned int  TC_Span_Value = 0;
 146          unsigned int  RTD_Span_Value = 0;
 147          unsigned int  mV_Span_Value = 0;
 148          unsigned int  mA_Span_Value = 0;
 149          unsigned int  Temp_offset = 0 ; 
 150          unsigned int  Temp_m = 0 ;  
 151          unsigned int  use_flag;
 152          unsigned char  use_year = 0x14;
C51 COMPILER V9.02   MAIN                                                                  03/30/2015 14:00:36 PAGE 14  

 153          unsigned char  use_mon  = 0x01;
 154          unsigned char  use_day  = 0x01;
 155          unsigned char  use_week = 0x03;
 156          unsigned char  use_hour = 0x12;
 157          unsigned char  use_min  = 0x01;
 158          unsigned char  use_sec  = 0x01;
 159          //unsigned char  eep_count;
 160          unsigned int   Disp_year;
 161          unsigned char  n_code = 0 ;
 162          unsigned char CAIT = 0x01;
 163          unsigned char Func_Type;
 164          unsigned char AD_Hi;
 165          unsigned char AD_Mid;
 166          unsigned char AD_Lo;
 167          unsigned char AD_Status;
 168          unsigned char PCB_SETUP;
 169          unsigned char Soft_Timer_Enable = 0;
 170          unsigned char Key_backup, ReceiveDate;
 171          
 172          bit f_half_sec;
 173          bit ReceiveFlag = 0;
 174          bit tran = 0 ;
 175          bit Zero_f = 0 ;
 176          /***************************************
 177                     Port In/Out Setting
 178          *****************************************/
 179          void PORT_Init(void)
 180          {
 181   1              P0M0 = 0xFF;      //00=Qb,01=pull output, 10= input only,11=open drain
 182   1              P0M1 = 0x00;     //P0= ALL INPUT
 183   1              P0   = 0xff;
 184   1      
 185   1              P1M0 = 0x00;     //P1= ALL OUTPUT
 186   1              P1M1 = 0xFF;     //SETUP P1 ALL LO //  define P1.3 P1.4 P1.5 as push-pull
 187   1          P1   = 0x00;
 188   1      
 189   1              P2M0 = 0x04;     //P2= ALL OUTOUT
 190   1              P2M1 = 0xDF;     //SETUP P2 ALL LO
 191   1              P2   = 0x00;
 192   1      
 193   1          P3M0 = 0xED;         //
 194   1              P3M1 = 0x13;
 195   1              P3   = 0x2C;
 196   1      }
 197          /*******************************************
 198               interrupt   0
 199          *******************************************/
 200          void ex_int0(void) interrupt 0
 201          {;
 202   1      }
 203          /*******************************************
 204               interrupt   1
 205          *******************************************/
 206          void time0(void) interrupt  1     //   T=1/16 sec 
 207          {
 208   1       unsigned int Value_code;
 209   1              TR0 = 0;
 210   1              T1_cnt++;
 211   1              if ((T1_cnt%8)==0)
 212   1              Value_code = SBUF;
 213   1              TH0 = 0x0B;      //0b
 214   1              TL0 = 0xDC;
C51 COMPILER V9.02   MAIN                                                                  03/30/2015 14:00:36 PAGE 15  

 215   1              TR0 = 1;
 216   1      }
 217          
 218          /*******************************************
 219               interrupt   3
 220          *******************************************/
 221          void time1(void) interrupt  3   //    T=1/16 sec 
 222          {
 223   1              TR1 = 0;
 224   1              T0_cnt++;                                                       
 225   1      
 226   1              if (Soft_Timer[DISPLAY_SEND_TIME] != 0)         Soft_Timer[DISPLAY_SEND_TIME]--;
 227   1              if (Soft_Timer[ADC_READ_TIME] != 0)         Soft_Timer[ADC_READ_TIME]--;
 228   1              if ((T0_cnt%8)==0)      
 229   1                {
 230   2                if (Soft_Timer[RTC_READ_TIME] != 0)   Soft_Timer[RTC_READ_TIME]--;
 231   2                  f_half_sec = 1;
 232   2                }
 233   1              if (T0_cnt == 15)
 234   1              {
 235   2                      T0_cnt = 0;
 236   2                      if (Soft_Timer[UART_SEND_TIME] != 0)    Soft_Timer[UART_SEND_TIME]--;
 237   2                      if (Soft_Timer[MV_SEND_TIME] != 0)          Soft_Timer[MV_SEND_TIME]--;
 238   2                      if (Soft_Timer[SETUP_TIMEOUT] != 0)     Soft_Timer[SETUP_TIMEOUT]--;    
 239   2                      if (Soft_Timer[TIMEUP_TIME] != 0)               Soft_Timer[TIMEUP_TIME]--;
 240   2                      if (Soft_Timer[TEMP_TIME] != 0)             Soft_Timer[TEMP_TIME]--;
 241   2              }               
 242   1              TH1 = 0x0B;
 243   1              TL1 = 0xDC;
 244   1              TR1 = 1;
 245   1       }              
 246          /*******************************************/
 247          void T0_Init(void)
 248          {
 249   1              TR0 = 1;
 250   1              TMOD = 0x11;
 251   1              TH0 = 0x0B;             
 252   1              TL0 = 0xDC;     
 253   1              T0_cnt = 0;
 254   1      }
 255          /*******************************************
 256              
 257          *******************************************/
 258          void T1_Init(void)
 259          {
 260   1              TR1 = 0;
 261   1              TMOD = 0x11;  
 262   1              TH1 = 0x0B;
 263   1              TL1 = 0xDC;
 264   1              T1_cnt = 0;
 265   1       }
 266          /*******************************************
 267              
 268          *******************************************/
 269          void T2_Init(void)
 270          {
 271   1              TR2 = 1;
 272   1              T2MOD = 0x11;  //11  
 273   1              TH2 = 0x0B;
 274   1              TL2 = 0xDC;
 275   1              T2_cnt = 0;
 276   1      }
C51 COMPILER V9.02   MAIN                                                                  03/30/2015 14:00:36 PAGE 16  

 277          /*******************************************
 278              
 279          *******************************************/
 280          void INT0_Init(void)
 281          {
 282   1          INT0 = 1;
 283   1              INT1 = 1;        
 284   1              IE0  = 1;                  
 285   1              IT0  = 1;
 286   1              EX0  = 0;         
 287   1      }
 288          /*******************************************/
 289          void InitUart()    //InitUart use timer2
 290          {
 291   1         SCON |= 0x50;                          /* uart in mode 1 (8 bit), REN=1 50 */
 292   1         T2CON &= 0xF0;               /* EXEN2=0; TR2=0; C/T2#=0; CP/RL2#=0; */
 293   1         T2CON |= 0x30;               /* RCLK = 1; TCLK=1; */
 294   1         TH2=0xFF;                    /* init value */
 295   1         TL2=0xD0;                    /* init value */
 296   1         RCAP2H=0xFF;                 /* reload value, 9600 Bds at 11.059MHz */
 297   1         RCAP2L=0xDC;                /* reload value, 9600 Bds at 11.059MHz */
 298   1         ES = 1;                                                   /* Enable serial interrupt */
 299   1         TR2 = 1;                     /* Timer 2 run */
 300   1      }
 301          /*************************************************/
 302          void serial() interrupt 4
 303          {
 304   1              if(TI==1)
 305   1               {
 306   2                TI = 0 ;
 307   2                }                
 308   1          if(RI==1)
 309   1               {
 310   2                 RI=0;
 311   2                 ReceiveDate = SBUF;
 312   2                 ReceiveFlag = 1;
 313   2               }
 314   1      }
 315          /****************************************/
 316          void delay(unsigned int i)
 317          {
 318   1              unsigned char j;
 319   1              for (; i>0; i--)
 320   1                      for (j=0; j<255; j++);
 321   1      }
 322          /*******************************************
 323              
 324          *******************************************/
 325          void Buzzer(unsigned char status)
 326          {
 327   1              if (status)
 328   1            P3 =      P3 |= 0x10;
 329   1              else
 330   1                P3 = P3 &= ~0x10;
 331   1      }
 332          /*******************************************
 333                CHECK PCB TYPE
 334          *******************************************/
 335          void Check_PCB(void)
 336          {
 337   1                 if(P00 == 0)                //tc
 338   1                   {
C51 COMPILER V9.02   MAIN                                                                  03/30/2015 14:00:36 PAGE 17  

 339   2                           Work_Type = 0x00;
 340   2                               Func_Type = 0x00;
 341   2                               PCB_SETUP = 0x01;
 342   2                           if(P04 == 0)           //mV_out
 343   2                             {PCB_SETUP = 0x11 ;}
 344   2                       if(P05 == 0)   //mA_out
 345   2                             {PCB_SETUP = 0x21 ;}
 346   2                               if(use_flag == 0x0001) { NG_COD = 1;}
 347   2                       }
 348   1                 else if(P01 == 0)           //rtd
 349   1                       {
 350   2                                Work_Type = 0x01;
 351   2                                Func_Type = 0x01;
 352   2                                  PCB_SETUP = 0x02 ;
 353   2                            if(P04 == 0)      //mV_out
 354   2                              {PCB_SETUP = 0x12 ;}
 355   2                            if(P05 == 0)      //mA_out
 356   2                              {PCB_SETUP = 0x22 ;}
 357   2                                 if(use_flag == 0x0002) { NG_COD = 1;}
 358   2                       }
 359   1                else if(P02 == 0)          //mV
 360   1                       {
 361   2                               Work_Type = 0x02 ;
 362   2                               Func_Type = 0x02;
 363   2                                PCB_SETUP = 0x04 ;
 364   2                                if(P04 == 0)  //mV_out
 365   2                              {PCB_SETUP = 0x14 ;}
 366   2                            if(P05 == 0)      //mA_out
 367   2                              {PCB_SETUP = 0x24 ;}
 368   2                                 if(use_flag == 0x0004) { NG_COD = 1;}
 369   2                       } 
 370   1                else if(P03 == 0)             //mA
 371   1                       { 
 372   2                           Work_Type = 0x03 ;
 373   2                               Func_Type = 0x03;
 374   2                                 PCB_SETUP = 0x08 ;
 375   2                               if(P04 == 0)           //mV_out
 376   2                             {PCB_SETUP = 0x18 ;}
 377   2                           if(P05 == 0)       //mA_out
 378   2                             {PCB_SETUP = 0x28 ;}
 379   2                               if(use_flag == 0x0008) { NG_COD = 1;}  
 380   2                       }
 381   1      }
 382          /***********************************************/
 383          unsigned int TEMP_F_TO_C(unsigned int tc_tmp)
 384          {
 385   1       unsigned int ttmp;
 386   1      
 387   1                if(NP_COD == 1)
 388   1                  {
 389   2                       if(tc_tmp >= 32)
 390   2                    {
 391   3                          if(AV_COD == 0)
 392   3                            {
 393   4                              ttmp = (tc_tmp-32)/1.8;
 394   4                            }
 395   3                        else
 396   3                           {
 397   4                                  ttmp = (tc_tmp+32)/1.8; 
 398   4                   }
 399   3                    }
 400   2                  else
C51 COMPILER V9.02   MAIN                                                                  03/30/2015 14:00:36 PAGE 18  

 401   2                    {
 402   3                         if(AV_COD == 0)
 403   3                               {
 404   4                         ttmp = (32-tc_tmp)/1.8;
 405   4                                 AV_COD = 1 ;
 406   4                   }
 407   3                         else
 408   3                           {
 409   4                                ttmp = (32+tc_tmp)/1.8;
 410   4                                
 411   4                               }
 412   3                        }
 413   2            }
 414   1          else
 415   1                {               
 416   2                 if(tc_tmp >= 320)
 417   2                    {
 418   3                          if(AV_COD == 0)
 419   3                            {
 420   4                              ttmp = (tc_tmp-320)/1.8;
 421   4                            }
 422   3                        else
 423   3                           {
 424   4                                  ttmp = (tc_tmp+320)/1.8; 
 425   4                   }
 426   3                    }
 427   2                  else
 428   2                    {
 429   3                         if(AV_COD == 0)
 430   3                               {
 431   4                         ttmp = (320-tc_tmp)/1.8;
 432   4                                       AV_COD = 1 ;
 433   4                   }
 434   3                         else
 435   3                           {
 436   4                                ttmp = (320+tc_tmp)/1.8;
 437   4                               }
 438   3                       }
 439   2                 }
 440   1            return(ttmp);
 441   1      }
 442          /**********************************************/
 443          void Volt_Ctrl(void)
 444          {
 445   1      }
 446          /*********************************
 447              15782,15956,16125,16288,16448,16605,16757,16907,17029,17148,17266,
 448              17380,17493,17593,17692,17789,17884,17978,18060,18141,18221,18299,18377,18443,18509,18573,18637,18700,
             -18756,18811,18865,18919,
 449              18972,19022,19072,19121,19170,19219,19255,19291,19326,19362,19397,19430,19462,19495,19527,19559,19586,
             -19613,19641,19668,19695,
 450              19719,19742,19766,19790,19814,19832,19851,19870,19888,19907,19926,19945,19963,19982,20001,
 451          *******273.5 K *****/                                                                                                                                                     
 452          unsigned int Temp_Read(void)
 453          {
 454   1      unsigned int Temp_Count,P_count;
 455   1                   TEMP = 1;
 456   1                        P_count = 0;
 457   1                        delay(1);
 458   1                      while(TEMP)
 459   1                         { ; P_count = P_count + 1 ;}   
 460   1                          TEMP = 0 ;
C51 COMPILER V9.02   MAIN                                                                  03/30/2015 14:00:36 PAGE 19  

 461   1                   if(P_count >= 0x7010){Temp_Count = 0;}      //
 462   1                       else{ Temp_Count = ( 0x7010 - P_count)/19.4; //9.936 ;1760 2329 
 463   2                         if(Temp_Count > 121)
 464   2                                      { Temp_Count = Temp_Count-(Temp_Count-120)/12 ;  
 465   3                                            if(Temp_Count > 252)
 466   3                                          { Temp_Count = Temp_Count + (Temp_Count-251)/20 ;
 467   4                                                if(Temp_Count > 281)
 468   4                                              { Temp_Count = Temp_Count-(Temp_Count-280)/18 ;
 469   5                                                    if(Temp_Count > 401)                        //1212
 470   5                                                   { Temp_Count = Temp_Count + (Temp_Count-400)/28;
 471   6                                                            if(Temp_Count > 541)
 472   6                                                          { Temp_Count = Temp_Count+(Temp_Count-540)/15; 
 473   7                                                               if(Temp_Count > 641)
 474   7                                                              { Temp_Count = Temp_Count+(Temp_Count-640)/16;
 475   8                                                                if(Temp_Count > 731)                                             
 476   8                                                                     { Temp_Count = Temp_Count+(Temp_Count-730)/11;   //
 477   9                                                                          if(Temp_Count > 861)
 478   9                                                                        { Temp_Count = Temp_Count+(Temp_Count-860)/8;
 479  10                                                                             if(Temp_Count > 941)
 480  10                                                                           { Temp_Count = Temp_Count+(Temp_Count-940)/14;
 481  11                                                                                if(Temp_Count > 1011)
 482  11                                                                              { Temp_Count = Temp_Count+(Temp_Count-1010)/10; 
 483  12                                                                                                                              if(Temp_Count > 1041)
 484  12                                                                                { Temp_Count = Temp_Count-(Temp_Count-1040)/14;
 485  13                                                                                     if(Temp_Count > 1081)
 486  13                                                                                   { Temp_Count = Temp_Count+(Temp_Count-1080)/5;
 487  14                                                                                       if(Temp_Count > 1181)
 488  14                                                                                     { Temp_Count = Temp_Count+(Temp_Count-1180)/9;
 489  15                                                                                          if(Temp_Count > 1271)
 490  15                                                                                        { Temp_Count = Temp_Count+(Temp_Count-1270)/1
             -0;
 491  16                                                                                             if(Temp_Count > 1361)
 492  16                                                                                           { Temp_Count = Temp_Count+(Temp_Count-1360
             -)/6;
 493  17                                                                                               if(Temp_Count > 1491)
 494  17                                                                                         { Temp_Count = Temp_Count + (Temp_Co
             -unt-1490)/8;
 495  18                                                                                                  if(Temp_Count > 1541)
 496  18                                                                                            { Temp_Count = Temp_Count + (Temp
             -_Count-1540)/4;
 497  19                                                                                                                                                                   if(Temp_Count > 1726)
 498  19                                                                                                     { Temp_Count = Temp_Count+(Temp_
             -Count-1720)/10;
 499  20                                                                                                                                                                      }}}}}}}}}} }}}}}}} }
 500   2                  }
 501   1          return(Temp_Count);
 502   1      }
 503          /***********************************************/
 504          unsigned char Get_Key(void)
 505          {
 506   1        if(FUNCTION_KEY == 1 && OFFSET_KEY == 1 && UP_KEY == 1 && DOWN_KEY == 1) 
 507   1          {
 508   2               key_bak  =  0;
 509   2               key = 0 ; 
 510   2              }
 511   1        else if(FUNCTION_KEY == 0 )
 512   1          {
 513   2                if(key_bak == 0)
 514   2                 {
 515   3                   key_bak = 1 ;
 516   3                   key = key |= 0x01 ;
 517   3                 }
C51 COMPILER V9.02   MAIN                                                                  03/30/2015 14:00:36 PAGE 20  

 518   2                else
 519   2                 {
 520   3                      key = key &= 0xfe ;
 521   3                 }
 522   2               }
 523   1         else if(OFFSET_KEY == 0)
 524   1           {
 525   2               if(key_bak == 0)
 526   2                 {
 527   3                   key = key |= 0x02 ;
 528   3                   key_bak = 1; 
 529   3                 }
 530   2                else
 531   2                 {
 532   3                      key = key &= 0xfd ;
 533   3                 }
 534   2               }
 535   1         else if(UP_KEY == 0)
 536   1          {
 537   2               if(key_bak == 0)
 538   2                 {
 539   3                   key = key |= 0x04 ;
 540   3                   key_bak = 1; 
 541   3                 }
 542   2                else
 543   2                 {
 544   3                      key = key &= 0xfb ;
 545   3                 }
 546   2               }
 547   1         else if(DOWN_KEY == 0)
 548   1          {
 549   2               if(key_bak == 0)
 550   2                 {
 551   3                   key = key |= 0x08;
 552   3                   key_bak = 1; 
 553   3                 }
 554   2                else
 555   2                 {
 556   3                      key = key &= 0xf7 ;
 557   3                 }
 558   2               }
 559   1       
 560   1         return key;
 561   1      }
 562          /*******************************
 563          
 564          ********************************/
 565          unsigned  int DO_TC_TYPE(void)
 566          {
 567   1          unsigned int Code_Value,TC_Value,TT_Value,TA_Value ;
 568   1               unsigned char key;
 569   1              key = Get_Key();
 570   1                if(key == 0x01)
 571   1                  { Func_Type = 4;
 572   2                        if(Temp_Flag != 0)  Func_Type = 0;
 573   2                      }
 574   1         else
 575   1           { 
 576   2                if(Temp_Flag != 0 ){Temp_m = Temp_offset;}
 577   2            if (Soft_Timer[TEMP_TIME] == 0)
 578   2              {
 579   3                        Soft_Timer[TEMP_TIME] = 8;
C51 COMPILER V9.02   MAIN                                                                  03/30/2015 14:00:36 PAGE 21  

 580   3                     Data_Value[n_code] = Temp_Read() ;
 581   3                     if(n_code < 4){n_code++;}
 582   3                    else{ Temp_m = (Data_Value[3]+Data_Value[2]+Data_Value[1]+Data_Value[0])/4 ;
 583   4                                        n_code = 0 ;
 584   4                                   if(Temp_Flag != 0){Temp_Flag-- ;} }
 585   3                      }
 586   2                      if (Soft_Timer[ADC_READ_TIME] == 0) 
 587   2                        {
 588   3                            Soft_Timer[ADC_READ_TIME] = 8;
 589   3                                Code_Value =  Read_AD3421_Value();
 590   3      
 591   3                          if (TC_Type == K_TYPE)
 592   3                    { 
 593   4                                  Temp_sp = (Temp_m*24)/10;
 594   4                                  TT_Value = Check_Type_Offset(Code_Value); 
 595   4                                  TC_Value = Get_K_Slope(TT_Value);
 596   4                                      TT_Value = TC_Value/48.8 ;
 597   4                                      TA_Value = (TC_Value/38+163) ;
 598   4                                      if (C_F_Type == 0) TC_Value = TEMP_F_TO_C(TC_Value); //
 599   4                        }
 600   3                  else if (TC_Type == J_TYPE)
 601   3                    { 
 602   4                                  Temp_sp = (Temp_m*30)/10;    //300
 603   4                                  TT_Value = Check_Type_Offset(Code_Value);
 604   4                                      TC_Value = Get_J_Slope(TT_Value);
 605   4                                  TT_Value = TC_Value/27.4 ;
 606   4                                  TA_Value = (TC_Value/21.4+163) ;
 607   4                                      if (C_F_Type == 0) TC_Value = TEMP_F_TO_C(TC_Value); //
 608   4                        }
 609   3                  else if (TC_Type == T_TYPE)
 610   3                    {
 611   4                                  Temp_sp = (Temp_m*24)/10;     //1.044
 612   4                                  TT_Value = Check_Type_Offset(Code_Value);
 613   4                                  TC_Value = Get_T_Slope(TT_Value);
 614   4                              TT_Value = TC_Value/7.5 ;
 615   4                                      TA_Value = (TC_Value/6+163) ;
 616   4                                      if (C_F_Type == 0) TC_Value = TEMP_F_TO_C(TC_Value); // 
 617   4                        }
 618   3                  else if (TC_Type == E_TYPE)
 619   3                    { 
 620   4                                  Temp_sp = (Temp_m*36)/10;   // 1.54
 621   4                              TT_Value = Check_Type_Offset(Code_Value);
 622   4                                  TC_Value = Get_E_Slope(TT_Value);
 623   4                                  TT_Value = TC_Value/28.3 ;
 624   4                                  TA_Value = (TC_Value/22.5+163) ;
 625   4                                 if (C_F_Type == 0) TC_Value = TEMP_F_TO_C(TC_Value);  //
 626   4                        }
 627   3                  else if (TC_Type == R_TYPE)
 628   3                   {  NP_COD = 1;
 629   4                                  Temp_sp = (Temp_m*4)/10;//Temp_offset/12;
 630   4                                      TT_Value = Check_Type_Offset(Code_Value);
 631   4                                  TC_Value = Get_R_Slope(TT_Value);
 632   4                                  TT_Value = TC_Value/56.8 ;
 633   4                                  TA_Value = (TC_Value/44.5+163) ;
 634   4                                 if (C_F_Type == 0)  TC_Value = TEMP_F_TO_C(TC_Value);
 635   4                        }
 636   3                  else if (TC_Type == S_TYPE)
 637   3                    {    NP_COD = 1;
 638   4                                   Temp_sp = (Temp_m*4)/10;//Temp_offset/12;
 639   4                                       TT_Value = Check_Type_Offset(Code_Value);
 640   4                                       TC_Value = Get_S_Slope(TT_Value);
 641   4                                   TT_Value = TC_Value/56.8 ;
C51 COMPILER V9.02   MAIN                                                                  03/30/2015 14:00:36 PAGE 22  

 642   4                                       TA_Value = (TC_Value/44.5+163) ;
 643   4                                      if (C_F_Type == 0)      TC_Value = TEMP_F_TO_C(TC_Value); 
 644   4                        }
 645   3                        }
 646   2                  if (Soft_Timer[RTC_READ_TIME] == 0)
 647   2                     {
 648   3                               RTC_READ_SET();
 649   3                               Soft_Timer[RTC_READ_TIME] = 8;
 650   3                         }
 651   2                  if (Soft_Timer[DISPLAY_SEND_TIME] == 0)
 652   2                    {
 653   3                           Soft_Timer[DISPLAY_SEND_TIME] = 32;        
 654   3                                 LED_Disp(1,TC_Value);
 655   3      //                         LED_Disp(1,Temp_m);
 656   3                          if ((TC_Value > alarm_Low_set)&&(TC_Value < alarm_Hi_set))
 657   3                        { BEEP_OUT = 1; }
 658   3                              else
 659   3                                { BEEP_OUT = 0; }
 660   3                        }
 661   2                  if (Soft_Timer[MV_SEND_TIME] == 0)
 662   2                   {
 663   3                         if( P04 == 0) Set_mV(TT_Value);
 664   3      
 665   3                         if( P05 == 0) Set_mA(TA_Value);
 666   3                         Soft_Timer[MV_SEND_TIME] = 16;
 667   3                       }
 668   2                  if (Soft_Timer[UART_SEND_TIME] == 0)
 669   2                   {
 670   3                        if(tran == 0)
 671   3                          {
 672   4                              SBUF = TC_Value ;
 673   4                               tran = 1 ;
 674   4                               Soft_Timer[UART_SEND_TIME] = 1;
 675   4                     }
 676   3                   else
 677   3                    { 
 678   4                      SBUF = TC_Value >> 8 ;
 679   4                      tran = 0;
 680   4                              Soft_Timer[UART_SEND_TIME] = 59 ;
 681   4                        }
 682   3                      TI = 1;
 683   3                }
 684   2              }
 685   1          return  TC_Value;
 686   1      }
 687          /*************************************************************************************/
 688          unsigned int Check_Type_Offset(unsigned int Code_Value)
 689          {
 690   1           if (NG_COD == 0)
 691   1             {
 692   2                  if (AV_COD == 0)
 693   2                        {
 694   3                         if(Code_Value >= TC_Zero_offset)        
 695   3                           {
 696   4                        if((Code_Value - TC_Zero_offset) >= Temp_sp)
 697   4                           { Code_Value = (Code_Value - TC_Zero_offset) - Temp_sp ;}
 698   4                         else
 699   4                                   { Code_Value = (Temp_sp + TC_Zero_offset)- Code_Value; AV_COD = 1 ; }
 700   4                        }
 701   3                               else
 702   3                                {   
 703   4                             if((TC_Zero_offset - Code_Value) >= Temp_sp)
C51 COMPILER V9.02   MAIN                                                                  03/30/2015 14:00:36 PAGE 23  

 704   4                                  { Code_Value = TC_Zero_offset - (Code_Value + Temp_sp);AV_COD = 1 ;}
 705   4                         else
 706   4                          { Code_Value =  (Temp_sp + TC_Zero_offset) - Code_Value; AV_COD = 1 ; }
 707   4                            }
 708   3                         }
 709   2                else    // AV_COD = 1  NG_COD = 0
 710   2                     {
 711   3      /*
 712   3                           if(Code_Value >= TC_Zero_offset)
 713   3                                 {
 714   3                                  if((Code_Value - TC_Zero_offset) >= Temp_sp)
 715   3                                { Code_Value = (Code_Value + TC_Zero_offset) + Temp_sp;}
 716   3                                  else
 717   3                                    { Code_Value =  Temp_sp + ( Code_Value + TC_Zero_offset);}
 718   3                                 }
 719   3                           else
 720   3                                 {      // AV_COD = 1  NG_COD = 0
 721   3                                  if((TC_Zero_offset- Code_Value ) >= Temp_sp)
 722   3                                { Code_Value = ( Code_Value + TC_Zero_offset) + Temp_sp;}
 723   3                                  else
 724   3                                    { Code_Value = Temp_sp + (Code_Value + TC_Zero_offset) ;}
 725   3                                 }
 726   3      */
 727   3                   Code_Value = (Code_Value + TC_Zero_offset) + Temp_sp;
 728   3                         }
 729   2                 }
 730   1            else
 731   1                 {
 732   2                   if(AV_COD == 0)  // AV_COD = 0      NG_COD = 1
 733   2                         {
 734   3                          if(Code_Value >= TC_Zero_offset)
 735   3                            {
 736   4                         if((Code_Value - TC_Zero_offset) >= Temp_sp)
 737   4                           { Code_Value = (Code_Value + Temp_sp) + TC_Zero_offset ;}
 738   4                         else
 739   4                           { Code_Value = Code_Value + (Temp_sp  + TC_Zero_offset) ;}
 740   4                        }
 741   3                      else
 742   3                        {
 743   4                             if((TC_Zero_offset - Code_Value) >= Temp_sp)
 744   4                                   { Code_Value = (TC_Zero_offset + Temp_sp) - Code_Value; AV_COD = 1;}
 745   4                         else
 746   4                           { Code_Value = (TC_Zero_offset + Temp_sp) - Code_Value; AV_COD = 1;}
 747   4                            }
 748   3                         }
 749   2                else    // AV_COD = 1  NG_COD = 1
 750   2                     {
 751   3                           if(Code_Value >= TC_Zero_offset)
 752   3                                 {
 753   4                                  if((Code_Value - TC_Zero_offset) >= Temp_sp)
 754   4                                { Code_Value = (Code_Value - Temp_sp) - TC_Zero_offset;}
 755   4                                  else
 756   4                                    { Code_Value = Temp_sp - ( Code_Value - TC_Zero_offset);AV_COD = 0;}
 757   4                                 }
 758   3                           else
 759   3                                 {
 760   4                                  if(( TC_Zero_offset - Code_Value) >= Temp_sp)
 761   4                                { Code_Value =  TC_Zero_offset - (Temp_sp + Code_Value);AV_COD = 0;}
 762   4                                  else
 763   4                                    { Code_Value = ( TC_Zero_offset +  Temp_sp) - Code_Value;AV_COD = 0;}
 764   4                                 }
 765   3                         }
C51 COMPILER V9.02   MAIN                                                                  03/30/2015 14:00:36 PAGE 24  

 766   2                 }
 767   1      
 768   1         if(ADD_COD == 1 ) 
 769   1               { Code_Value = Code_Value - (Code_Value/70); }   //TC_Span_Value
 770   1         else
 771   1               { Code_Value = Code_Value + (Code_Value/70);}
 772   1                 
 773   1              if(OVER_COD == 1){ Code_Value = 0xffff;}
 774   1      
 775   1        return Code_Value;
 776   1      }
 777          /***********************************************
 778          RTD=  2 27.6    40      48      56      58
 779          131072                                  
 780          3200 2600 1950    950  40
 781          1300 2200  3250  4100    5000 5750      6450
 782          7350 7950  8700  9300  9900     10500    11150
 783          11700 12300     12850   13400 
 784          *************************************************/
 785          unsigned int DO_RTD_TYPE(void)
 786          {
 787   1        unsigned int RTD_Value; 
 788   1        unsigned char key;     
 789   1      
 790   1            key = Get_Key();
 791   1               
 792   1                if(key == 0x01)
 793   1                {
 794   2                   Func_Type =  4;
 795   2                }
 796   1              else
 797   1                {
 798   2                      if (Soft_Timer[ADC_READ_TIME] == 0) 
 799   2                         {
 800   3                               Soft_Timer[ADC_READ_TIME] = 16;
 801   3      
 802   3                                RTD_Value = Read_AD3421_Value();
 803   3      
 804   3                               if((NG_COD == 1)&&(AV_COD == 1))
 805   3                                 {
 806   4                                                if( RTD_Value >= RTD_Zero_offset)
 807   4                                                  {
 808   5                                                   RTD_Value = RTD_Value - RTD_Zero_offset;
 809   5                                                      }
 810   4                                                 else
 811   4                                                  {
 812   5                                                       RTD_Value = RTD_Zero_offset -RTD_Value;
 813   5                                                       AV_COD = 0;
 814   5                                                      }
 815   4                                      }
 816   3                                else if((NG_COD == 1)&&(AV_COD == 0))
 817   3                                  {
 818   4                                                   RTD_Value = RTD_Value + RTD_Zero_offset;
 819   4                                  }                   
 820   3                                else if((NG_COD == 0)&&(AV_COD == 1))
 821   3                                  {
 822   4                                                   RTD_Value = RTD_Value + RTD_Zero_offset;
 823   4                                  }   
 824   3                                else if((NG_COD == 0)&&(AV_COD == 0))
 825   3                                  {
 826   4                                             if( RTD_Value >= RTD_Zero_offset)
 827   4                                                  {
C51 COMPILER V9.02   MAIN                                                                  03/30/2015 14:00:36 PAGE 25  

 828   5                                                   RTD_Value = RTD_Value - RTD_Zero_offset;
 829   5                                                      }
 830   4                                                 else
 831   4                                                  {
 832   5                                                       RTD_Value = RTD_Zero_offset -RTD_Value;
 833   5                                                   AV_COD = 1 ;
 834   5                                                      }
 835   4                                      }
 836   3                                         if(RTD_Span_offset > 0x44e4)
 837   3                                               {  RTD_Value = RTD_Value +(RTD_Value/RTD_Span_Value);}
 838   3                                        else
 839   3                                               {  RTD_Value = RTD_Value - (RTD_Value/RTD_Span_Value);}
 840   3                                       if(OVER_COD == 1) RTD_Value = 0xffff;
 841   3                    RTD_Value = Get_RTD_Slope(RTD_Value);
 842   3       
 843   3                       if (C_F_Type == 0)     RTD_Value = TEMP_F_TO_C(RTD_Value);
 844   3                     }
 845   2               if (Soft_Timer[DISPLAY_SEND_TIME] == 0)
 846   2                {
 847   3                         LED_Disp(1,RTD_Value);
 848   3                         Soft_Timer[DISPLAY_SEND_TIME] = 16 ;
 849   3      
 850   3                               if ((RTD_Value > alarm_Low_set)&&(RTD_Value < alarm_Hi_set))
 851   3                        { BEEP_OUT = 1; }
 852   3                              else
 853   3                                { BEEP_OUT = 0; }
 854   3                        }
 855   2                  if (Soft_Timer[MV_SEND_TIME] == 0)
 856   2                    {
 857   3                         if( P04 == 0) Set_mV(RTD_Value);
 858   3                         if( P05 == 0) Set_mA(RTD_Value);
 859   3      
 860   3                         Soft_Timer[MV_SEND_TIME] = 2;
 861   3                        }
 862   2                  if (Soft_Timer[RTC_READ_TIME] == 0)
 863   2                   {
 864   3                         RTC_READ_SET();
 865   3                         Soft_Timer[RTC_READ_TIME] = 8 ;
 866   3                       }
 867   2                  if (Soft_Timer[UART_SEND_TIME] == 0)
 868   2                    {
 869   3                         if(tran == 0)
 870   3                          {
 871   4                              SBUF = RTD_Value ;
 872   4                               tran = 1 ;
 873   4                               Soft_Timer[UART_SEND_TIME] = 1;
 874   4                     }
 875   3                   else
 876   3                    { 
 877   4                      SBUF = RTD_Value >> 8 ;
 878   4                      tran = 0;
 879   4                              Soft_Timer[UART_SEND_TIME] = 59 ;
 880   4                        }
 881   3                      TI = 1;
 882   3                 }
 883   2          }
 884   1         return RTD_Value;
 885   1      }
 886          /***********************************************
 887          
 888          ************************************************/
 889          unsigned  int DO_mV_TYPE(void)
C51 COMPILER V9.02   MAIN                                                                  03/30/2015 14:00:36 PAGE 26  

 890          {
 891   1           unsigned int mV_Value;
 892   1               unsigned char key;
 893   1      
 894   1            key = Get_Key();
 895   1               
 896   1                if(key == 0x01)
 897   1                  {
 898   2                    Func_Type = 4;
 899   2                  }
 900   1                else 
 901   1                  {
 902   2                       if (Soft_Timer[ADC_READ_TIME] == 0) 
 903   2                        {
 904   3                          Soft_Timer[ADC_READ_TIME] = 16;
 905   3      
 906   3                          mV_Value = Read_AD3421_Value();
 907   3      
 908   3                               
 909   3                               if((NG_COD == 1)&&(AV_COD == 1))
 910   3                                 {
 911   4                                                if( mV_Value > mV_Zero_offset)                
 912   4                                                  {
 913   5                                                   mV_Value = mV_Value - mV_Zero_offset;
 914   5                                                      }
 915   4                                                 else
 916   4                                                  {
 917   5                                                       mV_Value = mV_Zero_offset -mV_Value;
 918   5                                                       AV_COD = 0;
 919   5                                                      }
 920   4                                      }
 921   3                                else if((NG_COD == 1)&&(AV_COD == 0))
 922   3                                  {
 923   4                                                   mV_Value = mV_Value + mV_Zero_offset;
 924   4                                  }                   
 925   3                                else if((NG_COD == 0)&&(AV_COD == 1))
 926   3                                  {
 927   4                                                   mV_Value = mV_Value + mV_Zero_offset;
 928   4                                  }   
 929   3                                else if((NG_COD == 0)&&(AV_COD == 0))
 930   3                                  {
 931   4                                             if( mV_Value >= mV_Zero_offset)
 932   4                                                  {
 933   5                                                   mV_Value = mV_Value - mV_Zero_offset;
 934   5                                                      }
 935   4                                                 else
 936   4                                                  {
 937   5                                                       mV_Value = mV_Zero_offset -mV_Value;
 938   5                                                   AV_COD = 1 ;
 939   5                                                      }
 940   4                                      }
 941   3                                         if(mV_Span_offset > 0x0c80)
 942   3                                               { mV_Value = mV_Value + (mV_Value/mV_Span_Value); }
 943   3                                        else
 944   3                                               { mV_Value = mV_Value - (mV_Value/mV_Span_Value); }
 945   3      
 946   3      //                                      mV_Value = 0x7d00 ;
 947   3      //                                              mV_Value = 0 ;
 948   3                       
 949   3                                      mV_Value = mV_Value/3.2;
 950   3      //                      mV_Value = mV_Value/5.29;
 951   3                              if(OVER_COD == 1) mV_Value = 0xffff;     
C51 COMPILER V9.02   MAIN                                                                  03/30/2015 14:00:36 PAGE 27  

 952   3                       }
 953   2                 if (Soft_Timer[DISPLAY_SEND_TIME] == 0)
 954   2                   {
 955   3                          LED_Disp(1,mV_Value);
 956   3                          Soft_Timer[DISPLAY_SEND_TIME] = 8 ;
 957   3      
 958   3                               if ((mV_Value > alarm_Low_set)&&(mV_Value < alarm_Hi_set))
 959   3                        { BEEP_OUT = 1; }
 960   3                              else
 961   3                                { BEEP_OUT = 0; }
 962   3                   }
 963   2                 if (Soft_Timer[MV_SEND_TIME] == 0)
 964   2                   {
 965   3                         if( P04 == 0)  Set_mV(mV_Value);
 966   3                         if( P05 == 0)  Set_mA(mV_Value);
 967   3      
 968   3                         Soft_Timer[MV_SEND_TIME] = 2;
 969   3                       }
 970   2                if (Soft_Timer[RTC_READ_TIME] == 0)
 971   2                  {
 972   3                        RTC_READ_SET();
 973   3                        Soft_Timer[RTC_READ_TIME] = 8 ;
 974   3                      }
 975   2                 if (Soft_Timer[UART_SEND_TIME] == 0)
 976   2                   {
 977   3                         if(tran == 0)
 978   3                          {
 979   4                              SBUF = mV_Value ;
 980   4                               tran = 1 ;
 981   4                               Soft_Timer[UART_SEND_TIME] = 1;
 982   4                     }
 983   3                   else
 984   3                    { 
 985   4                      SBUF = mV_Value >> 8 ;
 986   4                      tran = 0;
 987   4                              Soft_Timer[UART_SEND_TIME] = 59 ;
 988   4                        }
 989   3                      TI = 1;
 990   3                       }
 991   2                }
 992   1               return mV_Value ;
 993   1      }
 994          /***********************************************
 995          
 996          *************************************************/
 997          unsigned int DO_mA_TYPE(void)
 998          {
 999   1           unsigned int mA_Value;
1000   1               unsigned char key;
1001   1      
1002   1            key = Get_Key();
1003   1               
1004   1                if(key == 0x01)
1005   1                  {
1006   2                    Func_Type = 4 ;
1007   2                  }
1008   1                else 
1009   1                  {
1010   2                       if (Soft_Timer[ADC_READ_TIME] == 0) 
1011   2                         {
1012   3                                   Soft_Timer[ADC_READ_TIME] = 16;
1013   3      
C51 COMPILER V9.02   MAIN                                                                  03/30/2015 14:00:36 PAGE 28  

1014   3                                       mA_Value = Read_AD3421_Value();
1015   3      
1016   3                               if((NG_COD == 1)&&(AV_COD == 1))
1017   3                                 {
1018   4                                                if( mA_Value >= mA_Zero_offset)
1019   4                                                  {
1020   5                                                   mA_Value = mA_Value - mA_Zero_offset;
1021   5                                                      }
1022   4                                                 else
1023   4                                                  {
1024   5                                                       mA_Value = mA_Zero_offset -mA_Value;
1025   5                                                       AV_COD = 0;
1026   5                                                      }
1027   4                                      }
1028   3                                else if((NG_COD == 1)&&(AV_COD == 0))
1029   3                                  {
1030   4                                                   mA_Value = mA_Value + mA_Zero_offset;
1031   4                                  }                   
1032   3                                else if((NG_COD == 0)&&(AV_COD == 1))
1033   3                                  {
1034   4                                                   mA_Value = mA_Value + mA_Zero_offset;
1035   4                                  }   
1036   3                                else if((NG_COD == 0)&&(AV_COD == 0))
1037   3                                  {
1038   4                                             if( mA_Value >= mA_Zero_offset)
1039   4                                                  {
1040   5                                                   mA_Value = mA_Value - mA_Zero_offset;
1041   5                                                      }
1042   4                                                 else
1043   4                                                  {
1044   5                                                       mA_Value = mA_Zero_offset -mA_Value;
1045   5                                                   AV_COD = 1 ;
1046   5                                                      }
1047   4                                      }
1048   3                                         if(mA_Span_offset >  0x1900)
1049   3                                               { mA_Value = mA_Value + (mA_Value/mA_Span_Value); }
1050   3                                        else
1051   3                                               { mA_Value = mA_Value - (mA_Value/mA_Span_Value); }
1052   3      
1053   3                                       mA_Value = mA_Value/3.2 ;
1054   3      
1055   3                                       if(OVER_COD == 1) mA_Value = 0xffff;
1056   3                        }
1057   2                 if (Soft_Timer[DISPLAY_SEND_TIME] == 0)
1058   2                   {
1059   3                          LED_Disp(1,mA_Value);
1060   3                          Soft_Timer[DISPLAY_SEND_TIME] = 16 ;
1061   3      
1062   3                               if ((mA_Value > alarm_Low_set)&&(mA_Value < alarm_Hi_set))
1063   3                        { BEEP_OUT = 1; }
1064   3                              else
1065   3                                { BEEP_OUT = 0; }
1066   3                   }
1067   2                 if (Soft_Timer[MV_SEND_TIME] == 0)
1068   2                   {
1069   3                         if( P04 == 0)  Set_mV(mA_Value);
1070   3                         if( P05 == 0)  Set_mA(mA_Value);
1071   3      
1072   3                         Soft_Timer[MV_SEND_TIME] = 2;
1073   3                       }
1074   2                 if (Soft_Timer[RTC_READ_TIME] == 0)
1075   2                  {
C51 COMPILER V9.02   MAIN                                                                  03/30/2015 14:00:36 PAGE 29  

1076   3                        RTC_READ_SET();
1077   3                        Soft_Timer[RTC_READ_TIME] = 8 ;
1078   3                      }
1079   2                 if (Soft_Timer[UART_SEND_TIME] == 0)
1080   2                   {
1081   3                         if(tran == 0)
1082   3                          {
1083   4                              SBUF = mA_Value ;
1084   4                               tran = 1 ;
1085   4                               Soft_Timer[UART_SEND_TIME] = 1;
1086   4                     }
1087   3                   else
1088   3                    { 
1089   4                      SBUF = mA_Value >> 8 ;
1090   4                      tran = 0;
1091   4                              Soft_Timer[UART_SEND_TIME] = 59 ;
1092   4                        }
1093   3                      TI = 1;
1094   3                       }
1095   2               }
1096   1        return mA_Value;
1097   1      }
1098          /*************************************************/
1099          unsigned int Read_AD3421_Value(void)
1100          {
1101   1         unsigned int  AD3421_Value;
1102   1         unsigned char ssta;
1103   1      
1104   1                       ssta = Get_AD3421_Value();
1105   1                if (ssta == 0)
1106   1                  {
1107   2                               AD_Hi =  AD_Hi & 0x03;
1108   2                    if(AD_Hi >= 2)
1109   2                         {
1110   3                            AV_COD = 1;
1111   3                                AD3421_Value = AD_Hi & 0x03;    
1112   3                                AD3421_Value = AD3421_Value << 8 ;
1113   3                                AD3421_Value = AD3421_Value + AD_Mid ;
1114   3                                AD3421_Value = AD3421_Value << 7 ;
1115   3                                AD_Lo = AD_Lo >> 1;
1116   3                                AD3421_Value = AD3421_Value + AD_Lo ;  
1117   3                                AD3421_Value = ~ AD3421_Value; 
1118   3                                if( AD3421_Value >= 0xf000){OVER_COD = 1;} else{OVER_COD = 0;}
1119   3                         }
1120   2                        else
1121   2                         {
1122   3                                AV_COD = 0;
1123   3                                AD3421_Value = AD_Hi & 0x03;    
1124   3                                AD3421_Value = AD3421_Value << 8 ;
1125   3                                AD3421_Value = AD3421_Value + AD_Mid ;
1126   3                                AD3421_Value = AD3421_Value << 7 ;
1127   3                                AD_Lo = AD_Lo >> 1;
1128   3                                AD3421_Value = AD3421_Value + AD_Lo;
1129   3                                if( AD3421_Value >= 0xf000){OVER_COD = 1;} else{OVER_COD = 0;}
1130   3                         }
1131   2                 }
1132   1         return AD3421_Value;
1133   1      }
1134          /*************************************************/     
1135          void DO_SETUP_TYPE(void)
1136          {
1137   1              unsigned char set_key = 0, times = 0, Itemm = 0; 
C51 COMPILER V9.02   MAIN                                                                  03/30/2015 14:00:36 PAGE 30  

1138   1              unsigned char item_key,confrom_key, up_key,don_key;
1139   1              unsigned int  value_cal = 0;
1140   1              
1141   1      
1142   1                    SETUP_LED_Disp(Itemm,value_cal);
1143   1      
1144   1                         while (CAIT)
1145   1                                  {
1146   2                                     set_key = Get_Key();
1147   2      
1148   2                                                            if((set_key & 0x01) == 1)
1149   2                                                              { item_key = 1 ;}
1150   2                                                             else
1151   2                                                              { item_key = 0 ;}
1152   2      
1153   2                                                            if((set_key & 0x02) == 2)
1154   2                                                              {confrom_key = 1 ;}
1155   2                                                             else
1156   2                                                              { confrom_key = 0 ;}
1157   2      
1158   2                                                            if((set_key & 0x04) == 4)
1159   2                                                              { up_key = 1 ;}
1160   2                                                             else
1161   2                                                              { up_key = 0 ;}
1162   2      
1163   2                                                if((set_key & 0x08) == 8)
1164   2                                                              { don_key = 1 ;}
1165   2                                                              else
1166   2                                                              { don_key = 0 ;}
1167   2      
1168   2                                                         if (item_key == 1) 
1169   2                                                           {
1170   3                                                                Itemm ++;
1171   3                                                                times=0;
1172   3                                                               }
1173   2                                                         if (Itemm > 0x13)
1174   2                                                               {
1175   3                                                                   Itemm = 0; 
1176   3                                                                       CAIT = 0;
1177   3                                                               } 
1178   2                                                        if(up_key == 1)   value_cal++;
1179   2                                                        if(don_key == 1)  value_cal--;
1180   2      
1181   2      
1182   2                              if ((Itemm >= TC_ZERO_CAL)&&(Itemm <= mA_SPAN_CAL))
1183   2                                   {
1184   3                                                 if (Soft_Timer[ADC_READ_TIME] == 0) 
1185   3                                                   {
1186   4                                                        Soft_Timer[ADC_READ_TIME] = 4 ;
1187   4                                                     Data_Value[n_code] = Read_AD3421_Value();
1188   4                                                                  if(n_code < 8)
1189   4                                                                        {n_code++;}
1190   4                                                                        else
1191   4                                                                         {
1192   5                                                                          Data_Value[9] = (Data_Value[7]+Data_Value[6]+Data_Value[5]+Data_Value[4]+Data_Value[3]+Data_Va
             -lue[2]+Data_Value[1]+Data_Value[0])/8 ;
1193   5                                                                              n_code = 0 ;
1194   5                                                                         }
1195   4                                                        }
1196   3                                                  else
1197   3                                                    {
1198   4                                                            Data_Value[9] = Data_Value[n_code] ;
C51 COMPILER V9.02   MAIN                                                                  03/30/2015 14:00:36 PAGE 31  

1199   4                                                        }
1200   3                                                }
1201   2                              if (Itemm == MODE_CAL)                  //tc,rtd,mV,mA
1202   2                                {
1203   3                                                          SETUP_LED_Disp(Itemm,Work_Type);
1204   3                                                                 Work_Type = Work_Type + value_cal;
1205   3                                                                   value_cal = 0;
1206   3                                                                if(Work_Type >= 4)
1207   3                                                                  {
1208   4                                                                       Work_Type = 0;
1209   4                                                                       value_cal = 0;
1210   4                                                                      }        
1211   3                                                                if(confrom_key == 1)
1212   3                                                                  { 
1213   4                                                                        EEPROM_write_byte(Mode_Select,Work_Type);
1214   4                                                                        SETUP_LED_Disp(22,0);
1215   4                                                                        delay(2500);
1216   4                                                                        times ++;
1217   4                                                                      }
1218   3                                              }
1219   2                                      else if (Itemm == C_F_CAL)
1220   2                                  {
1221   3                                               if (Work_Type >= 2) {Itemm = Itemm + 1;}
1222   3                                              else{   SETUP_LED_Disp(Itemm,C_F_Type);
1223   4                                                                C_F_Type = C_F_Type + value_cal;
1224   4                                                                  value_cal = 0;
1225   4                                                             
1226   4                                                                 if(C_F_Type >= 2 )
1227   4                                                                         {
1228   5                                                                          C_F_Type = 0 ;
1229   5                                                                          value_cal = 0;
1230   5                                                                         }
1231   4                                                                 if(confrom_key == 1)
1232   4                                                                  { 
1233   5                                                                         EEPROM_write_byte(C_F_Select,C_F_Type);  //C,F
1234   5                                                                         times ++; SETUP_LED_Disp(22,0);delay(2500);
1235   5                                                                      }
1236   4                                                         }
1237   3                                              }
1238   2                               else if (Itemm == TYPE_CAL)
1239   2                                  {
1240   3                                                  if (Work_Type != 0)
1241   3                                                        {     Itemm = Itemm + 1;}
1242   3                                                      else{   TC_Type = TC_Type + value_cal; 
1243   4                                                                        value_cal = 0;
1244   4                                                                if (TC_Type >= 6)
1245   4                                                                  {
1246   5                                                                    TC_Type = 0 ;
1247   5                                                                        value_cal = 0;
1248   5                                                                  }              
1249   4                                                                   SETUP_LED_Disp(Itemm,TC_Type);
1250   4      
1251   4                                                                      if(confrom_key == 1)
1252   4                                                                   {
1253   5                                                                         EEPROM_write_byte(Type_Select,TC_Type);  //K,J,T,E,R,B,S
1254   5                                                                         times ++; SETUP_LED_Disp(22,0);delay(2500);
1255   5                                                                       }
1256   4                                                           }
1257   3                                               }              
1258   2                                      else if (Itemm == TC_ZERO_CAL)
1259   2                                                {
1260   3                                                 if (Work_Type != 0){ Itemm = Itemm + 1;}
C51 COMPILER V9.02   MAIN                                                                  03/30/2015 14:00:36 PAGE 32  

1261   3                                               else{
1262   4                                                                 SETUP_LED_Disp(Itemm, Data_Value[9]);
1263   4                                                                 if(confrom_key == 1)
1264   4                                                                  {
1265   5                                                                        Temp_Flag = 3 ;
1266   5                                                                        Temp_offset = Temp_m;
1267   5                                                                       if ((Temp_m*24)/10 >= Data_Value[9])
1268   5                                                                         {
1269   6                                                                           if( AV_COD == 1)
1270   6                                                                             { TC_Zero_offset = (Temp_m*24)/10 - Data_Value[9]; NG_COD = 0;use_flag = use_flag&0xfe;}
1271   6                                                                           else{ TC_Zero_offset = (Temp_m*24)/10 + Data_Value[9]; NG_COD =0;use_flag = use_flag&0xfe;}
1272   6                                                                         }
1273   5                                                                       else
1274   5                                                                         {  
1275   6                                                                               if( AV_COD == 1)
1276   6                                                                             { TC_Zero_offset = Data_Value[9]-(Temp_m*24)/10 ;  NG_COD = 1;use_flag = use_flag|0x01;}
1277   6                                                                           else {TC_Zero_offset = Data_Value[9] + (Temp_m*24)/10;  NG_COD = 0;use_flag = use_flag&0xfe;}
1278   6                                                                         }
1279   5                                                                        EEPROM_write_byte(Status_flag,(use_flag));
1280   5                                                                        EEPROM_write_word(TC_Zero,TC_Zero_offset); 
1281   5                                                                        EEPROM_write_word(60,Temp_offset);                                                                              
1282   5                                                                  delay(50);
1283   5                                                                      times ++; SETUP_LED_Disp(22,0);delay(2500);
1284   5                                                                }
1285   4                                                       }
1286   3                                               }
1287   2                            else if (Itemm == TC_SPAN_CAL)
1288   2                                  {
1289   3                                                if (Work_Type != 0) { Itemm = Itemm + 1; }
1290   3                                               else
1291   3                                                {
1292   4                                                 SETUP_LED_Disp(Itemm,Data_Value[9]);
1293   4                                                if(confrom_key == 1)
1294   4                                                  { 
1295   5                                                       if( NG_COD == 1)
1296   5                                                          {TC_Span_offset = Data_Value[9] + TC_Zero_offset;}
1297   5                                                  else {TC_Span_offset = Data_Value[9] - TC_Zero_offset;}
1298   5                                                              EEPROM_write_word(TC_Span,TC_Span_offset);  
1299   5      
1300   5                                                   if(TC_Span_offset+TC_Zero_offset >= 0xc8ca )
1301   5                                                         { TC_Span_Value = (TC_Span_offset+TC_Zero_offset) /((TC_Span_offset+TC_Zero_offset) - 0xc8ca);use
             -_flag = use_flag|0x10;}
1302   5                                                       else
1303   5                                                         { TC_Span_Value = (TC_Span_offset+TC_Zero_offset) /(0xc8ca - (TC_Span_offset+TC_Zero_offset));use
             -_flag = use_flag&0xef;}
1304   5      
1305   5                                                                          EEPROM_write_word(TC_Span_Per,TC_Span_Value);
1306   5                                                                              delay(50);
1307   5                                                                              EEPROM_write_byte(Status_flag,use_flag);
1308   5                                                                        times ++; SETUP_LED_Disp(22,0);delay(2500);
1309   5                                                        }
1310   4                                                        }
1311   3                                                 }
1312   2                            else if (Itemm == RTD_ZERO_CAL)
1313   2                                    {
1314   3                                                  if (Work_Type != 1) {       Itemm = Itemm + 1;}
1315   3                                                      else{
1316   4                                                               if( AV_COD == 1){ NG_COD = 1;}else{ NG_COD = 0;}
1317   4                                                                SETUP_LED_Disp(Itemm,Data_Value[9]);
1318   4                                                                if(confrom_key == 1)
1319   4                                                                  {
1320   5                                                                        RTD_Zero_offset = Data_Value[9] ;
C51 COMPILER V9.02   MAIN                                                                  03/30/2015 14:00:36 PAGE 33  

1321   5                                                                       EEPROM_write_word(RTD_Zero,RTD_Zero_offset);  //rtd
1322   5                                                                        delay(50);
1323   5                                                                       if( NG_COD == 1){ EEPROM_write_byte(Status_flag,(use_flag|0x02));}
1324   5                                                                       else { EEPROM_write_byte(Status_flag,(use_flag&0xfd));}
1325   5                                                                        times ++; SETUP_LED_Disp(22,0);delay(2500);
1326   5                                                                      }
1327   4                                                          }
1328   3                                                }
1329   2                                 else if (Itemm == RTD_SPAN_CAL)
1330   2                                    {
1331   3                                                  if (Work_Type != 1) {Itemm = Itemm + 1;}
1332   3                                                      else{    
1333   4                                                                SETUP_LED_Disp(Itemm,Data_Value[9]);
1334   4                                                                if(confrom_key == 1)
1335   4                                                                  {
1336   5                                                                       RTD_Span_offset = Data_Value[9] ;
1337   5                                                                       EEPROM_write_word(RTD_Span,RTD_Span_offset);  //rtd
1338   5      
1339   5                                                                       if( NG_COD == 1)
1340   5                                                                         { if ((RTD_Span_offset + RTD_Zero_offset) > 0x44e4 )
1341   6                                                                              { RTD_Span_Value = ((RTD_Span_offset + RTD_Zero_offset)/((RTD_Span_offset + RTD_Zero_offse
             -t)-0x44e4));}
1342   6                                                                               else
1343   6                                                                                 { RTD_Span_Value = ((RTD_Span_offset + RTD_Zero_offset)/(0x44e4 - (RTD_Span_offset + RTD_Zero_
             -offset)));}
1344   6                                                                         }
1345   5                                                                       else
1346   5                                                                         { if ((RTD_Span_offset - RTD_Zero_offset) > 0x44e4 )
1347   6                                                                              { RTD_Span_Value = ((RTD_Span_offset - RTD_Zero_offset)/((RTD_Span_offset - RTD_Zero_offse
             -t)-0x44e4));}
1348   6                                                                               else
1349   6                                                                                  { RTD_Span_Value = ((RTD_Span_offset - RTD_Zero_offset)/(0x44e4 - (RTD_Span_offset - RTD_Zero
             -_offset)));}
1350   6                                                                         }
1351   5                                                                          EEPROM_write_word(RTD_Span_Per,RTD_Span_Value);
1352   5                                                                       times ++;      SETUP_LED_Disp(22,0);delay(2500);
1353   5                                                                      }
1354   4                                                         }
1355   3                                               }
1356   2                                  else if (Itemm == mV_ZERO_CAL)
1357   2                                     {
1358   3                                                  if (Work_Type != 2)   {     Itemm = Itemm + 1;}
1359   3                                                      else{
1360   4                                                               if( AV_COD == 1){ NG_COD = 1;}else{ NG_COD = 0;}
1361   4                                                                SETUP_LED_Disp(Itemm,Data_Value[9]);
1362   4                                                                if(confrom_key == 1)
1363   4                                                                  {
1364   5                                                                       mV_Zero_offset = Data_Value[9] ;
1365   5                                                                       EEPROM_write_word(mV_Zero,mV_Zero_offset);  
1366   5                                                                        delay(50);
1367   5                                                                       if( NG_COD == 1){ EEPROM_write_byte(Status_flag,(use_flag|0x04));}
1368   5                                                                       else { EEPROM_write_byte(Status_flag,(use_flag&0xfb));}
1369   5                                                                       times ++; SETUP_LED_Disp(22,0);        delay(2500);
1370   5                                                                      }
1371   4                                                         }
1372   3                                                }
1373   2                                  else if (Itemm == mV_SPAN_CAL)
1374   2                                       {
1375   3                                                         if (Work_Type != 2) {        Itemm = Itemm + 1;}
1376   3                                                        else{ 
1377   4                                                                SETUP_LED_Disp(Itemm,Data_Value[9]);
1378   4                                                                if(confrom_key == 1)
C51 COMPILER V9.02   MAIN                                                                  03/30/2015 14:00:36 PAGE 34  

1379   4                                                                  {
1380   5                                                                        mV_Span_offset = Data_Value[9] ;
1381   5      
1382   5                                                                       EEPROM_write_word(mV_Span,mV_Span_offset);  
1383   5      
1384   5                                                                       if( NG_COD == 1)
1385   5                                                                         { if ((mV_Span_offset + mV_Zero_offset) > 0x7d00 )            
1386   6                                                                              { mV_Span_Value = ((mV_Span_offset + mV_Zero_offset)/((mV_Span_offset + mV_Zero_offset)-0x
             -7d00));}
1387   6                                                                               else
1388   6                                                                                  { mV_Span_Value = ((mV_Span_offset + mV_Zero_offset)/(0x7d00 - (mV_Span_offset + mV_Zero_offs
             -et)));}
1389   6                                                                         }
1390   5                                                                       else
1391   5                                                                         { if ((mV_Span_offset - mV_Zero_offset) > 0x7d00)
1392   6                                                                              { mV_Span_Value = ((mV_Span_offset - mV_Zero_offset)/((mV_Span_offset - mV_Zero_offset)-0x
             -7d00));}
1393   6                                                                               else
1394   6                                                                                  { mV_Span_Value = ((mV_Span_offset - mV_Zero_offset)/(0x7d00 - (mV_Span_offset - mV_Zero_offs
             -et)));}
1395   6                                                                         }
1396   5                                                                          EEPROM_write_word(mV_Span_Per,mV_Span_Value);
1397   5                                                                       times ++;      SETUP_LED_Disp(22,0);delay(2500);
1398   5                                                                      }
1399   4                                                         }
1400   3                                               }
1401   2                                 else if (Itemm == mA_ZERO_CAL)
1402   2                                     {
1403   3                                                   if (Work_Type != 3)  {     Itemm = Itemm + 1;}
1404   3                                                      else{
1405   4                                                                if( AV_COD == 1){ NG_COD = 1;}else{ NG_COD = 0;}
1406   4                                                                SETUP_LED_Disp(Itemm,Data_Value[9]);
1407   4                                                                if(confrom_key == 1)
1408   4                                                                  {
1409   5                                         delay(50);
1410   5                                                                       mA_Zero_offset = Data_Value[9];
1411   5                                                                       EEPROM_write_word(mA_Zero,mA_Zero_offset);  
1412   5                                                                         delay(50);
1413   5                                                                      if( NG_COD == 1){ EEPROM_write_byte(Status_flag,(use_flag|0x08));}
1414   5                                                                       else { EEPROM_write_byte(Status_flag,(use_flag&0xf7));}
1415   5                                                                       times ++; SETUP_LED_Disp(22,0);delay(25000);
1416   5                                                                      }
1417   4                                                         }
1418   3                                               }
1419   2                                  else if (Itemm == mA_SPAN_CAL)
1420   2                                      {
1421   3                                                        if (Work_Type != 3)  {Itemm = Itemm + 1;}
1422   3                                                      else{
1423   4                                                               SETUP_LED_Disp(Itemm,Data_Value[9] );
1424   4                                                                if(confrom_key == 1)
1425   4                                                                  {
1426   5                                                                       mA_Span_offset = Data_Value[9] ; 
1427   5                                                                       EEPROM_write_word(mA_Span,mA_Span_offset);  
1428   5                                                                       delay(50);
1429   5                                                                       if( NG_COD == 1)
1430   5                                                                         { if ((mA_Span_offset + mA_Zero_offset) > 0x1900 )   
1431   6                                                                              { mA_Span_Value = ((mA_Span_offset + mA_Zero_offset)/((mA_Span_offset + mA_Zero_offset)- 0
             -x1900));}
1432   6                                                                               else
1433   6                                                                                  { mA_Span_Value = ((mA_Span_offset + mA_Zero_offset)/( 0x1900 - (mA_Span_offset + mA_Zero_off
             -set)));}
1434   6                                                                         }
C51 COMPILER V9.02   MAIN                                                                  03/30/2015 14:00:36 PAGE 35  

1435   5                                                                       else
1436   5                                                                         { if ((mA_Span_offset - mA_Zero_offset) > 0x1900 )
1437   6                                                                              { mA_Span_Value = ((mA_Span_offset - mA_Zero_offset)/((mA_Span_offset - mA_Zero_offset)- 0
             -x1900));}
1438   6                                                                               else
1439   6                                                                                  { mA_Span_Value = ((mA_Span_offset - mA_Zero_offset)/( 0x1900 - (mA_Span_offset - mA_Zero_off
             -set)));}
1440   6                                                                         }
1441   5                                                                               EEPROM_write_word(mA_Span_Per,mA_Span_Value);
1442   5                                                                           times ++; SETUP_LED_Disp(22,0);    delay(2500);
1443   5                                                                      }
1444   4                                                         }
1445   3                                                 }
1446   2                                               
1447   2                                 else if (Itemm == ALARM_LO_CAL)
1448   2                                       {
1449   3                                     alarm_Low_set = alarm_Low_set + value_cal*10 ;
1450   3                                                                                value_cal = 0;
1451   3                                                                SETUP_LED_Disp(Itemm,alarm_Low_set);
1452   3                                                                if((up_key == 1)||(don_key == 1))
1453   3                                                                  {
1454   4                                                                   if(alarm_Low_set > 9999){value_cal = 0;alarm_Low_set = 0;}
1455   4                                                                       if(confrom_key == 1)
1456   4                                                                    {
1457   5                                                              EEPROM_write_word(Alarm_Low,alarm_Low_set);  //alarm
1458   5                                                                              times ++; SETUP_LED_Disp(22,0);delay(2500);
1459   5                                                                        } 
1460   4                                                                  }
1461   3                                                      }
1462   2                                   else if (Itemm == ALARM_HI_CAL)
1463   2                                      { 
1464   3                                                                 alarm_Hi_set = alarm_Hi_set + value_cal*10 ;
1465   3                                                                  value_cal = 0;
1466   3                                                                 SETUP_LED_Disp(Itemm,alarm_Hi_set);
1467   3                                                                if((up_key == 1)||(don_key == 1))
1468   3                                                                  {
1469   4                                                                        if(alarm_Hi_set > 9999){value_cal = 0;alarm_Hi_set = 0;}
1470   4      
1471   4                                                                        if(confrom_key == 1)
1472   4                                                                    {
1473   5                                                              EEPROM_write_word(Alarm_Hi,alarm_Hi_set);  //alarm
1474   5                                                                              times ++; SETUP_LED_Disp(22,0);delay(2500);
1475   5                                                                        }
1476   4                                                                  }
1477   3                                                      }
1478   2                                   else if (Itemm == YEAR_DATE_CAL)
1479   2                                      {   
1480   3                                                         if(value_cal >= 200)
1481   3                                                           {
1482   4                                                                 if(use_year == 0) {use_year = 0x99; value_cal = 0 ;}
1483   4                                                                 else
1484   4                                                                  { if((use_year&0x0f) == 0){use_year = (((use_year-0x10)&0xf0)|0x09); value_cal = 0 ; }
1485   5                                                                        else { use_year = use_year -0x01; value_cal = 0 ;}
1486   5                                                                  }
1487   4                                                               }
1488   3                                                              else
1489   3                                                               {
1490   4                                                                if(value_cal == 1) 
1491   4                                                                 {
1492   5                                                                    if(use_year >= 0x9a) { use_year = 0; value_cal = 0;}
1493   5                                                                       else{if((use_year&0x0f) == 0x09) {use_year = ((use_year+0x10)&0xf0);value_cal = 0; } 
1494   6                                                                            else { use_year = use_year + 0x01; value_cal = 0;} } 
C51 COMPILER V9.02   MAIN                                                                  03/30/2015 14:00:36 PAGE 36  

1495   5                                                             } 
1496   4                                                                }     
1497   3                                                        SETUP_LED_Disp(Itemm,use_year + 0x2000);
1498   3                                                                                                                                               
1499   3                                                               if(confrom_key == 1)
1500   3                                                                 {
1501   4                                                                    RTC_write_byte(6,use_year);
1502   4                                                                      EEPROM_write_byte(Year_Date,use_year); 
1503   4                                                                              times ++;SETUP_LED_Disp(22,0);delay(2500);
1504   4                                                                 }
1505   3                                                           
1506   3                                                 }
1507   2                                 else if (Itemm == MON_DATE_CAL)
1508   2                                     {
1509   3                                                     if(value_cal >= 200)
1510   3                                                           {
1511   4                                                                 if(use_mon <= 0x01){use_mon = 0x12; value_cal = 0 ;}
1512   4                                                            else
1513   4                                                                 { if((use_mon&0x0f) == 0) {use_mon = (((use_mon-0x10)&0xf0)|0x09); value_cal = 0 ; }
1514   5                                                                           else{use_mon = use_mon - 0x01; value_cal = 0 ;}
1515   5                                                                 }
1516   4                                                               }
1517   3                                                        else
1518   3                                                               {
1519   4                                                                if(value_cal == 1) 
1520   4                                                                  {
1521   5                                                                        if(use_mon == 0x12){use_mon = 0x01; value_cal = 0 ;}
1522   5                                                                       else {if((use_mon&0x0f) == 0x09) {use_mon = ((use_mon+0x10)&0xf0); value_cal = 0;}
1523   6                                                                          else { use_mon = use_mon + 0x01; value_cal = 0 ;}}
1524   5                                                                      }
1525   4                                                               }
1526   3                                                                SETUP_LED_Disp(Itemm,use_mon);
1527   3      
1528   3                                                               if(confrom_key == 1)
1529   3                                                                 {
1530   4                                                                   RTC_write_byte(5,use_mon);
1531   4                                                                       EEPROM_write_byte(Mon_Date,use_mon);
1532   4                                                                       times ++;  SETUP_LED_Disp(22,0);delay(2500);
1533   4                                                                 }
1534   3                                                      }
1535   2                                 else if (Itemm == DAY_DATE_CAL)                      //add week setup
1536   2                                    {
1537   3                                                       if(value_cal >= 200)
1538   3                                                         {
1539   4                                                           if((use_day == 1)&&(use_mon == 0x02)&&(use_year%4 == 0)) { use_day = 0x29 ;  value_cal = 0 ; }
1540   4                                                          else if((use_day == 1)&&(use_mon == 0x02)&&(use_year%4 != 0)) { use_day = 0x28 ; value_cal = 0 ;
             - }
1541   4                                                          else if((use_day == 1)&&((use_mon == 1)||(use_mon == 3)||(use_mon == 5)||(use_mon == 7)||(use_mo
             -n == 0x08)||(use_mon ==0x10)||(use_mon == 0x12))) { use_day =0x31;value_cal = 0;}
1542   4                                                          else if((use_day == 1)&&((use_mon == 4)||(use_mon == 6)||(use_mon == 0x09)||(use_mon == 0x11))) 
             -{ use_day = 0x30 ;  value_cal = 0 ; }
1543   4                                                              else if((use_day&0x0f) == 0) {use_day = (((use_day-0x10)&0xf0)|0x09);value_cal = 0;}
1544   4                                                               else {use_day = use_day -1; value_cal = 0;}
1545   4                                                        }
1546   3                                                 else
1547   3                                                       {
1548   4                                                       if(value_cal == 1)
1549   4                                                         {
1550   5                                                               if((use_mon == 2)&&(use_year%4 == 0)&&(use_day == 0x29)) { use_day = 1; value_cal = 0;}
1551   5                                                              else if((use_mon == 2)&&(use_year%4 != 0)&&(use_day == 0x28)) { use_day = 1; value_cal = 0;}
1552   5                                                              else if(((use_mon == 1)||(use_mon == 3)||(use_mon == 5)||(use_mon == 7)||(use_mon == 8)||(use_mon =
             -= 0x10)||(use_mon == 0x12))&&(use_day == 0x31)) { use_day = 1;value_cal = 0;}
C51 COMPILER V9.02   MAIN                                                                  03/30/2015 14:00:36 PAGE 37  

1553   5                                                              else if(((use_mon == 4)||(use_mon == 6)||(use_mon == 9)||(use_mon == 0x11))&&(use_day == 0x30)) { u
             -se_day = 1; value_cal = 0;}
1554   5                                                              else if((use_day&0x0f) == 0x09) {use_day = ((use_day + 0x10)&0xf0); value_cal = 0;}
1555   5                                                                 else{use_day = use_day + 1; value_cal = 0;}                 
1556   5                                                         }
1557   4                                                       }
1558   3                                               SETUP_LED_Disp(Itemm,use_day);
1559   3      
1560   3                                                       if(confrom_key == 1)
1561   3                                                         {
1562   4                                                           RTC_write_byte(4,use_day);
1563   4                                                               EEPROM_write_byte(Day_Date,use_day);
1564   4                                                                       times ++;      SETUP_LED_Disp(22,0);delay(250);
1565   4                                                         }
1566   3                                              }
1567   2                                else if (Itemm == HOUR_DATE_CAL)
1568   2                                   {
1569   3                                                        if(value_cal >= 200)
1570   3                                                         {
1571   4                                                          if (use_hour == 0){use_hour = 0x23; value_cal = 0;}
1572   4                                                          else 
1573   4                                                               { if((use_hour&0x0f) == 0x00) {use_hour = ((use_hour-0x10)&0xf0)|0x09; value_cal = 0;}  
1574   5                                                                 else {use_hour = use_hour - 0x01; value_cal = 0;}
1575   5                                                               }
1576   4                                                         }
1577   3                                                       else
1578   3                                                         {
1579   4                                                          if(value_cal == 1)
1580   4                                                           {
1581   5                                                                 if(use_hour == 0x23) {use_hour = 0; value_cal = 0;}
1582   5                                                                 else
1583   5                                                                  { if((use_hour&0x0f) == 0x09) {use_hour = (use_hour+0x10)&0xf0; value_cal = 0;}
1584   6                                                                        else {use_hour = use_hour + 0x01; value_cal = 0;}
1585   6                                                                      }    
1586   5                                                               }
1587   4                                                          }
1588   3                                                         SETUP_LED_Disp(Itemm,use_hour);
1589   3                                                         if(confrom_key == 1)
1590   3                                                               {
1591   4                                                                   RTC_write_byte(2,use_hour);
1592   4                                                                      EEPROM_write_byte(Hour_Date,use_hour);
1593   4                                                                       times ++;      SETUP_LED_Disp(22,0);delay(250);
1594   4                                                               }
1595   3                                               }
1596   2                             else if (Itemm == MIN_DATE_CAL)
1597   2                                   {
1598   3                                                   if(value_cal >= 200)
1599   3                                                         {
1600   4                                                           if(use_min == 0) { use_min = 0x59; value_cal = 0;}
1601   4                                                              else 
1602   4                                                               {
1603   5                                                                  if((use_min&0x0f) == 0) {use_min = ((use_min - 0x10)&0xf0)|0x09; value_cal = 0;} 
1604   5                                                                 else { use_min = use_min - 0x01; value_cal = 0;}
1605   5                                                               }
1606   4                                                        }
1607   3                                                      else
1608   3                                                        {     
1609   4                                                           if (value_cal == 1) 
1610   4                                                                 {
1611   5                                                                    if(use_min == 0x59) {use_min = 0; value_cal = 0;}
1612   5                                                                        else
1613   5                                                                         {  if((use_min&0x0f) == 0x09) {use_min = (use_min+0x10)&0xf0; value_cal = 0;}
C51 COMPILER V9.02   MAIN                                                                  03/30/2015 14:00:36 PAGE 38  

1614   6                                                                            else { use_min = use_min + 0x01; value_cal = 0;}
1615   6                                                                         }
1616   5                                                                 }
1617   4                                                        }
1618   3                                          SETUP_LED_Disp(Itemm,use_min );
1619   3                                                        if(confrom_key == 1)
1620   3                                                          {
1621   4                                                                   RTC_write_byte(1,use_min );
1622   4                                                                       EEPROM_write_byte(Min_Date,use_min);
1623   4                                                                       times ++;SETUP_LED_Disp(22,0); delay(250);
1624   4                                                              }
1625   3                                            }
1626   2                                          else if (Itemm >= PRODUCT_RESET)
1627   2                                                 { 
1628   3                                                                Itemm = 0 ;
1629   3                                                                CAIT  = 0 ;
1630   3                                                 }
1631   2                                       }
1632   1                      Check_PCB();                    
1633   1      }
1634          //*******************************
1635          void RTC_ON(void)
1636          { 
1637   1         use_week = RTC_read_byte(0x03);
1638   1         RTC_write_byte(0x07,SQWE);
1639   1         RTC_write_byte(0x03,use_week|0x08);    
1640   1                                   
1641   1          if((use_week&OSC_EN) == OSC_EN) {;}       // if oscillator = already running, do nothing. 
1642   1          else
1643   1               { 
1644   2             RTC_write_byte(0x06,use_year)   ;     // initialize YEAR  register           
1645   2             RTC_write_byte(0x05,use_mon)    ;     // initialize MONTH register  
1646   2             RTC_write_byte(0x04,use_day)    ;     // initialize DATE  register  
1647   2             RTC_write_byte(0x03,use_week|0x08);
1648   2             RTC_write_byte(0x02,use_hour)   ;     // initialize HOUR  register  
1649   2             RTC_write_byte(0x01,use_min)    ;     // initialize MIN   register  
1650   2             RTC_write_byte(0x00,use_sec|0x80) ;
1651   2               } 
1652   1       
1653   1      }
1654          /************************************************/
1655          void RTC_WRITE_SET(void)
1656          {
1657   1      
1658   1         RTC_write_byte(0x00,(use_sec|0x80));
1659   1      
1660   1         RTC_write_byte(0x01,use_min);
1661   1      
1662   1         RTC_write_byte(0x02,use_hour);
1663   1      
1664   1         RTC_write_byte(0x03,use_week|0x08);
1665   1      
1666   1         RTC_write_byte(0x04,use_day);
1667   1      
1668   1         RTC_write_byte(0x05,use_mon);
1669   1      
1670   1         RTC_write_byte(0x06,use_year);
1671   1      
1672   1         RTC_write_byte(0x07,0x40);
1673   1      }
1674          /*****************************************/
1675          void RTC_READ_SET(void)
C51 COMPILER V9.02   MAIN                                                                  03/30/2015 14:00:36 PAGE 39  

1676          { 
1677   1       use_sec  = RTC_read_byte(0x00)&0x7f ;
1678   1       use_min  = RTC_read_byte(0x01) ;
1679   1       use_hour = RTC_read_byte(0x02) ;
1680   1       use_week = RTC_read_byte(0x03)&0x07 ;
1681   1       use_day  = RTC_read_byte(0x04);
1682   1       use_mon  = RTC_read_byte(0x05);
1683   1       use_year = RTC_read_byte(0x06);
1684   1      
1685   1       if((use_mon&0x03) == 0x01)
1686   1       { 
1687   2         EEPROM_write_byte(Year_Date,use_year);
1688   2         EEPROM_write_byte(Mon_Date, use_mon);
1689   2         EEPROM_write_byte(Day_Date, use_day);
1690   2         EEPROM_write_byte(Week_Date, use_week);
1691   2         EEPROM_write_byte(Hour_Date,use_hour);
1692   2         EEPROM_write_byte(Min_Date, use_min);
1693   2         EEPROM_write_byte(sec_Date, use_sec);
1694   2       }
1695   1      }
1696          //*******************************
1697          void EEPROM_WriteDefault(void)
1698          {
1699   1          Check_PCB();
1700   1          EEPROM_write_byte(Mode_Select,Work_Type); //setup mode
1701   1          EEPROM_write_byte(C_F_Select, 0);  //c
1702   1              EEPROM_write_byte(Type_Select,0);  //Type define k=0.j=1,t=2
1703   1      
1704   1              EEPROM_write_word(TC_Zero, 0);  
1705   1              EEPROM_write_word(TC_Span, 1400);
1706   1              EEPROM_write_word(RTD_Zero, 0);
1707   1              EEPROM_write_word(RTD_Span, 850);
1708   1              EEPROM_write_word(mV_Zero, 0);
1709   1              EEPROM_write_word(mV_Span, 5000);
1710   1              EEPROM_write_word(mA_Zero, 40); 
1711   1          EEPROM_write_word(mA_Span, 200);
1712   1              EEPROM_write_word(Alarm_Low, 0);
1713   1              EEPROM_write_word(Alarm_Hi, 5000);
1714   1      
1715   1          EEPROM_write_byte(Year_Date,0x15);
1716   1          EEPROM_write_byte(Mon_Date, 0x01);
1717   1          EEPROM_write_byte(Day_Date, 0x01);
1718   1              EEPROM_write_byte(Week_Date,0x04);
1719   1          EEPROM_write_byte(Hour_Date,0x12);
1720   1          EEPROM_write_byte(Min_Date, 0x01);
1721   1              EEPROM_write_byte(sec_Date, 0x01);
1722   1              EEPROM_write_byte(Status_flag, 0);
1723   1              EEPROM_write_word(TC_Span_Per, 1);
1724   1              EEPROM_write_word(RTD_Span_Per, 1);
1725   1              EEPROM_write_word(mV_Span_Per, 1);
1726   1              EEPROM_write_word(mA_Span_Per, 1);
1727   1              EEPROM_write_word(60,0);
1728   1              EEPROM_write_word(EEP_ADR, 64);         //eep start code
1729   1          RTC_ON();
1730   1      }
1731          /*****************************************************/
1732          void DO_RESET_TYPE(void)
1733          {
1734   1           EEPROM_WriteDefault();
1735   1           LED_Fill();                                     //  LED all light
1736   1               Work_Type = EEPROM_read_byte(Mode_Select);
1737   1               C_F_Type = EEPROM_read_byte(C_F_Select);
C51 COMPILER V9.02   MAIN                                                                  03/30/2015 14:00:36 PAGE 40  

1738   1               TC_Type = EEPROM_read_byte(Type_Select);       //Type define k=0.j=1,t=2
1739   1               TC_Zero_offset = EEPROM_read_word(TC_Zero);    
1740   1               TC_Span_offset = EEPROM_read_word(TC_Span);
1741   1               RTD_Zero_offset = EEPROM_read_word(RTD_Zero);
1742   1               RTD_Span_offset = EEPROM_read_word(RTD_Span);
1743   1               mA_Zero_offset = EEPROM_read_word(mA_Zero);
1744   1               mA_Span_offset = EEPROM_read_word(mA_Span);
1745   1      
1746   1               mV_Zero_offset = EEPROM_read_word(mV_Zero);    
1747   1           mV_Span_offset = EEPROM_read_word(mV_Span);
1748   1               alarm_Low_set = EEPROM_read_word(Alarm_Low);
1749   1               alarm_Hi_set = EEPROM_read_word(Alarm_Hi);
1750   1           use_year = EEPROM_read_word(Year_Date);
1751   1      
1752   1           use_mon =  EEPROM_read_byte(Mon_Date);
1753   1           use_day =  EEPROM_read_byte(Day_Date);
1754   1               use_week = EEPROM_read_byte(Week_Date);
1755   1           use_hour = EEPROM_read_byte(Hour_Date);
1756   1           use_min =  EEPROM_read_byte(Min_Date);
1757   1               use_sec =  EEPROM_read_byte(sec_Date);
1758   1               use_flag =     EEPROM_read_byte(Status_flag);
1759   1               TC_Span_Value = EEPROM_read_word(TC_Span_Per);
1760   1               RTD_Span_Value = EEPROM_read_word(RTD_Span_Per);
1761   1               mV_Span_Value = EEPROM_read_word(mV_Span_Per);
1762   1               mA_Span_Value = EEPROM_read_word(mA_Span_Per);
1763   1               Temp_offset  = EEPROM_read_word(60);
1764   1      //       eep_count = EEPROM_read_byte(EEP_ADR);
1765   1      }
1766          /***********************************
1767          ****      System_Start          ****
1768          ***********************************/ 
1769          main(void)
1770          {
1771   1         TR0 = 0;
1772   1         TMOD = TMOD |= 0x01;
1773   1         TH0  = 0xDC; //use timer0 to delay 5ms
1774   1         TL0  = 0;
1775   1         TF0  = 0; 
1776   1      
1777   1         IFMT = 0x07 ; //#AUXRA_Rd ;set read AUXRA command
1778   1         SCMD = 0x46; //h
1779   1         SCMD = 0xB9; //h
1780   1         IFD  = IFD |= 0x08; //;
1781   1         IFMT = 0x06;  // #AUXRA_Wr ;set write AUXRA command
1782   1         SCMD = 0x46; // #46h
1783   1         SCMD = 0xB9; //h
1784   1         TR0  = 1 ;  //;timer0 run
1785   1         while( ~TF0 ) 
1786   1            {   }
1787   1         TF0 = 0;  //
1788   1         TR0  = 0; //;timer0 stop
1789   1         IFMT = 0x07 ; //#AUXRA_Rd ;set read AUXRA command
1790   1         SCMD = 0x46 ; //h
1791   1         SCMD = 0xB9 ; //h
1792   1         IFD  = IFD |= 0x03 ;
1793   1         IFMT = 0x06; // #AUXRA_Wr ;set write AUXRA command
1794   1         SCMD = 0x46; // h
1795   1         SCMD = 0xB9; //h
1796   1         IFMT = 0x07; //#AUXRA_Rd ;set read AUXRA command
1797   1         SCMD = 0x46; //h
1798   1         SCMD = 0xB9; //h
1799   1         IFD = IFD &= 0xFB; //
C51 COMPILER V9.02   MAIN                                                                  03/30/2015 14:00:36 PAGE 41  

1800   1         IFMT = 0x06; //, #AUXRA_Wr ;set write AUXRA command
1801   1         SCMD = 0x46; //h
1802   1         SCMD = 0x0B9; //h
1803   1      
1804   1              PORT_Init();
1805   1              RTC_SCL = 1;
1806   1              RTC_SDA = 1;
1807   1              EEPROM_Init();
1808   1              LED_Init();
1809   1              T0_Init();
1810   1              T1_Init();
1811   1              AD3421_Init();
1812   1              InitUart();
1813   1          Set_mA(0);
1814   1          LED_Fill();
1815   1              Set_mV(0);
1816   1              Buzzer(OFF);
1817   1              Soft_Timer_Enable = 0;
1818   1      
1819   1              if((EEPROM_read_byte(0) != 'N')||(EEPROM_read_byte(1) != 'E')||(EEPROM_read_byte(2) != 'W')||(EEPROM_read
             -_byte(3) != JOHNSON)||(EEPROM_read_byte(4) != LIN))
1820   1           {
1821   2                      EEPROM_write_byte(0, 'N');      
1822   2                      EEPROM_write_byte(1, 'E');
1823   2                      EEPROM_write_byte(2, 'W');
1824   2                      EEPROM_write_byte(3, JOHNSON);  
1825   2                      EEPROM_write_byte(4, LIN);
1826   2                      RTC_ON();       
1827   2                      EEPROM_WriteDefault();
1828   2           }
1829   1             LED_Fill(); 
1830   1                 Work_Type = EEPROM_read_byte(Mode_Select);           
1831   1                 C_F_Type = EEPROM_read_byte(C_F_Select);
1832   1                 TC_Type  = EEPROM_read_byte(Type_Select);       //Type define k=0.j=1,t=2
1833   1                 TC_Zero_offset = EEPROM_read_word(TC_Zero);  
1834   1                 TC_Span_offset = EEPROM_read_word(TC_Span);
1835   1                 RTD_Zero_offset = EEPROM_read_word(RTD_Zero);
1836   1                 RTD_Span_offset = EEPROM_read_word(RTD_Span);
1837   1                 mV_Zero_offset = EEPROM_read_word(mV_Zero);
1838   1                 mV_Span_offset = EEPROM_read_word(mV_Span);
1839   1                 mA_Zero_offset = EEPROM_read_word(mA_Zero);  
1840   1             mA_Span_offset = EEPROM_read_word(mA_Span);
1841   1                 alarm_Low_set = EEPROM_read_word(Alarm_Low);
1842   1                 alarm_Hi_set = EEPROM_read_word(Alarm_Hi);
1843   1             use_year = EEPROM_read_byte(Year_Date);
1844   1             use_mon = EEPROM_read_byte(Mon_Date);
1845   1             use_day = EEPROM_read_byte(Day_Date);
1846   1             use_hour = EEPROM_read_byte(Hour_Date);
1847   1             use_min = EEPROM_read_byte(Min_Date);
1848   1                 use_sec = EEPROM_read_byte(sec_Date);
1849   1      
1850   1                 use_flag =   EEPROM_read_byte(Status_flag);
1851   1      
1852   1                 TC_Span_Value = EEPROM_read_word(TC_Span_Per);
1853   1                 RTD_Span_Value = EEPROM_read_word(RTD_Span_Per);
1854   1                 mV_Span_Value = EEPROM_read_word(mV_Span_Per);
1855   1                 mA_Span_Value = EEPROM_read_word(mA_Span_Per);
1856   1                 Temp_offset  = EEPROM_read_word(60);
1857   1      //         eep_count = EEPROM_read_byte(EEP_ADR);
1858   1                 Disp_year = use_year+0x2000;
1859   1                 RTC_ON();
1860   1        
C51 COMPILER V9.02   MAIN                                                                  03/30/2015 14:00:36 PAGE 42  

1861   1      
1862   1               ET0 = 1;
1863   1               TR0 = 1;
1864   1               ET1 = 1;
1865   1               TR1 = 1;
1866   1               EA  = 1;
1867   1               MAIN_SW = 1 ;
1868   1      
1869   1           Check_PCB();
1870   1      
1871   1              if(Work_Type == 0)
1872   1                { if(use_flag & 0x01) NG_COD = 1 ;}
1873   1              else if(Work_Type == 1)
1874   1                { if(use_flag & 0x02) NG_COD = 1 ;}
1875   1              else if(Work_Type == 2)
1876   1                { if(use_flag &0x04)  NG_COD = 1 ;}
1877   1              else if(Work_Type == 3)
1878   1                { if(use_flag & 0x08) NG_COD = 1 ;}
1879   1      
1880   1      //***************************************
1881   1              while (1)
1882   1              {
1883   2                      switch (Func_Type)
1884   2                        {
1885   3                              case TC_FUNCTION:
1886   3                          if(Work_Type == 0)
1887   3                            { if(use_flag & 0x0010) {ADD_COD = 1;}else{ADD_COD = 0;}}
1888   3                                      DO_TC_TYPE();
1889   3                                      break;
1890   3      
1891   3                              case RTD_FUNCTION:
1892   3                              DO_RTD_TYPE();
1893   3                                      break;
1894   3      
1895   3                              case mV_FUNCTION:
1896   3                                      DO_mV_TYPE();
1897   3                                      break;
1898   3      
1899   3                              case mA_FUNCTION:
1900   3                                  DO_mA_TYPE();
1901   3                                      break;
1902   3                              
1903   3                              case SETUP_FUNCTION:
1904   3                                              CAIT = 1 ;
1905   3                                      DO_SETUP_TYPE();
1906   3                              
1907   3                                      break;
1908   3      
1909   3                              case CLEAR_FUNCTION:
1910   3                                      DO_RESET_TYPE();
1911   3                                      break;
1912   3                     }
1913   2               }
1914   1      }
C51 COMPILER V9.02   MAIN                                                                  03/30/2015 14:00:36 PAGE 43  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


R485_RX. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B0H  1
CCF2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DAH  1
TB80 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009BH  1
PCAPWM4. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F6H  1
P1M0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0091H  1
P0M1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0094H  1
_RTC_read_byte . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
non3 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0097H  1
CCF3 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DBH  1
TB81 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009BH  1
PCAPWM5. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F7H  1
P2M0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0095H  1
P1M1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0092H  1
P0 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0080H  1
f_half_sec . . . . . . . . . . . . . .  PUBLIC   DATA   BIT      0000H  1
AD_Mid . . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0000H  1
ADD_COD. . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0001H  1
R485_TX. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B1H  1
CCF4 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DCH  1
SM00 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009FH  1
P3M0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B1H  1
P2M1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0096H  1
P1 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0090H  1
CCF5 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DDH  1
SM01 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009FH  1
SM10 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009EH  1
P4M0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B3H  1
P3M1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B2H  1
P2 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A0H  1
Soft_Timer . . . . . . . . . . . . . .  PUBLIC   IDATA  ARRAY    0000H  9
DO_RTD_TYPE. . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  RTD_Value. . . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
  key. . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
SM11 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009EH  1
SM20 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009DH  1
ISPCR. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E7H  1
P5M0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B5H  1
P4M1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B4H  1
P3 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B0H  1
XICON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C0H  1
EEPROM_WriteDefault. . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
serial . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
Temp_offset. . . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0002H  2
mA_Span_Value. . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0004H  2
EEPROM_SDA . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A2H  1
DOWN_KEY . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0087H  1
T0 . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B4H  1
SM21 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009DH  1
AC . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D6H  1
EVRCR. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0097H  1
P5M1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B6H  1
P4 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E8H  1
_TEMP_F_TO_C . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  tc_tmp . . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
  ttmp . . . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0002H  2
Key_backup . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0006H  1
T1 . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B5H  1
C51 COMPILER V9.02   MAIN                                                                  03/30/2015 14:00:36 PAGE 44  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


SPCON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0085H  1
P5 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F8H  1
EIE1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00ADH  1
_Buzzer. . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  status . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
TC_Zero_offset . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0007H  2
T2 . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0090H  1
EA . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AFH  1
SFRPI. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00ACH  1
WDTCR. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E1H  1
P6 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C8H  1
mV_SCL . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A4H  1
KBI0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A0H  1
SPI_MOSI . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0095H  1
SPI_MISO . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0096H  1
mA_OUT . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0085H  1
KBI1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A1H  1
SPCTL. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0085H  1
KBI2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A2H  1
AIN0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0090H  1
CF . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DFH  1
AUXIP. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00AEH  1
KBI3 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A3H  1
AIN1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0091H  1
KBI4 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A4H  1
AIN2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0092H  1
FE . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009FH  1
CH . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F9H  1
KBI5 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A5H  1
AIN3 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0093H  1
KBI6 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A6H  1
AIN4 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0094H  1
EEPROM_SCL . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A3H  1
RTD_C. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0081H  1
KBI7 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A7H  1
AIN5 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0095H  1
IE . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A8H  1
mA_Span_offset . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0009H  2
AIN6 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0096H  1
CL . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E9H  1
Read_AD3421_Value. . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  AD3421_Value . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
  ssta . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
_RTC_write_byte. . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
AIN7 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0097H  1
CEX0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0092H  1
CCAP0H . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FAH  1
ADCH . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C6H  1
_delay . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0004H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0006H  2
  j. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0005H  1
size_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
CEX1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0093H  1
CCAP1H . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FBH  1
IP0H . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B7H  1
INT0_Init. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
Func_Type. . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   000BH  1
C51 COMPILER V9.02   MAIN                                                                  03/30/2015 14:00:36 PAGE 45  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


ALL_SDA. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A2H  1
CEX2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0094H  1
CCAP2H . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FCH  1
OFFSET_KEY . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B3H  1
CEX3 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0095H  1
CCAP3H . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FDH  1
CEX4 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0096H  1
CR . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DEH  1
CCAP4H . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FEH  1
CCAP0L . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EAH  1
ADCL . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BEH  1
RD . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B7H  1
CEX5 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0097H  1
EXF2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CEH  1
REN0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009CH  1
CCAP5H . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FFH  1
CCAP1L . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EBH  1
CCAPM0 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DAH  1
IP0L . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B8H  1
Check_PCB. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
AD_Hi. . . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   000CH  1
REN1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009CH  1
CCAP2L . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00ECH  1
CCAPM1 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DBH  1
IT2H . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C3H  1
ES . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ACH  1
TSTWD. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0097H  1
CCAP3L . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EDH  1
CCAPM2 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DCH  1
mV_Span_Value. . . . . . . . . . . . .  PUBLIC   DATA   U_INT    000DH  2
IT3H . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C7H  1
CCAP4L . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EEH  1
CCAPM3 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DDH  1
IP . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B8H  1
CCAP5L . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EFH  1
CCAPM4 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DEH  1
RI . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0098H  1
CCAPM5 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DFH  1
TC_Type. . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   000FH  1
INT0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B2H  1
CY . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D7H  1
DO_RESET_TYPE. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
mA_Zero_offset . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0010H  2
BEEP . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B4H  1
mV_OUT . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0084H  1
INT1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B3H  1
TI . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0099H  1
EEP_SCL. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A3H  1
INT2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EBH  1
Volt_Ctrl. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
INT3 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EAH  1
ADCV . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C6H  1
STRETCH. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008FH  1
AD_Lo. . . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0012H  1
PT0L . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B9H  1
CAIT . . . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0013H  1
PT1L . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BBH  1
C51 COMPILER V9.02   MAIN                                                                  03/30/2015 14:00:36 PAGE 46  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


RCAP2H . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CBH  1
RTC_SDA. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A2H  1
PS . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BCH  1
PT2L . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BDH  1
SP . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0081H  1
mV_Span_offset . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0014H  2
T2EX . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0091H  1
CMOD . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D9H  1
CCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D8H  1
SCFG . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009AH  1
RTC_WRITE_SET. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
PX0L . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B8H  1
OV . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D2H  1
Disp_year. . . . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0016H  2
PX1L . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BAH  1
RCAP2L . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CAH  1
main . . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
PX2L . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BEH  1
SPI_CLK. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0097H  1
PX3L . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BFH  1
SCMD . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E6H  1
WR . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B6H  1
C_T2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C9H  1
Work_Type. . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0018H  1
DO_SETUP_TYPE. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  set_key. . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0000H  1
  times. . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0001H  1
  Itemm. . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0002H  1
  item_key . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0003H  1
  confrom_key. . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0004H  1
  up_key . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0005H  1
  don_key. . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0006H  1
  value_cal. . . . . . . . . . . . . .  AUTO     DATA   U_INT    0007H  2
T0_cnt . . . . . . . . . . . . . . . .  PUBLIC   IDATA  U_CHAR   0009H  1
SPISTAT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0084H  1
T1_cnt . . . . . . . . . . . . . . . .  PUBLIC   IDATA  U_CHAR   000AH  1
Get_Key. . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
T2_cnt . . . . . . . . . . . . . . . .  PUBLIC   IDATA  U_CHAR   000BH  1
_Get_E_Slope . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
RTC_SCL. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0096H  1
RCLK . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CDH  1
Soft_Timer_Enable. . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0019H  1
DO_TC_TYPE . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Code_Value . . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
  TC_Value . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0002H  2
  TT_Value . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0004H  2
  TA_Value . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0006H  2
  key. . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
TCLK . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CCH  1
P00. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0080H  1
IFADRH . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E3H  1
MAIN_SW. . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   001AH  1
_Check_Type_Offset . . . . . . . . . .  PUBLIC   CODE   PROC     0017H  -----
  Code_Value . . . . . . . . . . . . .  * REG *  DATA   U_INT    0002H  2
P10. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0090H  1
P01. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0081H  1
IFMT . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E5H  1
C51 COMPILER V9.02   MAIN                                                                  03/30/2015 14:00:36 PAGE 47  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


PCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0087H  1
SBUF . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0099H  1
mV_Zero_offset . . . . . . . . . . . .  PUBLIC   DATA   U_INT    001BH  2
_Get_J_Slope . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
P20. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A0H  1
P11. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0091H  1
P02. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0082H  1
_Get_K_Slope . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
Get_AD3421_Value . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
P30. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B0H  1
P21. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A1H  1
P12. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0092H  1
P03. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0083H  1
FUNCTION_KEY . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B2H  1
P40. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00E8H  1
P31. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B1H  1
P22. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A2H  1
P13. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0093H  1
P04. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0084H  1
IFADRL . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E4H  1
SCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0098H  1
InitUart . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
RTC_READ_SET . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
P50. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00F8H  1
P41. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00E9H  1
P32. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B2H  1
P23. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A3H  1
P14. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0094H  1
P05. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0085H  1
TMOD . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0089H  1
TCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0088H  1
P60. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C8H  1
P51. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00F9H  1
P42. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EAH  1
P33. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B3H  1
P24. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A4H  1
P15. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0095H  1
P06. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0086H  1
tran . . . . . . . . . . . . . . . . .  PUBLIC   DATA   BIT      0001H  1
TEMP . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A5H  1
P61. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C9H  1
P52. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00FAH  1
P43. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EBH  1
P34. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B4H  1
P25. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A5H  1
P16. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0096H  1
P07. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0087H  1
P53. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00FBH  1
P44. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ECH  1
P35. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B5H  1
P26. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A6H  1
P17. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0097H  1
Value_SDA. . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A0H  1
P45. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EDH  1
P36. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B6H  1
P27. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A7H  1
_Get_R_Slope . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
C51 COMPILER V9.02   MAIN                                                                  03/30/2015 14:00:36 PAGE 48  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


TC_C . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0080H  1
P46. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EEH  1
P37. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B7H  1
ex_int0. . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
_Get_S_Slope . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
P47. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EFH  1
KBMASK . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D7H  1
_Get_T_Slope . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_Set_mA. . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_SETUP_LED_Disp. . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
OUT_SCL. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A4H  1
PORT_Init. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
AD_SDA . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A0H  1
IE0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0089H  1
LED_Fill . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
IE1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008BH  1
RTD_Span_Value . . . . . . . . . . . .  PUBLIC   DATA   U_INT    001DH  2
LED1_SDA . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0090H  1
IE2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C1H  1
EEPROM_Init. . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
LED2_SDA . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0093H  1
IE3. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C5H  1
GF4. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AEH  1
AUXR . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008EH  1
B. . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F0H  1
KBPATN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D5H  1
Value_SCL. . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A1H  1
ReceiveFlag. . . . . . . . . . . . . .  PUBLIC   DATA   BIT      0002H  1
CP_RL2 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C8H  1
NONE_4 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A6H  1
DO_mA_TYPE . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  mA_Value . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
  key. . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
NONE_5 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A7H  1
AD3421_Init. . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
NONE_6 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B6H  1
SPIDAT . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0086H  1
ACC. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E0H  1
ReceiveDate. . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   001FH  1
_LED_Disp. . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
NONE_7 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B7H  1
AD_SCL . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A1H  1
ES0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ACH  1
PCB_SETUP. . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0020H  1
ET0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A9H  1
key. . . . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0021H  1
LED1_SCL . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0092H  1
TF0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008DH  1
ET1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ABH  1
use_flag . . . . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0022H  2
RTD_Span_offset. . . . . . . . . . . .  PUBLIC   DATA   U_INT    0024H  2
LED2_SCL . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0094H  1
TF1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008FH  1
RI0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0098H  1
ET2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ADH  1
NG_COD . . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0026H  1
LED_Init . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
C51 COMPILER V9.02   MAIN                                                                  03/30/2015 14:00:36 PAGE 49  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


TF2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CFH  1
RI1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0098H  1
RB8. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009AH  1
TH0. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008CH  1
IT0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0088H  1
TI0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0099H  1
EX0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A8H  1
TH1. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008DH  1
AV_COD . . . . . . . . . . . . . . . .  EXTERN   DATA   U_CHAR   -----  1
IT1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008AH  1
TI1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0099H  1
TB8. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009BH  1
EX1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AAH  1
SPICON . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0085H  1
TH2. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CDH  1
IT2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C0H  1
EX2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C2H  1
P. . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D0H  1
alarm_Hi_set . . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0027H  2
IT3. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C4H  1
EX3. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C6H  1
SM0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009FH  1
TL0. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008AH  1
_Set_mV. . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
mA_C . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0083H  1
XOUT . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C8H  1
ECI. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0091H  1
SM1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009EH  1
SPICTL . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0085H  1
TL1. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008BH  1
AUXIPH . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00AFH  1
alarm_Low_set. . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0029H  2
ALE. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EEH  1
SM2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009DH  1
TL2. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CCH  1
_Get_RTD_Slope . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
IFD. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E2H  1
PT0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B9H  1
NP_COD . . . . . . . . . . . . . . . .  EXTERN   DATA   U_CHAR   -----  1
R485_DE_RE . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B5H  1
PT1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BBH  1
RS0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D3H  1
TR0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008CH  1
PT2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BDH  1
RS1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D4H  1
TR1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008EH  1
TR2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CAH  1
PX0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B8H  1
EIP1H. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00AFH  1
RTD_Zero_offset. . . . . . . . . . . .  PUBLIC   DATA   U_INT    002BH  2
PX1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BAH  1
key_bak. . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   002DH  1
PX2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C3H  1
DO_mV_TYPE . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  mV_Value . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
  key. . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
PX3. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C7H  1
C51 COMPILER V9.02   MAIN                                                                  03/30/2015 14:00:36 PAGE 50  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


Temp_sp. . . . . . . . . . . . . . . .  PUBLIC   DATA   U_INT    002EH  2
Data_Value . . . . . . . . . . . . . .  PUBLIC   IDATA  ARRAY    000CH  20
EIP1L. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00AEH  1
DPH. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0083H  1
use_week . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0030H  1
CKO. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C8H  1
_EEPROM_read_byte. . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
DPL. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0082H  1
time0. . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Value_code . . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
PCON0. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0087H  1
SPSTAT . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0084H  1
SBUF0. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0099H  1
IPH. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B7H  1
time1. . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
use_year . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0031H  1
T0CKO. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B4H  1
PCON1. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0097H  1
SBUF1. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0099H  1
T1CKO. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B5H  1
EXEN2. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CBH  1
PCON2. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C7H  1
S2BUF. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009AH  1
SCON0. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0098H  1
Temp_m . . . . . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0032H  2
REN. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009CH  1
SCON1. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0098H  1
mV_C . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0082H  1
ADCON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C5H  1
RTC_ON . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
mA_SDA . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A2H  1
T2MOD. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C9H  1
T2CON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C8H  1
Zero_f . . . . . . . . . . . . . . . .  PUBLIC   DATA   BIT      0003H  1
_EEPROM_read_word. . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
ADCTL. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C5H  1
n_code . . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0034H  1
use_sec. . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0035H  1
ADCVL. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BEH  1
TC_Span_Value. . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0036H  2
wchar_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  CHAR     -----  1
SADEN. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B9H  1
AD_Status. . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0038H  1
C_F_Type . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0039H  1
S1BRT. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009AH  1
use_day. . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   003AH  1
RXD. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B0H  1
KBCON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D6H  1
use_hour . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   003BH  1
UP_KEY . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0086H  1
XIN. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C9H  1
PSL. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BCH  1
SADDR. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A9H  1
_EEPROM_write_byte . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
TXD. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B1H  1
mA_SCL . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A4H  1
AUXR0. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008EH  1
C51 COMPILER V9.02   MAIN                                                                  03/30/2015 14:00:36 PAGE 51  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


AUXR1. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A2H  1
SPI_SS . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0094H  1
AUXR2. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A6H  1
use_min. . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   003CH  1
Temp_Flag. . . . . . . . . . . . . . .  PUBLIC   IDATA  U_CHAR   0020H  1
OVER_COD . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   003DH  1
S2RXD. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0092H  1
F0 . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D5H  1
Temp_Read. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Temp_Count . . . . . . . . . . . . .  * REG *  DATA   U_INT    0002H  2
  P_count. . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0082H  2
BEEP_OUT . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B4H  1
S2TXD. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0093H  1
F1 . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D1H  1
TC_Span_offset . . . . . . . . . . . .  PUBLIC   DATA   U_INT    003EH  2
_EEPROM_write_word . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
LED1_LE. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0091H  1
LED2_LE. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0095H  1
T0_Init. . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
use_mon. . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0040H  1
PCAPWM0. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F2H  1
PSW. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D0H  1
T1_Init. . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
PCAPWM1. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F3H  1
T2_Init. . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
mV_SDA . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A2H  1
CCF0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D8H  1
RB80 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009AH  1
PCAPWM2. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F4H  1
CCF1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D9H  1
RB81 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009AH  1
PCAPWM3. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F5H  1
SPDAT. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0086H  1
P0M0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0093H  1
AUXIE. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00ADH  1


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   8172    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     65      31
   IDATA SIZE       =     33    ----
   BIT SIZE         =      4    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
