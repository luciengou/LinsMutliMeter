C51 COMPILER V9.02   MAIN                                                                  01/12/2014 08:41:24 PAGE 1   


C51 COMPILER V9.02, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c OMF2 OPTIMIZE(4,SPEED) BROWSE DEBUG

line level    source

   1          /***********************************************
   2            PRODUCT FOR NEWCAL MIX_TEMP FUNCTION
   3             CPU : MPC82G516
   4             BEGIN DATE: 2013.11.01
   5             FINISHED  : 2014.01.25
   6             WRITEBY   :JOHNSON LIN
   7             AD111  setup   SET 1001 0000 FOR A0 TYPE 
   8              8CH =  pga =1 ,32767BITS
   9          **************************************************/
  10          #include <MPC82G516.h>
  11          #include <intrins.h>
  12          #include <LED.h>
  13          #include <AD3421.h>
  14          #include <DAC6571_mV.h>
  15          #include <DAC6571_mA.h>
  16          #include <RTC3130.h>
  17          #include <EEPROM.H>
  18          #include <STDLIB.H>
  19          #include <TYPE_SLOPE.H>
  20          
  21          #define   BASE_TEMP             32               //F & C Transfor Data
  22          #define   MAX_TEMP              3240     //F 1800C
  23          #define   MAX_VOLT              4400     //mV
  24          #define   EEP_START             60
  25          #define   EEP_END                       20000
  26          #define   JOHNSON             0x5a
  27          #define   LIN                 0xa5
  28          
  29          #define   K_TYPE                0               //2466F   54.807mV      P0=0x00
  30          #define   J_TYPE                1               //1368F   42.922mV
  31          #define   T_TYPE            2           //360F    9.286mV
  32          #define   E_TYPE                3               //1440F   61.022mV
  33          #define   R_TYPE                4               //2880F   18.842mV
  34          #define   S_TYPE                5               //2880F   16.771mV
  35          #define   B_TYPE                6               //3240F   13.585mV
  36          #define   N_TYPE            7           //?       ?
  37          
  38          #define TC_FUNCTION             0
  39          #define RTD_FUNCTION    1
  40          #define mV_FUNCTION             2
  41          #define mA_FUNCTION             3
  42          #define RESET_FUNCTION  4
  43          #define SETUP_FUNCTION  5
  44          
  45          #define   ON    1
  46          #define   OFF   0
  47          
  48          
  49          #define DISPLAY_SEND_TIME  0       //timer out work select
  50          #define DATA_SAVE_TIME     1
  51          #define DATA_SEND_TIME     2
  52          #define SETUP_TIMEOUT      3
  53          #define TIMEUP_TIME        4
  54          
  55          #define ITEM              0
C51 COMPILER V9.02   MAIN                                                                  01/12/2014 08:41:24 PAGE 2   

  56          #define MODE_CAL          1
  57          #define C_F_CAL           2
  58          #define TYPE_CAL          3
  59          #define TC_ZERO_CAL       4
  60          #define TC_SPAN_CAL       5
  61          #define RTD_ZERO_CAL      6
  62          #define RTD_SPAN_CAL      7
  63          #define mV_ZERO_CAL       8
  64          #define mV_SPAN_CAL       9
  65          #define mA_ZERO_CAL       10
  66          #define mA_SPAN_CAL       11
  67          #define ALARM_LO_CAL      12
  68          #define ALARM_HI_CAL      13
  69          #define YEAR_DATE_CAL     14
  70          #define MON_DATE_CAL      15
  71          #define DAY_DATE_CAL      16
  72          #define HOUR_DATE_CAL     17
  73          #define MIN_DATE_CAL      18
  74          #define PRODUCT_RESET     19
  75          #define NOMAL_FUNCTION    0
  76          
  77                             
  78          #define  Mode_Select 18    //EEP Address
  79          #define  C_F_Select  19
  80          #define  Type_Select 20
  81          #define  TC_Zero     21   
  82          #define  TC_Span     23
  83          #define  RTD_Zero    25
  84          #define  RTD_Span    27
  85          #define  mV_Zero     29                                                                   
  86          #define  mV_Span     31
  87          #define  mA_Zero     33
  88          #define  mA_Span     35
  89          #define  Alarm_Low   37
  90          #define  Alarm_Hi    39
  91          #define  Year_Date   41
  92          #define  Mon_Date    42
  93          #define  Day_Date    43
  94          #define  Week_Date   44
  95          #define  Hour_Date   45
  96          #define  Min_Date    46
  97          #define  EEP_ADR     50
  98          
  99          sbit TC_SW1    = P0^0;  //k=0x00;j=0x01;t=0x02;e=0x03; 
 100          sbit TC_SW2    = P0^1;  //r=0x04;s=0x05;b=0x06;n=0x07;
 101          sbit TC_SW3    = P0^2;
 102          
 103          sbit TYPE_SW1  = P0^3;   //tc= 000 00xxx;  rtd=000 01xxx;    mV=000 10xxx
 104          sbit TYPE_SW2  = P0^4;   //mA= 000 11xxx;
 105          sbit TYPE_SW3  = P0^5;
 106          
 107          sbit UP_KEY   = P0^6;
 108          sbit DOWN_KEY = P0^7;
 109          
 110          sbit LED1_SCL = P1^0;
 111          sbit LED1_SDA = P1^1;
 112          sbit LED1_OE  = P1^2;
 113          sbit LED2_SCL = P1^3;
 114          sbit LED2_SDA = P1^4;
 115          sbit LED2_OE  = P1^5;
 116          sbit RTC_SCL  = P1^6;
 117          sbit RTC_SDA  = P1^7;
C51 COMPILER V9.02   MAIN                                                                  01/12/2014 08:41:24 PAGE 3   

 118          
 119          sbit mV_SCL   = P2^0;
 120          sbit mV_SDA   = P2^1;
 121          sbit mA_SCL   = P2^2;
 122          sbit mA_SDA   = P2^3;
 123          sbit EEP_SCL  = P2^4;
 124          sbit EEP_SDA  = P2^5;
 125          sbit Value_SCL  = P2^6;
 126          sbit Value_SDA  = P2^7;
 127          
 128          sbit R485_RX           = P3^0;
 129          sbit R485_TX           = P3^1;
 130          sbit FUNCTION_KEY      = P3^2;
 131          sbit OFFSET_KEY        = P3^3;
 132          sbit BEEP_OUT          = P3^4;   //for relay
 133          sbit R485_DE_RE        = P3^5;
 134          sbit NONE_0            = P3^6;
 135          sbit NONE_1            = P3^7;
 136          //===============================
 137          extern unsigned int KX; 
 138          extern unsigned int R;  
 139          extern unsigned int     TC_type_zero[8];         
 140          extern unsigned int     TC_type_span[8];
 141          extern unsigned char key_delay[16];
 142          
 143          idata unsigned char Soft_Timer[8] = {0,0,0,0,0,0,0,0};
 144          idata unsigned char T0_cnt, T1_cnt;
 145          
 146          unsigned char MAIN_SW;
 147          unsigned char Work_Type;
 148          unsigned char C_F_Type;
 149          unsigned char TC_Type;
 150          unsigned int  TC_Zero_offset;
 151          unsigned int  TC_Span_offset;
 152          unsigned int  RTD_Zero_offset;
 153          unsigned int  RTD_Span_offset;
 154          unsigned int  mV_Zero_offset;
 155          unsigned int  mV_Span_offset;
 156          unsigned int  mA_Zero_offset;
 157          unsigned int  mA_Span_offset;
 158          unsigned int  alarm_Low_set;
 159          unsigned int  alarm_Hi_set;
 160          unsigned char  use_year;
 161          unsigned char  use_mon;
 162          unsigned char  use_day;
 163          unsigned char  use_week;
 164          unsigned char  use_hour;
 165          unsigned char  use_min;
 166          unsigned char  eep_count;
 167          unsigned int   Disp_year;
 168          unsigned int  TempValue;
 169          
 170          unsigned int  LeftLiter;
 171          unsigned int left_FlowCnt, UseSec, UseHour;
 172          
 173          unsigned char tmp1;
 174          unsigned char C_F_Type;
 175          unsigned char ADH;
 176          unsigned char ADL;
 177          unsigned char Soft_Timer_Enable = 0;
 178          unsigned char Key_backup, ReceiveDate;
 179          unsigned char WashLiter, r_step, r_step_max, r_step_cnt;
C51 COMPILER V9.02   MAIN                                                                  01/12/2014 08:41:24 PAGE 4   

 180          
 181          bit f_half_sec, f_key_hold, f_water_out, f_alarm_no_water,f_Power_on,f_reflash;
 182          bit ReceiveFlag=0,f_acid3=0, f_clean=0, f_lock, f_show_orp=0;
 183          
 184          
 185          const unsigned char code TC_tab_offset[10] = {10, 15, 20, 30, 40, 60, 80};
 186          const unsigned char code TC_tab_slope[10] = {4, 3, 2, 1, 17, 6, 7, 5};
 187          const unsigned char code TC_tab_type[8] = {0x02, 0x0B, 0x2D, 0x36, 0x00};
 188          
 189          const unsigned char code RTD_tab_offset[10] = {10, 15, 20, 30, 40, 60, 80};
 190          const unsigned char code RTD_tab_slop[10] = {4, 3, 2, 1, 17, 6, 7, 5};
 191          
 192          const int code tab_k[22] = {
 193               4, 800, 1150, 1500, 1800, 2150, 2500, 2800,
 194                  1500, 1850, 2200, 2500, 2850, 3200, 3500,
 195                  2000, 2350, 2700, 3000, 3350, 3700, 4000
 196          };
 197          const int code tab_j[22] = {
 198               0, 800, 1150, 1500, 1800, 2150, 2500, 2800,
 199                  1500, 1850, 2200, 2500, 2850, 3200, 3500,
 200                  2000, 2350, 2700, 3000, 3350, 3700, 4000
 201          };
 202          const int code tab_t[22] = {
 203               0, 800, 1150, 1500, 1800, 2150, 2500, 2800,
 204                  1500, 1850, 2200, 2500, 2850, 3200, 3500,
 205                  2000, 2350, 2700, 3000, 3350, 3700, 4000
 206          };
 207          const int code tab_e[22] = {
 208               0, 800, 1150, 1500, 1800, 2150, 2500, 2800,
 209                  1500, 1850, 2200, 2500, 2850, 3200, 3500,
 210                  2000, 2350, 2700, 3000, 3350, 3700, 4000
 211          };
 212          const int code tab_r[22] = {
 213               0, 800, 1150, 1500, 1800, 2150, 2500, 2800,
 214                  1500, 1850, 2200, 2500, 2850, 3200, 3500,
 215                  2000, 2350, 2700, 3000, 3350, 3700, 4000
 216          };
 217          const int code tab_s[22] = {
 218               0, 800, 1150, 1500, 1800, 2150, 2500, 2800,
 219                  1500, 1850, 2200, 2500, 2850, 3200, 3500,
 220                  2000, 2350, 2700, 3000, 3350, 3700, 4000
 221          };
 222          const int code tab_b[22] = {
 223               0, 800, 1150, 1500, 1800, 2150, 2500, 2800,
 224                  1500, 1850, 2200, 2500, 2850, 3200, 3500,
 225                  2000, 2350, 2700, 3000, 3350, 3700, 4000
 226          };
 227          const int code tab_n[22] = {
 228               0, 800, 1150, 1500, 1800, 2150, 2500, 2800,
 229                  1500, 1850, 2200, 2500, 2850, 3200, 3500,
 230                  2000, 2350, 2700, 3000, 3350, 3700, 4000
 231          };
 232          const int code tab_rtd[22] = {
 233               0, 800, 1150, 1500, 1800, 2150, 2500, 2800,
 234                  1500, 1850, 2200, 2500, 2850, 3200, 3500,
 235                  2000, 2350, 2700, 3000, 3350, 3700, 4000
 236          };
 237          /***************************************
 238                     Port In/Out Setting
 239          *****************************************/
 240          void PORT_Init(void)
 241          {
C51 COMPILER V9.02   MAIN                                                                  01/12/2014 08:41:24 PAGE 5   

 242   1              P0M0 = 0xFF;      //00=Qb,01=pull output, 10= input only,11=open drain
 243   1              P0M1 = 0x00;     //P0= ALL INPUT
 244   1      
 245   1              P1M0 = 0x00;     //P1= ALL OUTPUT
 246   1              P1M1 = 0xFF;     //SETUP P1 ALL LO //  define P1.3 P1.4 P1.5 as push-pull
 247   1              P2M0 = 0x00;     //P2= ALL OUTOUT
 248   1              P2M1 = 0xFF;     //SETUP P2 ALL LO
 249   1          P3M0 = 0xFF;         //
 250   1              P3M1 = 0xff;
 251   1              P0 = 0xff;
 252   1              P1 = 0x00;
 253   1              P2 = 0x00; 
 254   1              P3 = 0x00;
 255   1      }
 256          /*******************************************
 257               interrupt   0
 258          *******************************************/
 259          void ex_int0(void) interrupt 0
 260          {
 261   1      ;       
 262   1      }
 263          /*******************************************
 264               interrupt   1
 265          *******************************************/
 266          void time0(void) interrupt  1     //   T=1/16 sec 
 267          {
 268   1       unsigned int Value_code;
 269   1              TR0 = 0;
 270   1              T1_cnt++;
 271   1              if ((T1_cnt%8)==0)
 272   1              SBUF = Value_code;
 273   1              TH0 = 0x0B;
 274   1              TL0 = 0xDC;
 275   1              TR0 = 1;
 276   1      }
 277          
 278          /*******************************************
 279               interrupt   3
 280          *******************************************/
 281          void time1(void) interrupt   3   //    T=1/16 sec 
 282          {
 283   1              TR1 = 0;
 284   1              T0_cnt++;
 285   1      
 286   1              if (Soft_Timer[DISPLAY_SEND_TIME] != 0)         Soft_Timer[DISPLAY_SEND_TIME]--;
 287   1      
 288   1              if ((T0_cnt%8)==0)                f_half_sec = 1;
 289   1                              
 290   1              if (T0_cnt == 16)
 291   1              {
 292   2                      T0_cnt = 0;
 293   2                      if (Soft_Timer[DATA_SAVE_TIME] != 0)    Soft_Timer[DATA_SAVE_TIME]--;   
 294   2                      if (Soft_Timer[DATA_SEND_TIME] != 0)    Soft_Timer[DATA_SEND_TIME]--;
 295   2                      if (Soft_Timer[SETUP_TIMEOUT] != 0)       Soft_Timer[SETUP_TIMEOUT]--;  
 296   2                      if (Soft_Timer[TIMEUP_TIME] != 0)               Soft_Timer[TIMEUP_TIME]--;
 297   2              }               
 298   1              TH1 = 0x0B;
 299   1              TL1 = 0xDC;
 300   1              TR1 = 1;
 301   1                      
 302   1      }
 303          //      DISPLAY_SEND_TIME  0       //timer out work select
C51 COMPILER V9.02   MAIN                                                                  01/12/2014 08:41:24 PAGE 6   

 304          //      DATA_SAVE_TIME     1
 305          //      DATA_SEND_TIME     2
 306          //      SETUP_TIMEOUT      3
 307          //      OTHER_SEND_TIME    4
 308          /*******************************************
 309              
 310          *******************************************/
 311          void T0_Init(void)
 312          {
 313   1              TR0 = 0;
 314   1              TMOD = 0x11;
 315   1              TH0 = 0x0B;
 316   1              TL0 = 0xDC;
 317   1              T0_cnt = 0;
 318   1              ET0 = 1;
 319   1              TR0 = 1;
 320   1      }
 321          /*******************************************
 322              
 323          *******************************************/
 324          void T1_Init(void)
 325          {
 326   1              TR1 = 0;
 327   1              TMOD = 0x11;
 328   1              TH1 = 0x0B;
 329   1              TL1 = 0xDC;
 330   1              T1_cnt = 0;
 331   1      //      AD111_Init();
 332   1              ET1 = 1;
 333   1              TR1 = 1;
 334   1      }
 335          /*******************************************
 336              
 337          *******************************************/
 338          void INT0_Init(void)
 339          {
 340   1          INT0 = 1;    
 341   1              IE0  = 0;                  
 342   1              IT0  = 1;
 343   1              EX0  = 1;         
 344   1      }
 345          /*******************************************/
 346          void InitUart()    //InitUart use timer2
 347          {
 348   1         SCON |= 0x50;                          /* uart in mode 1 (8 bit), REN=1 */
 349   1         T2CON &= 0xF0;               /* EXEN2=0; TR2=0; C/T2#=0; CP/RL2#=0; */
 350   1         T2CON |= 0x30;               /* RCLK = 1; TCLK=1; */
 351   1         TH2=0xFF;                    /* init value */
 352   1         TL2=0xD0;                    /* init value */
 353   1         RCAP2H=0xFF;                 /* reload value, 9600 Bds at 11.059MHz */
 354   1         RCAP2L=0xDC;                 /* reload value, 9600 Bds at 11.059MHz */
 355   1         ES = 1;                                                   /* Enable serial interrupt */
 356   1         TR2 = 1;                     /* Timer 2 run */
 357   1      }
 358          /******************************************
 359          void InitUart()              //InitUart use timer2
 360          {
 361             SCON |= 0x50;                            // uart in mode 1 (8 bit), REN=1 
 362             T2CON &= 0xF0;               // EXEN2=0; TR2=0; C/T2#=0; CP/RL2#=0; 
 363             T2CON |= 0x30;               // RCLK = 1; TCLK=1; 
 364             TH2=0xFF;                    // init value 
 365             TL2=0xDC;                    // init value 
C51 COMPILER V9.02   MAIN                                                                  01/12/2014 08:41:24 PAGE 7   

 366             RCAP2H=0xFF;                 // reload value, 9600 Bds at 11.059MHz 
 367             RCAP2L=0xDC;                 // reload value, 9600 Bds at 11.059MHz 
 368             ES = 1;                                              // Enable serial interrupt 
 369             TR2 = 1;                     // Timer 2 run 
 370          }
 371          /*************************************************/
 372          void serial() interrupt 4
 373          {
 374   1              if(TI==1)
 375   1              {
 376   2                 TI=0;
 377   2              }
 378   1              if(RI==1)
 379   1              {
 380   2                 RI=0;
 381   2                 ReceiveDate = SBUF;
 382   2                 ReceiveFlag = 1;
 383   2              }
 384   1      }
 385          /*******************************************/
 386          void sendchar(unsigned char SendData)
 387          {
 388   1         SBUF = SendData;
 389   1      }
 390          /******************************************
 391             Delay Time  250uS*i
 392          *******************************************/
 393          void delay(unsigned int i)
 394          {
 395   1              unsigned char j;
 396   1              for (; i>0; i--)
 397   1                      for (j=0; j<255; j++);
 398   1      }
 399          /*******************************************
 400              
 401          *******************************************/
 402          void Buzzer(unsigned char status)
 403          {
 404   1              if (status)
 405   1            P2 =      P2 |= 0x20;
 406   1              else
 407   1                P2 = P2 &= ~0x20;
 408   1      }
 409          //==============================================
 410          void EEPROM_write_word(unsigned char addr, unsigned int intdata)
 411          {
 412   1              EEPROM_write_byte(addr++, (unsigned char)(intdata));
 413   1              EEPROM_write_byte(addr, (unsigned char)(intdata>>8));
 414   1      }
 415          //======================================
 416          unsigned int EEPROM_read_word(unsigned char addr)
 417          {
 418   1              unsigned int rdata;
 419   1      
 420   1              rdata = (unsigned int)(EEPROM_read_byte(addr+1));
 421   1              rdata <<= 8;
 422   1              rdata += (unsigned int)(EEPROM_read_byte(addr));
 423   1      
 424   1              return(rdata);  
 425   1      }
 426          //===========================================
 427          void EEPROM_WriteDefault(void)
C51 COMPILER V9.02   MAIN                                                                  01/12/2014 08:41:24 PAGE 8   

 428          {
 429   1         unsigned char switch_status;
 430   1          
 431   1               switch_status = P2 & 0x1f;
 432   1      
 433   1          EEPROM_write_byte(Mode_Select,5);
 434   1          EEPROM_write_byte(C_F_Select, 0);
 435   1              EEPROM_write_byte(Type_Select,0);  //Type define k=0.j=1,t=2
 436   1              EEPROM_write_word(TC_Zero, 0);  
 437   1              EEPROM_write_word(TC_Span, 0);
 438   1              EEPROM_write_word(RTD_Zero, 0);
 439   1              EEPROM_write_word(RTD_Span, 0);
 440   1              EEPROM_write_word(mV_Zero, 0);
 441   1              EEPROM_write_word(mV_Span, 0);
 442   1              EEPROM_write_word(mA_Zero, 0);  
 443   1          EEPROM_write_word(mA_Span, 0);
 444   1              EEPROM_write_word(Alarm_Low, 0);
 445   1              EEPROM_write_word(Alarm_Hi, 5000);
 446   1          EEPROM_write_byte(Year_Date, 2014);
 447   1          EEPROM_write_byte(Mon_Date, 1);
 448   1          EEPROM_write_byte(Day_Date, 1);
 449   1              EEPROM_write_byte(Week_Date, 3);
 450   1          EEPROM_write_byte(Hour_Date, 12);
 451   1          EEPROM_write_byte(Min_Date, 0);
 452   1              EEPROM_write_word(EEP_ADR, 50);
 453   1      }
 454          //==============================
 455          unsigned char Setup_time_is_up(void)
 456          {
 457   1              unsigned int i, reti;
 458   1      
 459   1              reti = 0;
 460   1              i = UseHour/24;
 461   1              return(reti);    
 462   1      }
 463          //======================================
 464          void Init_Volt_Detect(void)
 465          {
 466   1              r_step = 0;
 467   1              r_step_max = 0;
 468   1              r_step_cnt = 0;
 469   1              delay(1000);
 470   1      }
 471          //==================================
 472          unsigned char CurrentSeg(unsigned int i)
 473          {
 474   1              unsigned char retc;
 475   1      
 476   1              if (i < 12)
 477   1                      retc = 0;
 478   1              else if (i < 15)
 479   1                      retc = 1;
 480   1              else if (i < 18)
 481   1                      retc = 2;
 482   1              else if (i < 22)
 483   1                      retc = 3;
 484   1              else if (i < 25)
 485   1                      retc = 4;
 486   1              else if (i < 28)
 487   1                      retc = 5;
 488   1              else
 489   1                      retc = 6;
C51 COMPILER V9.02   MAIN                                                                  01/12/2014 08:41:24 PAGE 9   

 490   1      
 491   1              return retc;
 492   1      }
 493          /************************************************/
 494          void do_reset(void)
 495          {
 496   1      }
 497          /************************************************/
 498          void Volt_Ctrl(void)
 499          {
 500   1      }
 501          /***********************************************/
 502          unsigned char Get_Key(void)
 503          {
 504   1          unsigned char key = 0;
 505   1              unsigned char key_bak ;                                 // key1為了記錄按鍵是否被釋放過
 506   1      
 507   1        if(FUNCTION_KEY == 0)
 508   1          {
 509   2               if(key_bak == 0)
 510   2                 {
 511   3                   key = (key |0x01);
 512   3                   key_bak = (key |0x01); 
 513   3                 }
 514   2                else
 515   2                 {
 516   3                      key = (key & 0xfe) ;
 517   3                 }
 518   2               }
 519   1         if(OFFSET_KEY == 0)
 520   1          {
 521   2               if(key_bak == 0)
 522   2                 {
 523   3                   key = (key |0x02);
 524   3                   key_bak = (key |0x02); 
 525   3                 }
 526   2                else
 527   2                 {
 528   3                      key = (key & 0xfd) ;
 529   3                 }
 530   2               }
 531   1         if(UP_KEY == 0)
 532   1          {
 533   2               if(key_bak == 0)
 534   2                 {
 535   3                   key = (key |0x04);
 536   3                   key_bak = (key |0x04); 
 537   3                 }
 538   2                else
 539   2                 {
 540   3                      key = (key & 0xfb) ;
 541   3                 }
 542   2               }
 543   1         if(DOWN_KEY == 0)
 544   1          {
 545   2               if(key_bak == 0)
 546   2                 {
 547   3                   key = (key |0x08);
 548   3                   key_bak = (key |0x08); 
 549   3                 }
 550   2                else
 551   2                 {
C51 COMPILER V9.02   MAIN                                                                  01/12/2014 08:41:24 PAGE 10  

 552   3                      key = (key & 0xf7) ;
 553   3                 }
 554   2               }
 555   1      
 556   1         return key;
 557   1      }
 558          /************************************************/
 559          void do_electrolyze(void)
 560          {
 561   1              unsigned char key=0;                                    // key1為了記錄按鍵是否被釋放過
 562   1              unsigned char rr=0, rr1=0;
 563   1              unsigned char Time_of_NoWater=0;
 564   1              unsigned char NoWaterVoice_Counter=0;
 565   1              unsigned char seg0=0,off_cut=0;
 566   1              bit rr2=0;
 567   1      }
 568          /************************************************/
 569          unsigned int DO_TC_TYPE(void)
 570          {
 571   1           unsigned int Code_Value,TC_Value;
 572   1               unsigned char key;
 573   1      
 574   1            key = Get_Key();
 575   1               
 576   1                if(key == 0x01)
 577   1                {
 578   2                   Work_Type = 5;
 579   2                }
 580   1         else
 581   1           {
 582   2              Code_Value = Get_AD3421_Value();
 583   2      
 584   2             if (TC_Type == K_TYPE)
 585   2               {
 586   3                      Code_Value  = Code_Value*(Code_Value/(TC_Span_offset- TC_Zero_offset)); 
 587   3                      TC_Value = Get_K_Slope(Code_Value);
 588   3                    }
 589   2              else if (TC_Type == J_TYPE)
 590   2                {
 591   3                       Code_Value  = Code_Value*(Code_Value/(TC_Span_offset- TC_Zero_offset));
 592   3                       TC_Value = Get_J_Slope(Code_Value); 
 593   3                    }
 594   2              else if (TC_Type == T_TYPE)
 595   2                {
 596   3                       Code_Value  = Code_Value*(Code_Value/(TC_Span_offset- TC_Zero_offset));
 597   3                       TC_Value = Get_T_Slope(Code_Value); 
 598   3                    }
 599   2              else if (TC_Type == E_TYPE)
 600   2                {
 601   3                       Code_Value  = Code_Value*(Code_Value/(TC_Span_offset- TC_Zero_offset));
 602   3                       TC_Value = Get_E_Slope(Code_Value); 
 603   3                    }
 604   2              else if (TC_Type == R_TYPE)
 605   2                {
 606   3                       Code_Value  = Code_Value*(Code_Value/(TC_Span_offset- TC_Zero_offset));
 607   3                       TC_Value = Get_R_Slope(Code_Value); 
 608   3                    }
 609   2              else if (TC_Type == S_TYPE)
 610   2                {
 611   3                       Code_Value  = Code_Value*(Code_Value/(TC_Span_offset- TC_Zero_offset));
 612   3                       TC_Value = Get_S_Slope(Code_Value); 
 613   3                    }
C51 COMPILER V9.02   MAIN                                                                  01/12/2014 08:41:24 PAGE 11  

 614   2              else if (TC_Type == B_TYPE)
 615   2                {
 616   3                       Code_Value  = Code_Value*(Code_Value/(TC_Span_offset- TC_Zero_offset));
 617   3                       TC_Value = Get_B_Slope(Code_Value); 
 618   3                    }
 619   2              else if (TC_Type == N_TYPE)
 620   2                {
 621   3                       Code_Value  = Code_Value*(Code_Value/(TC_Span_offset- TC_Zero_offset));
 622   3                       TC_Value = Get_N_Slope(Code_Value); 
 623   3                    }
 624   2            }
 625   1      
 626   1          return TC_Value;
 627   1      }
 628          /************************************************/
 629          unsigned int Get_K_Slope(unsigned int Code_Value)
 630          {
 631   1         unsigned int out_Value;
 632   1      
 633   1      
 634   1               if((Code_Value > 1000) && (Code_Value < 2000))
 635   1                 {
 636   2                 }
 637   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 638   1                 {
 639   2                 }    
 640   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 641   1                 {
 642   2                 }
 643   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 644   1                 {
 645   2                 }
 646   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 647   1                 {
 648   2                 }
 649   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 650   1                 {
 651   2                 }
 652   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 653   1                 {
 654   2                 }
 655   1      
 656   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 657   1                 {
 658   2                 }
 659   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 660   1                 {
 661   2                 }
 662   1      
 663   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 664   1                 {
 665   2                 }
 666   1      
 667   1         return out_Value;
 668   1      
 669   1      }
 670          /************************************************/
 671          unsigned int Get_J_Slope(unsigned int Code_Value)
 672          {
 673   1         unsigned int out_Value;
 674   1      
 675   1      
C51 COMPILER V9.02   MAIN                                                                  01/12/2014 08:41:24 PAGE 12  

 676   1               if((Code_Value > 1000) && (Code_Value < 2000))
 677   1                 {
 678   2                 }
 679   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 680   1                 {
 681   2                 }    
 682   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 683   1                 {
 684   2                 }
 685   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 686   1                 {
 687   2                 }
 688   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 689   1                 {
 690   2                 }
 691   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 692   1                 {
 693   2                 }
 694   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 695   1                 {
 696   2                 }
 697   1      
 698   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 699   1                 {
 700   2                 }
 701   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 702   1                 {
 703   2                 }
 704   1      
 705   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 706   1                 {
 707   2                 }
 708   1      
 709   1         return out_Value;
 710   1      
 711   1      }
 712          /************************************************/
 713          unsigned int Get_T_Slope(unsigned int Code_Value)
 714          {
 715   1         unsigned int out_Value;
 716   1      
 717   1      
 718   1               if((Code_Value > 1000) && (Code_Value < 2000))
 719   1                 {
 720   2                 }
 721   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 722   1                 {
 723   2                 }    
 724   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 725   1                 {
 726   2                 }
 727   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 728   1                 {
 729   2                 }
 730   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 731   1                 {
 732   2                 }
 733   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 734   1                 {
 735   2                 }
 736   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 737   1                 {
C51 COMPILER V9.02   MAIN                                                                  01/12/2014 08:41:24 PAGE 13  

 738   2                 }
 739   1      
 740   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 741   1                 {
 742   2                 }
 743   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 744   1                 {
 745   2                 }
 746   1      
 747   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 748   1                 {
 749   2                 }
 750   1      
 751   1         return out_Value;
 752   1      
 753   1      }
 754          /************************************************/
 755          unsigned int Get_E_Slope(unsigned int Code_Value)
 756          {
 757   1         unsigned int out_Value;
 758   1      
 759   1      
 760   1               if((Code_Value > 1000) && (Code_Value < 2000))
 761   1                 {
 762   2                 }
 763   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 764   1                 {
 765   2                 }    
 766   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 767   1                 {
 768   2                 }
 769   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 770   1                 {
 771   2                 }
 772   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 773   1                 {
 774   2                 }
 775   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 776   1                 {
 777   2                 }
 778   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 779   1                 {
 780   2                 }
 781   1      
 782   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 783   1                 {
 784   2                 }
 785   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 786   1                 {
 787   2                 }
 788   1      
 789   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 790   1                 {
 791   2                 }
 792   1      
 793   1         return out_Value;
 794   1      
 795   1      }
 796          /************************************************/
 797          unsigned int Get_R_Slope(unsigned int Code_Value)
 798          {
 799   1         unsigned int out_Value;
C51 COMPILER V9.02   MAIN                                                                  01/12/2014 08:41:24 PAGE 14  

 800   1      
 801   1      
 802   1               if((Code_Value > 1000) && (Code_Value < 2000))
 803   1                 {
 804   2                 }
 805   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 806   1                 {
 807   2                 }    
 808   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 809   1                 {
 810   2                 }
 811   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 812   1                 {
 813   2                 }
 814   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 815   1                 {
 816   2                 }
 817   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 818   1                 {
 819   2                 }
 820   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 821   1                 {
 822   2                 }
 823   1      
 824   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 825   1                 {
 826   2                 }
 827   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 828   1                 {
 829   2                 }
 830   1      
 831   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 832   1                 {
 833   2                 }
 834   1      
 835   1         return out_Value;
 836   1      
 837   1      }
 838          /************************************************/
 839          unsigned int Get_S_Slope(unsigned int Code_Value)
 840          {
 841   1         unsigned int out_Value;
 842   1      
 843   1      
 844   1               if((Code_Value > 1000) && (Code_Value < 2000))
 845   1                 {
 846   2                 }
 847   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 848   1                 {
 849   2                 }    
 850   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 851   1                 {
 852   2                 }
 853   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 854   1                 {
 855   2                 }
 856   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 857   1                 {
 858   2                 }
 859   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 860   1                 {
 861   2                 }
C51 COMPILER V9.02   MAIN                                                                  01/12/2014 08:41:24 PAGE 15  

 862   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 863   1                 {
 864   2                 }
 865   1      
 866   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 867   1                 {
 868   2                 }
 869   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 870   1                 {
 871   2                 }
 872   1      
 873   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 874   1                 {
 875   2                 }
 876   1      
 877   1         return out_Value;
 878   1      
 879   1      }
 880          /************************************************/
 881          unsigned int Get_B_Slope(unsigned int Code_Value)
 882          {
 883   1         unsigned int out_Value;
 884   1      
 885   1      
 886   1               if((Code_Value > 1000) && (Code_Value < 2000))
 887   1                 {
 888   2                 }
 889   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 890   1                 {
 891   2                 }    
 892   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 893   1                 {
 894   2                 }
 895   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 896   1                 {
 897   2                 }
 898   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 899   1                 {
 900   2                 }
 901   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 902   1                 {
 903   2                 }
 904   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 905   1                 {
 906   2                 }
 907   1      
 908   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 909   1                 {
 910   2                 }
 911   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 912   1                 {
 913   2                 }
 914   1      
 915   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 916   1                 {
 917   2                 }
 918   1      
 919   1         return out_Value;
 920   1      
 921   1      }
 922          /************************************************/
 923          unsigned int Get_N_Slope(unsigned int Code_Value)
C51 COMPILER V9.02   MAIN                                                                  01/12/2014 08:41:24 PAGE 16  

 924          {
 925   1         unsigned int out_Value;
 926   1      
 927   1      
 928   1               if((Code_Value > 1000) && (Code_Value < 2000))
 929   1                 {
 930   2                 }
 931   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 932   1                 {
 933   2                 }    
 934   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 935   1                 {
 936   2                 }
 937   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 938   1                 {
 939   2                 }
 940   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 941   1                 {
 942   2                 }
 943   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 944   1                 {
 945   2                 }
 946   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 947   1                 {
 948   2                 }
 949   1      
 950   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 951   1                 {
 952   2                 }
 953   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 954   1                 {
 955   2                 }
 956   1      
 957   1              else if((Code_Value > 2000) && (Code_Value < 3000))
 958   1                 {
 959   2                 }
 960   1      
 961   1         return out_Value;
 962   1      
 963   1      }
 964          
 965          /************************************************/
 966          unsigned int DO_RTD_TYPE(void)
 967          {
 968   1           unsigned int Code_Value,RTD_Value;
 969   1               unsigned char key;
 970   1      
 971   1            key = Get_Key();
 972   1               
 973   1                if(key == 0x01)
 974   1                {
 975   2                   Work_Type = 5;
 976   2                }
 977   1              else
 978   1               {
 979   2             Code_Value = Get_AD3421_Value();
 980   2                 Code_Value  = Code_Value*(Code_Value/(TC_Span_offset- TC_Zero_offset)); 
 981   2                 RTD_Value = Code_Value*(Code_Value/(RTD_Span_offset- RTD_Zero_offset)); 
 982   2      
 983   2      
 984   2               if((RTD_Value > 1000) && (RTD_Value < 2000))
 985   2                 {
C51 COMPILER V9.02   MAIN                                                                  01/12/2014 08:41:24 PAGE 17  

 986   3                 }
 987   2              else if((RTD_Value > 2000) && (RTD_Value < 3000))
 988   2                 {
 989   3                 }    
 990   2              else if((RTD_Value > 2000) && (RTD_Value < 3000))
 991   2                 {
 992   3                 }
 993   2              else if((RTD_Value > 2000) && (RTD_Value < 3000))
 994   2                 {
 995   3                 }
 996   2              else if((RTD_Value > 2000) && (RTD_Value < 3000))
 997   2                 {
 998   3                 }
 999   2              else if((RTD_Value > 2000) && (RTD_Value < 3000))
1000   2                 {
1001   3                 }
1002   2              else if((RTD_Value > 2000) && (RTD_Value < 3000))
1003   2                 {
1004   3                 }
1005   2              }
1006   1         return RTD_Value;
1007   1      }
1008          /************************************************/
1009          unsigned int DO_mV_TYPE(void)
1010          {
1011   1           unsigned int Code_Value,mV_Value;
1012   1               unsigned char key;
1013   1      
1014   1            key = Get_Key();
1015   1               
1016   1                if(key == 0x01)
1017   1                  {
1018   2                    Work_Type = 5;
1019   2                  }
1020   1               else
1021   1                 {
1022   2               Code_Value = Get_AD3421_Value();
1023   2               mV_Value = Code_Value*( Code_Value/(mV_Span_offset - mV_Zero_offset));
1024   2                 }
1025   1               return mV_Value ;
1026   1      }
1027          /************************************************/
1028          unsigned int DO_mA_TYPE(void)
1029          {
1030   1           unsigned int Code_Value,mA_Value;
1031   1               unsigned char key;
1032   1      
1033   1            key = Get_Key();
1034   1               
1035   1                if(key == 0x01)
1036   1                  {
1037   2                    Work_Type = 5;
1038   2                  }
1039   1               else
1040   1                 {
1041   2               Code_Value = Get_AD3421_Value();
1042   2               mA_Value = Code_Value*(Code_Value/(mA_Span_offset - mA_Zero_offset));
1043   2                 }
1044   1               return mA_Value;
1045   1      }
1046          /************************************************/
1047          void RTC_WRITE_SET()
C51 COMPILER V9.02   MAIN                                                                  01/12/2014 08:41:24 PAGE 18  

1048          {
1049   1      RTC_write_byte(0,0x02);
1050   1      RTC_write_byte(3,use_min);
1051   1      RTC_write_byte(4,use_hour);
1052   1      RTC_write_byte(5,use_week);
1053   1      RTC_write_byte(6,use_day);
1054   1      RTC_write_byte(7,use_mon);
1055   1      RTC_write_byte(8,use_year);
1056   1      RTC_write_byte(0,0);
1057   1      }
1058          
1059          /************************************************/
1060          void RTC_READ_SET()
1061          {
1062   1       RTC_write_byte(0,0x01);
1063   1       use_min = RTC_read_byte(3);
1064   1       use_hour = RTC_read_byte(4);
1065   1       use_week = RTC_read_byte(5);
1066   1       use_day = RTC_read_byte(6);
1067   1       use_mon = RTC_read_byte(7);
1068   1       use_mon = RTC_read_byte(8);
1069   1       RTC_write_byte(0,0);
1070   1      }
1071          
1072          /*************************************************/     
1073          void DO_SETUP_TYPE(void)
1074          {
1075   1              unsigned int  zero_cal = 0;
1076   1              unsigned int  span_cal = 0;
1077   1              unsigned char cExit;
1078   1              unsigned char set_key = 0,  times = 0;
1079   1              unsigned char confrom_key,up_key,don_key,item_key;
1080   1      
1081   1              
1082   1              while (ITEM < PRODUCT_RESET)
1083   1                       {
1084   2                             if (ITEM == NOMAL_FUNCTION)
1085   2                               {
1086   3                                     SETUP_LED_Disp(0,0);
1087   3                                     tmp1 = EEPROM_read_byte(C_F_Select);  //sbit FUNCTION_SELECT   = P3^2;sbit OFFSET_SELECT     = P
             -3^3;
1088   3                                     SETUP_LED_Disp(0,tmp1);
1089   3                                     cExit = 0;
1090   3      
1091   3                                     while (! cExit)
1092   3                                          {
1093   4                                                set_key = Get_Key();
1094   4      
1095   4                                                        if((set_key & 0x01) == 1) item_key = 1 ; else item_key = 0 ;
1096   4                                                        if((set_key & 0x02) == 1) confrom_key = 1 ; else confrom_key = 0 ;
1097   4                                                        if((set_key & 0x04) == 1) up_key = 1 ;  else up_key = 0 ;
1098   4                                            if((set_key & 0x08) == 1) don_key = 1 ; else don_key = 0 ;
1099   4                                      }
1100   3      
1101   3                                        if (ITEM == TYPE_CAL)
1102   3                                           {  }
1103   3                                    if (ITEM == C_F_CAL)
1104   3                                           {  }
1105   3                                    if (ITEM == TC_ZERO_CAL)
1106   3                                           {   }
1107   3                                    if (ITEM == TC_SPAN_CAL)
1108   3                                           {          }
C51 COMPILER V9.02   MAIN                                                                  01/12/2014 08:41:24 PAGE 19  

1109   3                                    if (ITEM == RTD_ZERO_CAL)
1110   3                                           {   }
1111   3                                        if (ITEM == RTD_SPAN_CAL)
1112   3                                           {   }
1113   3                                        if (ITEM == mV_ZERO_CAL)
1114   3                                           {   }
1115   3                                        if (ITEM == mV_SPAN_CAL)
1116   3                                           {   }
1117   3                                        if (ITEM == mA_ZERO_CAL)
1118   3                                           {   }
1119   3                                        if (ITEM == mA_SPAN_CAL)
1120   3                                           {   }
1121   3                                        if (ITEM == ALARM_LO_CAL)
1122   3                                           {   }
1123   3                                        if (ITEM == ALARM_HI_CAL)
1124   3                                           {   }
1125   3                                        if (ITEM == YEAR_DATE_CAL)
1126   3                                           {   }
1127   3                                        if (ITEM == MON_DATE_CAL)
1128   3                                           {   }
1129   3                                        if (ITEM == DAY_DATE_CAL)                     //add week setup
1130   3                                           {   }
1131   3                                        if (ITEM == HOUR_DATE_CAL)
1132   3                                           {   }
1133   3                                    if (ITEM == MIN_DATE_CAL)
1134   3                                           {   }
1135   3                                              }
1136   2                               }
1137   1      
1138   1                      if( MAIN_SW == OFF)
1139   1                    {
1140   2                       Work_Type = EEPROM_read_byte(Mode_Select); 
1141   2                    }
1142   1      }
1143          //*******************************
1144          void DO_RESET_TYPE(void)
1145          {
1146   1              
1147   1           EEPROM_WriteDefault();
1148   1           LED_Fill();                                     //  LED all light
1149   1               Work_Type = EEPROM_read_byte(Mode_Select);
1150   1               C_F_Type = EEPROM_read_byte(C_F_Select);
1151   1               TC_Type = EEPROM_read_byte(Type_Select);       //Type define k=0.j=1,t=2
1152   1               TC_Zero_offset = EEPROM_read_word(TC_Zero);    
1153   1               TC_Span_offset = EEPROM_read_word(TC_Span);
1154   1               RTD_Zero_offset = EEPROM_read_word(RTD_Zero);
1155   1               RTD_Span_offset = EEPROM_read_word(RTD_Span);
1156   1               mA_Zero_offset = EEPROM_read_word(mA_Zero);
1157   1               mA_Span_offset = EEPROM_read_word(mA_Span);
1158   1               mV_Zero_offset = EEPROM_read_word(mV_Zero);    
1159   1           mV_Span_offset = EEPROM_read_word(mV_Span);
1160   1               alarm_Low_set = EEPROM_read_word(Alarm_Low);
1161   1               alarm_Hi_set = EEPROM_read_word(Alarm_Hi);
1162   1           use_year = EEPROM_read_word(Year_Date);
1163   1           use_mon = EEPROM_read_word(Mon_Date);
1164   1           use_day = EEPROM_read_word(Day_Date);
1165   1               use_week = EEPROM_read_word(Week_Date);
1166   1           use_hour = EEPROM_read_word(Hour_Date);
1167   1           use_min = EEPROM_read_word(Min_Date);
1168   1               eep_count = EEPROM_read_word(EEP_ADR);
1169   1      }
1170          /***********************************
C51 COMPILER V9.02   MAIN                                                                  01/12/2014 08:41:24 PAGE 20  

1171          ****      System_Start          ****
1172          ***********************************/ 
1173          main(void)
1174          {
1175   1              PORT_Init();
1176   1              EEPROM_Init();
1177   1              LED_Init();
1178   1          LED_Fill();
1179   1              T0_Init();
1180   1              T1_Init();
1181   1              INT0_Init();
1182   1              AD3421_Init();
1183   1              InitUart();
1184   1          Set_mA(0);
1185   1              Set_mV(0);
1186   1              Buzzer(OFF);
1187   1              Soft_Timer_Enable = 0;
1188   1              EX0 = 0;
1189   1      
1190   1              if ((EEPROM_read_byte(0) != 'N')||(EEPROM_read_byte(1) != 'E')||(EEPROM_read_byte(2) != 'W')||(EEPROM_re
             -ad_byte(3) != JOHNSON)||(EEPROM_read_byte(4) != LIN))
1191   1                {
1192   2                      EEPROM_write_byte(0, 'N');      
1193   2                      EEPROM_write_byte(1, 'E');
1194   2                      EEPROM_write_byte(2, 'W');
1195   2                      EEPROM_write_byte(3, JOHNSON);  
1196   2                      EEPROM_write_byte(4, LIN);      
1197   2                      EEPROM_WriteDefault();
1198   2      
1199   2            }
1200   1      
1201   1            LED_Fill();                                     //  LED all light
1202   1      
1203   1               Work_Type = EEPROM_read_byte(Mode_Select);     
1204   1               C_F_Type = EEPROM_read_byte(C_F_Select);
1205   1               TC_Type  = EEPROM_read_byte(Type_Select);       //Type define k=0.j=1,t=2
1206   1               TC_Zero_offset = EEPROM_read_word(TC_Zero);    
1207   1               TC_Span_offset = EEPROM_read_word(TC_Span);
1208   1               RTD_Zero_offset = EEPROM_read_word(RTD_Zero);
1209   1               RTD_Span_offset = EEPROM_read_word(RTD_Span);
1210   1               mA_Zero_offset = EEPROM_read_word(mV_Zero);
1211   1               mA_Span_offset = EEPROM_read_word(mV_Span);
1212   1               mV_Zero_offset = EEPROM_read_word(mA_Zero);    
1213   1           mV_Span_offset = EEPROM_read_word(mA_Span);
1214   1               alarm_Low_set = EEPROM_read_word(Alarm_Low);
1215   1               alarm_Hi_set = EEPROM_read_word(Alarm_Hi);
1216   1           use_year = EEPROM_read_byte(Year_Date);
1217   1           use_mon = EEPROM_read_byte(Mon_Date);
1218   1           use_day = EEPROM_read_byte(Day_Date);
1219   1           use_hour = EEPROM_read_byte(Hour_Date);
1220   1           use_min = EEPROM_read_byte(Min_Date);
1221   1               eep_count =EEPROM_read_word(EEP_ADR);
1222   1               Disp_year = use_year+1911;
1223   1               EA = 1;
1224   1               MAIN_SW = 1 ;
1225   1               RTC_WRITE_SET();
1226   1       // if ((C_F_Type & 0x01) != 1)                      // 0 = C , 1 = F
1227   1      //        {     
1228   1      //              TempValue  = ((TempValue - 320)*5/9) ;                                                             
1229   1      //        }
1230   1               Work_Type = 0;  //EEPROM_read_byte(Type_Select);  //Type define k=0.j=1,t=2
1231   1      
C51 COMPILER V9.02   MAIN                                                                  01/12/2014 08:41:24 PAGE 21  

1232   1      //***************************************
1233   1              while (1)
1234   1              {
1235   2                      switch (Work_Type)
1236   2                        {
1237   3                              case TC_FUNCTION:
1238   3                                      DO_TC_TYPE();
1239   3                                      break;
1240   3      
1241   3                              case RTD_FUNCTION:
1242   3                              DO_RTD_TYPE();
1243   3                                      break;
1244   3      
1245   3                              case mV_FUNCTION:
1246   3                                      DO_mV_TYPE();
1247   3                                      break;
1248   3      
1249   3                              case mA_FUNCTION:
1250   3                                  DO_mA_TYPE();
1251   3                                      break;
1252   3                              
1253   3                              case RESET_FUNCTION:      //ok
1254   3                                      DO_RESET_TYPE();
1255   3                                      break;
1256   3      
1257   3                               case SETUP_FUNCTION:
1258   3                                      DO_SETUP_TYPE();         //
1259   3                                      break;
1260   3              
1261   3                   }
1262   2               }
1263   1      /*        
1264   1      #define K_TYPE          0               //2466F   54.807mV      P0=0x00
1265   1      #define J_TYPE          1               //1368F   42.922mV
1266   1      #define T_TYPE          2               //360F    9.286mV
1267   1      #define E_TYPE          3               //1440F   61.022mV
1268   1      #define R_TYPE          4               //2880F   18.842mV
1269   1      #define S_TYPE          5               //2880F   16.771mV
1270   1      #define B_TYPE          6               //3240F   13.585mV
1271   1      #define N_TYPE      7           //?       ?
1272   1      sbit TC_SW1    = P0^0;  //k=0x00;j=0x01;t=0x02;e=0x03; 
1273   1      sbit TC_SW2    = P0^1;  //r=0x04;s=0x05;b=0x06;n=0x07;
1274   1      sbit TC_SW3    = P0^2;
1275   1      
1276   1      sbit TYPE_SW1  = P0^3;   //tc= 000 00xxx;  rtd=000 01xxx;    mV=000 10xxx
1277   1      sbit TYPE_SW2  = P0^4;   //mA= 000 11xxx;
1278   1      sbit TYPE_SW3  = P0^5;
1279   1      */
1280   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2114    ----
   CONSTANT SIZE    =    444    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     53      70
   IDATA SIZE       =     10    ----
   BIT SIZE         =     11       1
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
C51 COMPILER V9.02   MAIN                                                                  01/12/2014 08:41:24 PAGE 22  

   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
