C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 1   


C51 COMPILER V9.02, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c OMF2 BROWSE DEBUG LISTINCLUDE SYMBOLS

line level    source

   1          /***********************************************
   2            PRODUCT FOR NEWCAL MIX_TEMP FUNCTION
   3             CPU : MPC82G516
   4             BEGIN DATE: 2013.11.01
   5             FINISHED  : 2014.01.25
   6             WRITEBY   :JOHNSON LIN
   7             AD111  setup   SET 1001 0000 FOR A0 TYPE 
   8              8CH =  pga =1 ,32767BITS
   9          **************************************************/
  10          #include <MG82FE564.H>
   1      =1  // (System)
   2      =1  sfr ACC       = 0xE0;
   3      =1  sfr B         = 0xF0;
   4      =1  sfr SP        = 0x81;
   5      =1  sfr DPL       = 0x82;
   6      =1  sfr DPH       = 0x83;
   7      =1  sfr PSW       = 0xD0;
   8      =1  
   9      =1  // (Interrupt)
  10      =1  sfr IE        = 0xA8;
  11      =1  sfr EIE1      = 0xAD;
  12      =1  sfr AUXIE     = 0xAD;
  13      =1  sfr XICON     = 0xC0;
  14      =1  sfr IP0L      = 0xB8;
  15      =1  sfr IP        = 0xB8;
  16      =1  sfr IP0H      = 0xB7;
  17      =1  sfr IPH       = 0xB7;
  18      =1  sfr EIP1L     = 0xAE;
  19      =1  sfr AUXIP     = 0xAE;
  20      =1  sfr EIP1H     = 0xAF;
  21      =1  sfr AUXIPH    = 0xAF;
  22      =1  
  23      =1  // (I/O Port)
  24      =1  sfr P0        = 0x80;
  25      =1  sfr P1        = 0x90;
  26      =1  sfr P2        = 0xA0;
  27      =1  sfr P3        = 0xB0;
  28      =1  sfr P4        = 0xE8;
  29      =1  sfr P5        = 0xF8;
  30      =1  sfr P6        = 0xC8;                            // Page F
  31      =1  sfr P0M0      = 0x93;
  32      =1  sfr P0M1      = 0x94;
  33      =1  sfr P1M0      = 0x91;
  34      =1  sfr P1M1      = 0x92;
  35      =1  sfr P2M0      = 0x95;
  36      =1  sfr P2M1      = 0x96;
  37      =1  sfr P3M0      = 0xB1;
  38      =1  sfr P3M1      = 0xB2;
  39      =1  sfr P4M0      = 0xB3;
  40      =1  sfr P4M1      = 0xB4;
  41      =1  sfr P5M0      = 0xB5;
  42      =1  sfr P5M1      = 0xB6;
  43      =1  
  44      =1  // (Timer)
  45      =1  sfr TCON      = 0x88;
C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 2   

  46      =1  sfr TMOD      = 0x89;
  47      =1  sfr T2CON     = 0xC8;
  48      =1  sfr T2MOD     = 0xC9;
  49      =1  sfr RCAP2L    = 0xCA;
  50      =1  sfr RCAP2H    = 0xCB;
  51      =1  sfr TL0       = 0x8A;
  52      =1  sfr TL1       = 0x8B;
  53      =1  sfr TH0       = 0x8C;
  54      =1  sfr TH1       = 0x8D;
  55      =1  sfr TL2       = 0xCC;
  56      =1  sfr TH2       = 0xCD;
  57      =1  
  58      =1  // (Serial Port)
  59      =1  sfr SCON      = 0x98;
  60      =1  sfr SCON0     = 0x98;
  61      =1  sfr SCON1     = 0x98;                            // Page 1
  62      =1  sfr SBUF      = 0x99;
  63      =1  sfr SBUF0     = 0x99;
  64      =1  sfr SBUF1     = 0x99;                            // Page 1
  65      =1  sfr SADDR     = 0xA9;
  66      =1  sfr SADEN     = 0xB9;
  67      =1  sfr SCFG      = 0x9A;
  68      =1  sfr S1BRT     = 0x9A;
  69      =1  sfr S2BUF     = 0x9A;                            // Page 1
  70      =1  
  71      =1  // (ADC)
  72      =1  sfr ADCON     = 0xC5;
  73      =1  sfr ADCTL     = 0xC5;
  74      =1  sfr ADCV      = 0xC6;
  75      =1  sfr ADCH      = 0xC6;
  76      =1  sfr ADCVL     = 0xBE;
  77      =1  sfr ADCL      = 0xBE;
  78      =1  
  79      =1  // (Keypad Interrupt)
  80      =1  sfr KBCON     = 0xD6;
  81      =1  sfr KBPATN    = 0xD5;
  82      =1  sfr KBMASK    = 0xD7;
  83      =1  
  84      =1  // (SPI)
  85      =1  sfr SPSTAT    = 0x84;
  86      =1  sfr SPCON     = 0x85;
  87      =1  sfr SPDAT     = 0x86;
  88      =1  sfr SPISTAT   = 0x84;
  89      =1  sfr SPICON    = 0x85;
  90      =1  sfr SPIDAT    = 0x86;
  91      =1  sfr SPCTL     = 0x85;
  92      =1  sfr SPICTL    = 0x85;
  93      =1  
  94      =1  // (PCA)
  95      =1  sfr CCON      = 0xD8;
  96      =1  sfr CMOD      = 0xD9;
  97      =1  sfr CL        = 0xE9;
  98      =1  sfr CH        = 0xF9;
  99      =1  sfr CCAPM0    = 0xDA;
 100      =1  sfr CCAPM1    = 0xDB;
 101      =1  sfr CCAPM2    = 0xDC;
 102      =1  sfr CCAPM3    = 0xDD;
 103      =1  sfr CCAPM4    = 0xDE;
 104      =1  sfr CCAPM5    = 0xDF;
 105      =1  sfr CCAP0H    = 0xFA;
 106      =1  sfr CCAP0L    = 0xEA;
 107      =1  sfr CCAP1H    = 0xFB;
C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 3   

 108      =1  sfr CCAP1L    = 0xEB;
 109      =1  sfr CCAP2H    = 0xFC;
 110      =1  sfr CCAP2L    = 0xEC;
 111      =1  sfr CCAP3H    = 0xFD;
 112      =1  sfr CCAP3L    = 0xED;
 113      =1  sfr CCAP4H    = 0xFE;
 114      =1  sfr CCAP4L    = 0xEE;
 115      =1  sfr CCAP5H    = 0xFF;
 116      =1  sfr CCAP5L    = 0xEF;
 117      =1  sfr PCAPWM0   = 0xF2;
 118      =1  sfr PCAPWM1   = 0xF3;
 119      =1  sfr PCAPWM2   = 0xF4;
 120      =1  sfr PCAPWM3   = 0xF5;
 121      =1  sfr PCAPWM4   = 0xF6;
 122      =1  sfr PCAPWM5   = 0xF7;
 123      =1  
 124      =1  // (Others)
 125      =1  sfr PCON      = 0x87;
 126      =1  sfr PCON0     = 0x87;
 127      =1  sfr PCON1     = 0x97;
 128      =1  sfr EVRCR     = 0x97;
 129      =1  sfr PCON2     = 0xC7;
 130      =1  sfr AUXR      = 0x8E;
 131      =1  sfr AUXR0     = 0x8E;
 132      =1  sfr AUXR1     = 0xA2;
 133      =1  sfr AUXR2     = 0xA6;
 134      =1  sfr STRETCH   = 0x8F;
 135      =1  sfr WDTCR     = 0xE1;
 136      =1  sfr TSTWD     = 0x97;
 137      =1  sfr SFRPI     = 0xAC;
 138      =1  
 139      =1  // (ISP)
 140      =1  sfr ISPCR     = 0xE7;
 141      =1  sfr IFMT      = 0xE5;
 142      =1  sfr IFD       = 0xE2;
 143      =1  sfr IFADRH    = 0xE3;
 144      =1  sfr IFADRL    = 0xE4;
 145      =1  sfr SCMD      = 0xE6;
 146      =1  
 147      =1  // (bits in PSW)
 148      =1  sbit CY       = PSW^7;
 149      =1  sbit AC       = PSW^6;
 150      =1  sbit F0       = PSW^5;
 151      =1  sbit RS1      = PSW^4;
 152      =1  sbit RS0      = PSW^3;
 153      =1  sbit OV       = PSW^2;
 154      =1  sbit F1       = PSW^1;
 155      =1  sbit P        = PSW^0;
 156      =1  
 157      =1  // (bits in IE)
 158      =1  sbit EA       = IE^7;
 159      =1  sbit GF4      = IE^6;
 160      =1  sbit ET2      = IE^5;
 161      =1  sbit ES       = IE^4;
 162      =1  sbit ES0      = IE^4;
 163      =1  sbit ET1      = IE^3;
 164      =1  sbit EX1      = IE^2;
 165      =1  sbit ET0      = IE^1;
 166      =1  sbit EX0      = IE^0;
 167      =1  
 168      =1  // (bits in IP0L)
 169      =1  sbit PX3L     = IP0L^7;
C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 4   

 170      =1  sbit PX2L     = IP0L^6;
 171      =1  sbit PT2L     = IP0L^5;
 172      =1  sbit PSL      = IP0L^4;
 173      =1  sbit PT1L     = IP0L^3;
 174      =1  sbit PX1L     = IP0L^2;
 175      =1  sbit PT0L     = IP0L^1;
 176      =1  sbit PX0L     = IP0L^0;
 177      =1  
 178      =1  sbit PT2      = IP^5;
 179      =1  sbit PS       = IP^4;
 180      =1  sbit PT1      = IP^3;
 181      =1  sbit PX1      = IP^2;
 182      =1  sbit PT0      = IP^1;
 183      =1  sbit PX0      = IP^0;
 184      =1  
 185      =1  //(bits in SCON0)
 186      =1  sbit FE       = SCON0^7;
 187      =1  sbit SM00     = SCON0^7;
 188      =1  sbit SM10     = SCON0^6;
 189      =1  sbit SM20     = SCON0^5;
 190      =1  sbit REN0     = SCON0^4;
 191      =1  sbit TB80     = SCON0^3;
 192      =1  sbit RB80     = SCON0^2;
 193      =1  sbit TI0      = SCON0^1;
 194      =1  sbit RI0      = SCON0^0;
 195      =1  
 196      =1  sbit SM0      = SCON^7;
 197      =1  sbit SM1      = SCON^6;
 198      =1  sbit SM2      = SCON^5;
 199      =1  sbit REN      = SCON^4;
 200      =1  sbit TB8      = SCON^3;
 201      =1  sbit RB8      = SCON^2;
 202      =1  sbit TI       = SCON^1;
 203      =1  sbit RI       = SCON^0;
 204      =1  
 205      =1  //(bits in SCON1)
 206      =1  sbit SM01     = SCON1^7;
 207      =1  sbit SM11     = SCON1^6;
 208      =1  sbit SM21     = SCON1^5;
 209      =1  sbit REN1     = SCON1^4;
 210      =1  sbit TB81     = SCON1^3;
 211      =1  sbit RB81     = SCON1^2;
 212      =1  sbit TI1      = SCON1^1;
 213      =1  sbit RI1      = SCON1^0;
 214      =1  
 215      =1  // (bits in TCON)
 216      =1  sbit TF1      = TCON^7;
 217      =1  sbit TR1      = TCON^6;
 218      =1  sbit TF0      = TCON^5;
 219      =1  sbit TR0      = TCON^4;
 220      =1  sbit IE1      = TCON^3;
 221      =1  sbit IT1      = TCON^2;
 222      =1  sbit IE0      = TCON^1;
 223      =1  sbit IT0      = TCON^0;
 224      =1  
 225      =1  // (bits in T2CON)
 226      =1  sbit TF2      = T2CON^7;
 227      =1  sbit EXF2     = T2CON^6;
 228      =1  sbit RCLK     = T2CON^5;
 229      =1  sbit TCLK     = T2CON^4;
 230      =1  sbit EXEN2    = T2CON^3;
 231      =1  sbit TR2      = T2CON^2;
C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 5   

 232      =1  sbit C_T2     = T2CON^1;
 233      =1  sbit CP_RL2   = T2CON^0;
 234      =1  
 235      =1  // (bits in CCON)
 236      =1  sbit CF       = CCON^7;
 237      =1  sbit CR       = CCON^6;
 238      =1  sbit CCF5     = CCON^5;
 239      =1  sbit CCF4     = CCON^4;
 240      =1  sbit CCF3     = CCON^3;
 241      =1  sbit CCF2     = CCON^2;
 242      =1  sbit CCF1     = CCON^1;
 243      =1  sbit CCF0     = CCON^0;
 244      =1  
 245      =1  // (bits in XICON)
 246      =1  sbit PX3      = XICON^7;
 247      =1  sbit IT3H     = XICON^7;
 248      =1  sbit EX3      = XICON^6;
 249      =1  sbit IE3      = XICON^5;
 250      =1  sbit IT3      = XICON^4;
 251      =1  sbit PX2      = XICON^3;
 252      =1  sbit IT2H     = XICON^3;
 253      =1  sbit EX2      = XICON^2;
 254      =1  sbit IE2      = XICON^1;
 255      =1  sbit IT2      = XICON^0;
 256      =1  
 257      =1  // (bits in P0)
 258      =1  sbit P07      = P0^7;
 259      =1  sbit P06      = P0^6;
 260      =1  sbit P05      = P0^5;
 261      =1  sbit P04      = P0^4;
 262      =1  sbit P03      = P0^3;
 263      =1  sbit P02      = P0^2;
 264      =1  sbit P01      = P0^1;
 265      =1  sbit P00      = P0^0;
 266      =1  
 267      =1  // (bits in P1)
 268      =1  sbit P17      = P1^7;
 269      =1  sbit P16      = P1^6;
 270      =1  sbit P15      = P1^5;
 271      =1  sbit P14      = P1^4;
 272      =1  sbit P13      = P1^3;
 273      =1  sbit P12      = P1^2;
 274      =1  sbit P11      = P1^1;
 275      =1  sbit P10      = P1^0;
 276      =1  
 277      =1  // (bits in P2)
 278      =1  sbit P27      = P2^7;
 279      =1  sbit P26      = P2^6;
 280      =1  sbit P25      = P2^5;
 281      =1  sbit P24      = P2^4;
 282      =1  sbit P23      = P2^3;
 283      =1  sbit P22      = P2^2;
 284      =1  sbit P21      = P2^1;
 285      =1  sbit P20      = P2^0;
 286      =1  
 287      =1  // (bits in P3)
 288      =1  sbit P37      = P3^7;
 289      =1  sbit P36      = P3^6;
 290      =1  sbit P35      = P3^5;
 291      =1  sbit P34      = P3^4;
 292      =1  sbit P33      = P3^3;
 293      =1  sbit P32      = P3^2;
C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 6   

 294      =1  sbit P31      = P3^1;
 295      =1  sbit P30      = P3^0;
 296      =1  
 297      =1  // (bits in P4)
 298      =1  sbit P47      = P4^7;
 299      =1  sbit P46      = P4^6;
 300      =1  sbit P45      = P4^5;
 301      =1  sbit P44      = P4^4;
 302      =1  sbit P43      = P4^3;
 303      =1  sbit P42      = P4^2;
 304      =1  sbit P41      = P4^1;
 305      =1  sbit P40      = P4^0;
 306      =1  
 307      =1  // (bits in P5)
 308      =1  sbit P53      = P5^3;
 309      =1  sbit P52      = P5^2;
 310      =1  sbit P51      = P5^1;
 311      =1  sbit P50      = P5^0;
 312      =1  
 313      =1  // (bits in P6)
 314      =1  sbit P61      = P6^1;
 315      =1  sbit P60      = P6^0;
 316      =1  
 317      =1  // (bits in P1, alternate)
 318      =1  sbit T2EX     = P1^1;
 319      =1  sbit T2       = P1^0;
 320      =1  sbit S2TXD    = P1^3;
 321      =1  sbit S2RXD    = P1^2;
 322      =1  
 323      =1  sbit SPI_CLK  = P1^7;
 324      =1  sbit SPI_MISO = P1^6;
 325      =1  sbit SPI_MOSI = P1^5;
 326      =1  sbit SPI_SS   = P1^4;
 327      =1  
 328      =1  sbit CEX5     = P1^7;
 329      =1  sbit CEX4     = P1^6;
 330      =1  sbit CEX3     = P1^5;
 331      =1  sbit CEX2     = P1^4;
 332      =1  sbit CEX1     = P1^3;
 333      =1  sbit CEX0     = P1^2;
 334      =1  sbit ECI      = P1^1;
 335      =1  
 336      =1  sbit AIN7     = P1^7;
 337      =1  sbit AIN6     = P1^6;
 338      =1  sbit AIN5     = P1^5;
 339      =1  sbit AIN4     = P1^4;
 340      =1  sbit AIN3     = P1^3;
 341      =1  sbit AIN2     = P1^2;
 342      =1  sbit AIN1     = P1^1;
 343      =1  sbit AIN0     = P1^0;
 344      =1  
 345      =1  //(bits in P2, alternate)
 346      =1  sbit KBI7     = P2^7;
 347      =1  sbit KBI6     = P2^6;
 348      =1  sbit KBI5     = P2^5;
 349      =1  sbit KBI4     = P2^4;
 350      =1  sbit KBI3     = P2^3;
 351      =1  sbit KBI2     = P2^2;
 352      =1  sbit KBI1     = P2^1;
 353      =1  sbit KBI0     = P2^0;
 354      =1  //sbit TEMP     = P2^5;
 355      =1  
C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 7   

 356      =1  // (bits in P3, alternate)
 357      =1  sbit RD       = P3^7;
 358      =1  sbit WR       = P3^6;
 359      =1  sbit T1       = P3^5;
 360      =1  sbit T0       = P3^4;
 361      =1  sbit INT1     = P3^3;
 362      =1  sbit INT0     = P3^2;
 363      =1  sbit TXD      = P3^1;
 364      =1  sbit RXD      = P3^0;
 365      =1  sbit T1CKO    = P3^5;
 366      =1  sbit T0CKO    = P3^4;
 367      =1  
 368      =1  // (bits in P4, alternate)
 369      =1  sbit INT2     = P4^3;
 370      =1  sbit INT3     = P4^2;
 371      =1  
 372      =1  sbit ALE      = P4^6;
 373      =1  
 374      =1  // (bits in P6, alternate)
 375      =1  sbit CKO      = P6^0;
 376      =1  sbit XOUT     = P6^0;
 377      =1  sbit XIN      = P6^1;
  11          #include <IO_DEFINE.h>
   1      =1  #ifndef IO_DEFINE_h_ 
   2      =1  #define IO_DEFINE_h_
   3      =1  
   4      =1  sbit TC_C    = P0^0;    //k=0x00;j=0x01;t=0x02;e=0x03; 
   5      =1  sbit RTD_C   = P0^1;    //r=0x04;s=0x05;b=0x06;n=0x07;
   6      =1  sbit mV_C    = P0^2;
   7      =1  sbit mA_C    = P0^3;     //tc= 000 00xxx;  rtd=000 01xxx;    mV=000 10xxx
   8      =1  sbit mV_OUT  = P0^4;     //mA= 000 11xxx;
   9      =1  sbit mA_OUT  = P0^5;
  10      =1  sbit UP_KEY   = P0^6;
  11      =1  sbit DOWN_KEY = P0^7;
  12      =1  
  13      =1  sbit LED1_SDA = P1^0;
  14      =1  sbit LED1_SCL = P1^2;
  15      =1  sbit LED1_LE  = P1^1;
  16      =1  sbit LED2_SDA  = P1^3;
  17      =1  sbit LED2_SCL  = P1^4;
  18      =1  sbit LED2_LE   = P1^5;
  19      =1  sbit RTC_SCL   = P1^6;
  20      =1  sbit non3      = P1^7;
  21      =1  
  22      =1  sbit AD_SDA   = P2^0;
  23      =1  sbit AD_SCL   = P2^1;
  24      =1  sbit ALL_SDA  = P2^2;
  25      =1  sbit EEP_SCL  = P2^3;
  26      =1  sbit OUT_SCL  = P2^4;
  27      =1  sbit TEMP     = P2^5;
  28      =1  sbit NONE_4   = P2^6;
  29      =1  sbit NONE_5   = P2^7;
  30      =1  sbit RTC_SDA  = P2^2;
  31      =1  
  32      =1  sbit R485_RX           = P3^0;
  33      =1  sbit R485_TX           = P3^1;
  34      =1  sbit FUNCTION_KEY      = P3^2;
  35      =1  sbit OFFSET_KEY        = P3^3;
  36      =1  sbit BEEP_OUT          = P3^4;   //for relay
  37      =1  sbit R485_DE_RE        = P3^5;
  38      =1  sbit NONE_6            = P3^6;
  39      =1  sbit NONE_7            = P3^7;
C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 8   

  40      =1  //------------------------
  41      =1  sbit EEPROM_SDA = P2^2;
  42      =1  sbit EEPROM_SCL = P2^3;
  43      =1  
  44      =1  sbit Value_SDA  = P2^0;
  45      =1  sbit Value_SCL  = P2^1;
  46      =1  sbit BEEP       = P3^4;  //for relay
  47      =1  
  48      =1  sbit mV_SDA   = P2^2;
  49      =1  sbit mV_SCL   = P2^4;
  50      =1  sbit mA_SDA   = P2^2;
  51      =1  sbit mA_SCL   = P2^4;
  52      =1  
  53      =1  #endif
  12          #include <LED.h>
   1      =1  #ifndef LED_h_ 
   2      =1  #define LED_h_ 
   3      =1  
   4      =1  
   5      =1  void LED_Disp(unsigned char LEDs, unsigned  int disp_value);
   6      =1  void SETUP_LED_Disp(unsigned char SETUP_SELECT, unsigned int disp_value);
   7      =1  void LED_DATA_Write(unsigned char prt,unsigned char D5,unsigned char D4,unsigned char D3,unsigned char D2,
             -unsigned char D1,unsigned char D0);
   8      =1  void DAY_LED_Disp(unsigned char DD,unsigned char HH, unsigned char MM);
   9      =1  void LED_Init(void);
  10      =1  void LED_Cls(void);
  11      =1  void LED_Fill(void);
  12      =1  #endif
  13          #include <AD3421.h>
   1      =1  /************************************************************************
   2      =1  * FileName     : i2c.h
   3      =1  * Description  : Default MPC82G516 to ctrl AD111A0 IC function.
   4      =1  *
   5      =1  *
   6      =1  * Version control:
   7      =1  ***************************************************************************/
   8      =1  #ifndef __AD3421_H__
   9      =1  #define __AD3421_H__
  10      =1  
  11      =1  
  12      =1  void AD3421_Init(void);
  13      =1  void AD3421_start(void);
  14      =1  void AD3421_stop(void);
  15      =1  void AD3421_write_byte(unsigned char bt);
  16      =1  unsigned char AD3421_read_byte(unsigned char lastbyte);         
  17      =1  void AD3421_write_com(unsigned char dev_id, unsigned char reg_addr);
  18      =1  unsigned char AD3421_read_com(unsigned char dev_id);
  19      =1  void S_Delay(unsigned int n);
  20      =1  unsigned char Get_AD3421_Value(void);
  21      =1  
  22      =1  unsigned int  SetmA(unsigned int mA_Value);
  23      =1  unsigned int  SetmV(unsigned int mV_Value);       
  24      =1  
  25      =1  
  26      =1  void DAC_write(unsigned char ch_id, unsigned int ma);
  27      =1  void Clear_key_delay(void);
  28      =1  unsigned char EEPROM_write(unsigned char reg_addr, unsigned int reg_data);
  29      =1  unsigned char   EEPROM_read_byte(unsigned char reg_addr);
  30      =1  unsigned char KeyScan(void);
  31      =1  unsigned char voicePlay(unsigned char id, unsigned char vol);
  32      =1  unsigned char Get_Key(void);
  33      =1  
C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 9   

  34      =1  #define         TRUE    1
  35      =1  #define         FALSE   0
  36      =1  
  37      =1  #endif 
  14          #include <DAC6571_mV.h>
   1      =1  /************************************************************************
   2      =1  * FileName     : i2c.h
   3      =1  * Description  : Default MPC82G516 to ctrl AD111A0 IC function.
   4      =1  *
   5      =1  *
   6      =1  * Version control:
   7      =1  ***************************************************************************/
   8      =1  #ifndef __DAC6571_mV_H__
   9      =1  #define __DAC6571_mV_H__
  10      =1  
  11      =1  void DAC6571mV_Init(void);
  12      =1  void DAC6571mV_start(void);
  13      =1  void DAC6571mV_stop(void);
  14      =1  void DAC6571mV_write_byte(unsigned char bt);
  15      =1  void mV_Delay(unsigned int n);
  16      =1  void Set_mV(unsigned int mV_V);   
  17      =1  
  18      =1  #define         TRUE    1
  19      =1  #define         FALSE   0
  20      =1  
  21      =1  #endif 
  15          #include <DAC6571_mA.h>
   1      =1  /************************************************************************
   2      =1  * FileName     : i2c.h
   3      =1  * Description  : Default MPC82G516 to ctrl AD111A0 IC function.
   4      =1  *
   5      =1  *
   6      =1  * Version control:
   7      =1  ***************************************************************************/
   8      =1  #ifndef __DAC6571_mA_H__
   9      =1  #define __DAC6571_mA_H__
  10      =1  
  11      =1  
  12      =1  void DAC6571mA_Init(void);
  13      =1  void DAC6571mA_start(void);
  14      =1  void DAC6571mA_stop(void);
  15      =1  void DAC6571mA_write_byte(unsigned char bt);
  16      =1  void mA_Delay(unsigned int n);
  17      =1  void Set_mA(unsigned int mA_Value);
  18      =1  
  19      =1  #define         TRUE    1
  20      =1  #define         FALSE   0
  21      =1  
  22      =1  #endif 
  16          #include <MCP79411.h>
   1      =1  /********************************
   2      =1  **          RTC.DEVICE     **
   3      =1  *********************************/
   4      =1  #ifndef __mcp79411_H_
   5      =1  #define __mcp79411_H_
   6      =1  
   7      =1  void RTC_Delay(unsigned int i);
   8      =1  void RTC_BitDly(void);  
   9      =1  //void RTC_Init(void);
  10      =1  void RTC_start0(void);  
  11      =1  void RTC_stop0(void);
  12      =1  void RTC_restart0(void);
C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 10  

  13      =1  void RTC_write_byte0(unsigned char bt);
  14      =1  void RTC_write_byte(unsigned char reg_addr,unsigned char reg_data);
  15      =1  void RTC_write_word(unsigned char addr, unsigned int intdata);
  16      =1  unsigned char RTC_read_byte0(void);
  17      =1  unsigned char RTC_read_byte(unsigned char reg_addr);
  18      =1  unsigned int  RTC_read_word(unsigned char addr);
  19      =1  void RTC_WRITE_SET(void);
  20      =1  void RTC_READ_SET(void);
  21      =1  void RTC_ON(void);
  22      =1  void RTC_Write_Default(void);
  23      =1  
  24      =1  #endif
  17          #include <EEPROM.H>
   1      =1  /********************************
   2      =1  **          EEPROM.DEVICE          **
   3      =1  *********************************/
   4      =1  #ifndef __EEPROM_H
   5      =1  #define __EEPROM_H
   6      =1  
   7      =1  void EEPROM_Delay(unsigned int i);
   8      =1  void EEPROM_BitDly(void);
   9      =1  void EEPROM_Init(void);
  10      =1  void EEPROM_start0(void);
  11      =1  void EEPROM_stop0(void);
  12      =1  void EEPROM_restart0(void);
  13      =1  
  14      =1  void EEPROM_write_byte0(unsigned char bt);
  15      =1  void EEPROM_write_byte(unsigned char reg_addr,unsigned char reg_data);
  16      =1  void EEPROM_write_word(unsigned char addr, unsigned int intdata);
  17      =1  
  18      =1  unsigned char EEPROM_read_byte0(void);
  19      =1  unsigned char EEPROM_read_byte(unsigned char reg_addr);
  20      =1  unsigned int  EEPROM_read_word(unsigned char addr);
  21      =1  void EEPROM_Write_Default(void);
  22      =1  
  23      =1  #endif
  18          #include <STDLIB.H>
   1      =1  /*--------------------------------------------------------------------------
   2      =1  STDLIB.H
   3      =1  
   4      =1  Standard functions.
   5      =1  Copyright (c) 1988-2005 Keil Elektronik GmbH and Keil Software, Inc.
   6      =1  All rights reserved.
   7      =1  --------------------------------------------------------------------------*/
   8      =1  
   9      =1  #ifndef __STDLIB_H__
  10      =1  #define __STDLIB_H__
  11      =1  
  12      =1  #ifndef _SIZE_T
  13      =1   #define _SIZE_T
  14      =1  
  15      =1  typedef unsigned int size_t;
  16      =1  #endif
  17      =1  
  18      =1  #ifndef NULL
  19      =1   #define NULL ((void *) 0L)
  20      =1  #endif
  21      =1  
  22      =1  #ifndef _WCHAR_T_DEFINED_
  23      =1  #define _WCHAR_T_DEFINED_
  24      =1  
  25      =1  typedef char wchar_t;
C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 11  

  26      =1  #endif
  27      =1  
  28      =1  #ifndef RAND_MAX
  29      =1   #define RAND_MAX  32767u
  30      =1  #endif
  31      =1  
  32      =1  #pragma SAVE
  33      =1  #pragma REGPARMS
  34      =1  
  35      =1  extern int    abs  (int   val);
  36      =1  extern long  labs  (long  val);
  37      =1  
  38      =1  extern float atof (char *s1);
  39      =1  extern long  atol (char *s1);
  40      =1  extern int   atoi (char *s1);
  41      =1  extern int   rand ();
  42      =1  extern void  srand (int);
  43      =1  
  44      =1  extern float         strtod  (char *, char **);
  45      =1  extern long          strtol  (char *, char **, unsigned char);
  46      =1  extern unsigned long strtoul (char *, char **, unsigned char);
  47      =1  
  48      =1  #define _MALLOC_MEM_    xdata
  49      =1  
  50      =1  extern void init_mempool          (void _MALLOC_MEM_ *p, unsigned int size);
  51      =1  extern void _MALLOC_MEM_ *malloc  (unsigned int size);
  52      =1  extern void free                  (void _MALLOC_MEM_ *p);
  53      =1  extern void _MALLOC_MEM_ *realloc (void _MALLOC_MEM_ *p, unsigned int size);
  54      =1  extern void _MALLOC_MEM_ *calloc  (unsigned int size, unsigned int len);
  55      =1  
  56      =1  #pragma RESTORE
  57      =1  
  58      =1  #endif
  19          #include <TYPE_SLOPE.H>
   1      =1  /*************************************
   2      =1   SLOPE FOR PER TYPE AND GAIN 
   3      =1  
   4      =1  **************************************/
   5      =1  #ifndef SLOPE_h_ 
   6      =1  #define SLOPE_h_ 
   7      =1  
   8      =1  unsigned int Get_K_Slope(unsigned  int kt);
   9      =1  unsigned int Get_J_Slope(unsigned  int jt);
  10      =1  unsigned int Get_T_Slope(unsigned  int ts);
  11      =1  unsigned int Get_E_Slope(unsigned  int et);
  12      =1  unsigned int Get_R_Slope(unsigned  int rt);
  13      =1  unsigned int Get_S_Slope(unsigned  int st);
  14      =1  unsigned int Get_B_Slope(unsigned  int bt);
  15      =1  unsigned int Get_N_Slope(unsigned  int nt); 
  16      =1  unsigned int Get_RTD_Slope(unsigned int rtd);
  17      =1  unsigned int DO_RTD_TYPE(void);
  18      =1  unsigned int Read_AD3421_Value(void);
  19      =1  unsigned int Check_Type_Offset(unsigned int ss);
  20      =1  #endif
  20          
  21          #define   BASE_TEMP             32       //F & C Transfor Data
  22          #define   MAX_TEMP              3240     //F 1800C
  23          #define   MAX_VOLT              2048     //mV
  24          #define   EEP_START             60
  25          #define   EEP_END               2000
  26          #define   JOHNSON       0x5a
  27          #define   LIN           0xa5
C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 12  

  28          
  29          #define   K_TYPE                0               //2466F   54.807mV      P0=0x00
  30          #define   J_TYPE                1               //1368F   42.922mV
  31          #define   T_TYPE            2           //360F    9.286mV
  32          #define   E_TYPE                3               //1440F   61.022mV
  33          #define   R_TYPE                4               //2880F   18.842mV
  34          #define   S_TYPE                5               //2880F   16.771mV
  35          #define   B_TYPE                6               //3240F   13.585mV
  36          #define   N_TYPE            7           //?       ?
  37          
  38          #define TC_FUNCTION             0
  39          #define RTD_FUNCTION    1
  40          #define mV_FUNCTION             2
  41          #define mA_FUNCTION             3
  42          #define SETUP_FUNCTION  4
  43          #define CLEAR_FUNCTION  5
  44          
  45          #define   ON    1
  46          #define   OFF   0
  47          
  48          //timer out work select
  49          #define DISPLAY_SEND_TIME  0     // DISPLAY TIME  
  50          #define ADC_READ_TIME      1     //     ADC_READ_TIME
  51          #define RTC_READ_TIME      2     //     RTC_READ_TIME
  52          #define RTC_SEND_TIME      3     //     RTC_SEND_TIME
  53          #define UART_SEND_TIME     4     //     UART_SEND_TIME
  54          #define MV_SEND_TIME       5     // mV_OUT_ TIME
  55          #define SETUP_TIMEOUT      6     //     FAIL_TIMEOUT
  56          #define TIMEUP_TIME        7     //
  57          #define TEMP_TIME          8     //
  58          
  59          #define NOMAL_FUNCTION    0
  60          #define MODE_CAL          1
  61          #define C_F_CAL           2
  62          #define TYPE_CAL          3
  63          #define TC_ZERO_CAL       4
  64          #define TC_SPAN_CAL       5
  65          #define RTD_ZERO_CAL      6
  66          #define RTD_SPAN_CAL      7
  67          #define mV_ZERO_CAL       8
  68          #define mV_SPAN_CAL       9
  69          #define mA_ZERO_CAL       10
  70          #define mA_SPAN_CAL       11
  71          #define ALARM_LO_CAL      12
  72          #define ALARM_HI_CAL      13
  73          #define YEAR_DATE_CAL     14
  74          #define MON_DATE_CAL      15
  75          #define DAY_DATE_CAL      16
  76          #define HOUR_DATE_CAL     17
  77          #define MIN_DATE_CAL      18
  78          //#define SEC_DATE_CAL      19
  79          #define PRODUCT_RESET     19
  80          #define  SQWE           0x40            //  SQWE = b6  
  81          #define  MFP_01H        0x00 
  82          #define  OSC_EN         0x80                    // day bit 7
  83          
  84          #define  sec     0x00  
  85          #define  min     0x01 
  86          #define  hour    0x02
  87          #define  week    0x03
  88          #define  day     0x04
  89          #define  month   0x05
C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 13  

  90          #define  year    0x06
  91          #define  ctl     0x07
  92                             
  93          #define  Mode_Select 18    //EEP Address
  94          #define  C_F_Select  19
  95          #define  Type_Select 20
  96          #define  TC_Zero     22   
  97          #define  TC_Span     24
  98          #define  RTD_Zero    26
  99          #define  RTD_Span    28
 100          #define  mV_Zero     30                                                                   
 101          #define  mV_Span     32
 102          #define  mA_Zero     34
 103          #define  mA_Span     36
 104          #define  Alarm_Low   38
 105          #define  Alarm_Hi    40
 106          #define  Year_Date   42
 107          #define  Mon_Date    43
 108          #define  Day_Date    44
 109          #define  Week_Date   45
 110          #define  Hour_Date   46
 111          #define  Min_Date    47
 112          #define  sec_Date    48
 113          #define  Status_flag 50
 114          #define  TC_Span_Per 52
 115          #define  RTD_Span_Per 54
 116          #define  mV_Span_Per 56
 117          #define  mA_Span_Per 58
 118          
 119          #define  EEP_ADR     64
 120          //===============================
 121          extern unsigned char key = 0,key_bak = 0;
 122          extern unsigned char AV_COD ;
 123          extern unsigned char NP_COD ;
 124          unsigned char NG_COD,ADD_COD;
 125          unsigned char OVER_COD = 0 ;
 126          idata unsigned char Soft_Timer[9] = {16,16,4,2,59,2,20,30,2};
 127          idata unsigned char T0_cnt,T2_cnt , T1_cnt;
 128          idata unsigned char Temp_Flag = 3 ;
 129          idata unsigned char  t_code = 8 ;
 130          idata unsigned int  Data_Value[15];
 131          unsigned int  Temp_sp = 0 ;
 132          unsigned char MAIN_SW;
 133          unsigned char Work_Type;
 134          unsigned char C_F_Type;
 135          unsigned char TC_Type;
 136          unsigned int  TC_Zero_offset;
 137          unsigned int  TC_Span_offset;
 138          unsigned int  RTD_Zero_offset;
 139          unsigned int  RTD_Span_offset;
 140          unsigned int  mV_Zero_offset;
 141          unsigned int  mV_Span_offset;
 142          unsigned int  mA_Zero_offset;
 143          unsigned int  mA_Span_offset;
 144          unsigned int  alarm_Low_set;
 145          unsigned int  alarm_Hi_set;
 146          unsigned int  TC_Span_Value = 0;
 147          unsigned int  RTD_Span_Value = 0;
 148          unsigned int  mV_Span_Value = 0;
 149          unsigned int  mA_Span_Value = 0;
 150          unsigned int  Temp_offset = 0 ; 
 151          unsigned int  Temp_m = 0 ;  
C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 14  

 152          unsigned int  use_flag;
 153          unsigned char  use_year = 0x14;
 154          unsigned char  use_mon  = 0x01;
 155          unsigned char  use_day  = 0x01;
 156          unsigned char  use_week = 0x03;
 157          unsigned char  use_hour = 0x12;
 158          unsigned char  use_min  = 0x01;
 159          unsigned char  use_sec  = 0x01;
 160          //unsigned char  eep_count;
 161          unsigned int   Disp_year;
 162          unsigned char  n_code = 0 ;
 163          unsigned char CAIT = 0x01;
 164          unsigned char Func_Type;
 165          unsigned char AD_Hi;
 166          unsigned char AD_Mid;
 167          unsigned char AD_Lo;
 168          unsigned char AD_Status;
 169          unsigned char PCB_SETUP;
 170          unsigned char Soft_Timer_Enable = 0;
 171          unsigned char Key_backup, ReceiveDate;
 172          
 173          bit f_half_sec;
 174          bit ReceiveFlag = 0;
 175          bit tran = 0 ;
 176          bit Zero_f = 0 ;
 177          /***************************************
 178                     Port In/Out Setting
 179          *****************************************/
 180          void PORT_Init(void)
 181          {
 182   1              P0M0 = 0xFF;      //00=Qb,01=pull output, 10= input only,11=open drain
 183   1              P0M1 = 0x00;     //P0= ALL INPUT  00
 184   1              P0   = 0xff;
 185   1      
 186   1              P1M0 = 0x00;     //P1= ALL OUTPUT//00
 187   1              P1M1 = 0xFF;     //SETUP P1 ALL LO //  define P1.3 P1.4 P1.5 as push-pull
 188   1          P1   = 0x00;
 189   1          
 190   1              P2M0 = 0x24;     //P2= ALL OUTOUT        04 
 191   1              P2M1 |= 0xFF;    //SETUP P2 ALL LO       df
 192   1              P2  =  P2|0x20;
 193   1      
 194   1          P3M0 = 0xED;         //     ed  
 195   1              P3M1 = 0x13;    // 13
 196   1              P3   = 0x2C;    // 2c
 197   1      }
 198          /*******************************************
 199               interrupt   0
 200          *******************************************/
 201          void ex_int0(void) interrupt 0
 202          {;
 203   1      }
 204          /*******************************************
 205               interrupt   1
 206          *******************************************/
 207          void time0(void) interrupt  1     //   T=1/16 sec 
 208          {
 209   1       unsigned int Value_code;
 210   1              TR0 = 0;
 211   1              T1_cnt++;
 212   1              if ((T1_cnt%8)==0)
 213   1              Value_code = SBUF;
C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 15  

 214   1              TH0 = 0x0B;      //0b
 215   1              TL0 = 0xDC;
 216   1              TR0 = 1;
 217   1      }
 218          
 219          /*******************************************
 220               interrupt   3
 221          *******************************************/
 222          void time1(void) interrupt  3   //    T=1/16 sec 
 223          {
 224   1              TR1 = 0;
 225   1              T0_cnt++;                                                       
 226   1      
 227   1              if (Soft_Timer[DISPLAY_SEND_TIME] != 0)         Soft_Timer[DISPLAY_SEND_TIME]--;
 228   1              if (Soft_Timer[ADC_READ_TIME] != 0)         Soft_Timer[ADC_READ_TIME]--;
 229   1              if ((T0_cnt%8)==0)      
 230   1                {
 231   2                if (Soft_Timer[RTC_READ_TIME] != 0)   Soft_Timer[RTC_READ_TIME]--;
 232   2                  f_half_sec = 1;
 233   2                }
 234   1              if (T0_cnt == 15)
 235   1              {
 236   2                      T0_cnt = 0;
 237   2                      if (Soft_Timer[UART_SEND_TIME] != 0)    Soft_Timer[UART_SEND_TIME]--;
 238   2                      if (Soft_Timer[MV_SEND_TIME] != 0)          Soft_Timer[MV_SEND_TIME]--;
 239   2                      if (Soft_Timer[SETUP_TIMEOUT] != 0)     Soft_Timer[SETUP_TIMEOUT]--;    
 240   2                      if (Soft_Timer[TIMEUP_TIME] != 0)               Soft_Timer[TIMEUP_TIME]--;
 241   2                      if (Soft_Timer[TEMP_TIME] != 0)             Soft_Timer[TEMP_TIME]--;
 242   2              }               
 243   1              TH1 = 0x0B;
 244   1              TL1 = 0xDC;
 245   1              TR1 = 1;
 246   1       }              
 247          /*******************************************/
 248          void T0_Init(void)
 249          {
 250   1              TR0 = 1;
 251   1              TMOD = 0x11;
 252   1              TH0 = 0x0B;             
 253   1              TL0 = 0xDC;     
 254   1              T0_cnt = 0;
 255   1      }
 256          /*******************************************
 257              
 258          *******************************************/
 259          void T1_Init(void)
 260          {
 261   1              TR1 = 0;
 262   1              TMOD = 0x11;  
 263   1              TH1 = 0x0B;
 264   1              TL1 = 0xDC;
 265   1              T1_cnt = 0;
 266   1       }
 267          /*******************************************
 268              
 269          *******************************************/
 270          void T2_Init(void)
 271          {
 272   1              TR2 = 1;
 273   1              T2MOD = 0x11;  //11  
 274   1              TH2 = 0x0B;
 275   1              TL2 = 0xDC;
C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 16  

 276   1              T2_cnt = 0;
 277   1      }
 278          /*******************************************
 279              
 280          *******************************************/
 281          void INT0_Init(void)
 282          {
 283   1          INT0 = 1;
 284   1              INT1 = 1;        
 285   1              IE0  = 1;                  
 286   1              IT0  = 1;
 287   1              EX0  = 0;         
 288   1      }
 289          /*******************************************/
 290          void InitUart()    //InitUart use timer2
 291          {
 292   1         SCON |= 0x50;                          /* uart in mode 1 (8 bit), REN=1 50 */
 293   1         T2CON &= 0xF0;               /* EXEN2=0; TR2=0; C/T2#=0; CP/RL2#=0; */
 294   1         T2CON |= 0x30;               /* RCLK = 1; TCLK=1; */
 295   1         TH2=0xFF;                    /* init value */
 296   1         TL2=0xD0;                    /* init value */
 297   1         RCAP2H=0xFF;                 /* reload value, 9600 Bds at 11.059MHz */
 298   1         RCAP2L=0xDC;                /* reload value, 9600 Bds at 11.059MHz */
 299   1         ES = 1;                                                   /* Enable serial interrupt */
 300   1         TR2 = 1;                     /* Timer 2 run */
 301   1      }
 302          /*************************************************/
 303          void serial() interrupt 4
 304          {
 305   1              if(TI==1)
 306   1               {
 307   2                TI = 0 ;
 308   2                }                
 309   1          if(RI==1)
 310   1               {
 311   2                 RI=0;
 312   2                 ReceiveDate = SBUF;
 313   2                 ReceiveFlag = 1;
 314   2               }
 315   1      }
 316          /****************************************/
 317          void delay(unsigned int i)
 318          {
 319   1              unsigned char j;
 320   1              for (; i>0; i--)
 321   1                      for (j=0; j<255; j++);
 322   1      }
 323          /*******************************************
 324              
 325          *******************************************/
 326          void Buzzer(unsigned char status)
 327          {
 328   1              if (status)
 329   1            P3 =      P3 |= 0x10;
 330   1              else
 331   1                P3 = P3 &= ~0x10;
 332   1      }
 333          /*******************************************
 334                CHECK PCB TYPE
 335          *******************************************/
 336          void Check_PCB(void)
 337          {
C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 17  

 338   1                 if(P00 == 0)                //tc
 339   1                   {
 340   2                           Work_Type = 0x00;
 341   2                               Func_Type = 0x00;
 342   2                               PCB_SETUP = 0x01;
 343   2                           if(P04 == 0)           //mV_out
 344   2                             {PCB_SETUP = 0x11 ;}
 345   2                       if(P05 == 0)   //mA_out
 346   2                             {PCB_SETUP = 0x21 ;}
 347   2                               if(use_flag == 0x0001) { NG_COD = 1;}
 348   2                       }
 349   1                 else if(P01 == 0)           //rtd
 350   1                       {
 351   2                                Work_Type = 0x01;
 352   2                                Func_Type = 0x01;
 353   2                                  PCB_SETUP = 0x02 ;
 354   2                            if(P04 == 0)      //mV_out
 355   2                              {PCB_SETUP = 0x12 ;}
 356   2                            if(P05 == 0)      //mA_out
 357   2                              {PCB_SETUP = 0x22 ;}
 358   2                                 if(use_flag == 0x0002) { NG_COD = 1;}
 359   2                       }
 360   1                else if(P02 == 0)          //mV
 361   1                       {
 362   2                               Work_Type = 0x02 ;
 363   2                               Func_Type = 0x02;
 364   2                                PCB_SETUP = 0x04 ;
 365   2                                if(P04 == 0)  //mV_out
 366   2                              {PCB_SETUP = 0x14 ;}
 367   2                            if(P05 == 0)      //mA_out
 368   2                              {PCB_SETUP = 0x24 ;}
 369   2                                 if(use_flag == 0x0004) { NG_COD = 1;}
 370   2                       } 
 371   1                else if(P03 == 0)             //mA
 372   1                       { 
 373   2                           Work_Type = 0x03 ;
 374   2                               Func_Type = 0x03;
 375   2                                 PCB_SETUP = 0x08 ;
 376   2                               if(P04 == 0)           //mV_out
 377   2                             {PCB_SETUP = 0x18 ;}
 378   2                           if(P05 == 0)       //mA_out
 379   2                             {PCB_SETUP = 0x28 ;}
 380   2                               if(use_flag == 0x0008) { NG_COD = 1;}  
 381   2                       }
 382   1      }
 383          /***********************************************/
 384          unsigned int TEMP_F_TO_C(unsigned int tc_tmp)
 385          {
 386   1       unsigned int ttmp;
 387   1      
 388   1                if(NP_COD == 1)
 389   1                  {
 390   2                       if(tc_tmp >= 32)
 391   2                    {
 392   3                          if(AV_COD == 0)
 393   3                            {
 394   4                              ttmp = (tc_tmp-32)/1.8;
 395   4                            }
 396   3                        else
 397   3                           {
 398   4                                  ttmp = (tc_tmp+32)/1.8; 
 399   4                   }
C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 18  

 400   3                    }
 401   2                  else
 402   2                    {
 403   3                         if(AV_COD == 0)
 404   3                               {
 405   4                         ttmp = (32-tc_tmp)/1.8;
 406   4                                 AV_COD = 1 ;
 407   4                   }
 408   3                         else
 409   3                           {
 410   4                                ttmp = (32+tc_tmp)/1.8;
 411   4                                
 412   4                               }
 413   3                        }
 414   2            }
 415   1          else
 416   1                {               
 417   2                 if(tc_tmp >= 320)
 418   2                    {
 419   3                          if(AV_COD == 0)
 420   3                            {
 421   4                              ttmp = (tc_tmp-320)/1.8;
 422   4                            }
 423   3                        else
 424   3                           {
 425   4                                  ttmp = (tc_tmp+320)/1.8; 
 426   4                   }
 427   3                    }
 428   2                  else
 429   2                    {
 430   3                         if(AV_COD == 0)
 431   3                               {
 432   4                         ttmp = (320-tc_tmp)/1.8;
 433   4                                       AV_COD = 1 ;
 434   4                   }
 435   3                         else
 436   3                           {
 437   4                                ttmp = (320+tc_tmp)/1.8;
 438   4                               }
 439   3                       }
 440   2                 }
 441   1            return(ttmp);
 442   1      }
 443          /**********************************************/
 444          void Volt_Ctrl(void)
 445          {
 446   1      }
 447          /*********************************
 448              15782,15956,16125,16288,16448,16605,16757,16907,17029,17148,17266,
 449              17380,17493,17593,17692,17789,17884,17978,18060,18141,18221,18299,18377,18443,18509,18573,18637,18700,
             -18756,18811,18865,18919,
 450              18972,19022,19072,19121,19170,19219,19255,19291,19326,19362,19397,19430,19462,19495,19527,19559,19586,
             -19613,19641,19668,19695,
 451              19719,19742,19766,19790,19814,19832,19851,19870,19888,19907,19926,19945,19963,19982,20001,
 452          *******273.5 K *****/                                                                                                                                                     
 453          unsigned int Temp_Read(void)
 454          {
 455   1      unsigned int Temp_Count,P_count;
 456   1      
 457   1                TEMP = 1;
 458   1                        P_count = 0;
 459   1                        delay(1);
C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 19  

 460   1                      while(TEMP)
 461   1                         { ; P_count = P_count + 1 ;}   
 462   1      
 463   1                          TEMP = 0 ;
 464   1                   if(P_count > 0x7c80){Temp_Count = 0;}       //7010
 465   1                       else{ Temp_Count = ( 0x7c80 - P_count)/19.4; //9.936 ;1760 2329 
 466   2                         if(Temp_Count > 121)
 467   2                                      { Temp_Count = Temp_Count-(Temp_Count-120)/12 ;  
 468   3                                            if(Temp_Count > 252)
 469   3                                          { Temp_Count = Temp_Count + (Temp_Count-251)/20 ;
 470   4                                                if(Temp_Count > 281)
 471   4                                              { Temp_Count = Temp_Count-(Temp_Count-280)/18 ;
 472   5                                                    if(Temp_Count > 401)                        //1212
 473   5                                                   { Temp_Count = Temp_Count + (Temp_Count-400)/28;
 474   6                                                            if(Temp_Count > 541)
 475   6                                                          { Temp_Count = Temp_Count+(Temp_Count-540)/15; 
 476   7                                                               if(Temp_Count > 641)
 477   7                                                              { Temp_Count = Temp_Count+(Temp_Count-640)/16;
 478   8                                                                if(Temp_Count > 731)                                             
 479   8                                                                     { Temp_Count = Temp_Count+(Temp_Count-730)/11;   //
 480   9                                                                          if(Temp_Count > 861)
 481   9                                                                        { Temp_Count = Temp_Count+(Temp_Count-860)/8;
 482  10                                                                             if(Temp_Count > 941)
 483  10                                                                           { Temp_Count = Temp_Count+(Temp_Count-940)/14;
 484  11                                                                                if(Temp_Count > 1011)
 485  11                                                                              { Temp_Count = Temp_Count+(Temp_Count-1010)/10; 
 486  12                                                                                                                              if(Temp_Count > 1041)
 487  12                                                                                { Temp_Count = Temp_Count-(Temp_Count-1040)/14;
 488  13                                                                                     if(Temp_Count > 1081)
 489  13                                                                                   { Temp_Count = Temp_Count+(Temp_Count-1080)/5;
 490  14                                                                                       if(Temp_Count > 1181)
 491  14                                                                                     { Temp_Count = Temp_Count+(Temp_Count-1180)/9;
 492  15                                                                                          if(Temp_Count > 1271)
 493  15                                                                                        { Temp_Count = Temp_Count+(Temp_Count-1270)/1
             -0;
 494  16                                                                                             if(Temp_Count > 1361)
 495  16                                                                                           { Temp_Count = Temp_Count+(Temp_Count-1360
             -)/6;
 496  17                                                                                               if(Temp_Count > 1491)
 497  17                                                                                         { Temp_Count = Temp_Count + (Temp_Co
             -unt-1490)/8;
 498  18                                                                                                  if(Temp_Count > 1541)
 499  18                                                                                            { Temp_Count = Temp_Count + (Temp
             -_Count-1540)/4;
 500  19                                                                                                                                                                   if(Temp_Count > 1726)
 501  19                                                                                                     { Temp_Count = Temp_Count+(Temp_
             -Count-1720)/10;
 502  20                                                                                                                                                                      }}}}}}}}}} }}}}}}}      }
 503   2                  }
 504   1          return(Temp_Count);
 505   1      }
 506          /***********************************************/
 507          unsigned char Get_Key(void)
 508          {
 509   1        if(FUNCTION_KEY == 1 && OFFSET_KEY == 1 && UP_KEY == 1 && DOWN_KEY == 1) 
 510   1          {
 511   2               key_bak  =  0;
 512   2               key = 0 ; 
 513   2              }
 514   1        else if(FUNCTION_KEY == 0 )
 515   1          {
 516   2                if(key_bak == 0)
C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 20  

 517   2                 {
 518   3                   key_bak = 1 ;
 519   3                   key = key |= 0x01 ;
 520   3                 }
 521   2                else
 522   2                 {
 523   3                      key = key &= 0xfe ;
 524   3                 }
 525   2               }
 526   1         else if(OFFSET_KEY == 0)
 527   1           {
 528   2               if(key_bak == 0)
 529   2                 {
 530   3                   key = key |= 0x02 ;
 531   3                   key_bak = 1; 
 532   3                 }
 533   2                else
 534   2                 {
 535   3                      key = key &= 0xfd ;
 536   3                 }
 537   2               }
 538   1         else if(UP_KEY == 0)
 539   1          {
 540   2               if(key_bak == 0)
 541   2                 {
 542   3                   key = key |= 0x04 ;
 543   3                   key_bak = 1; 
 544   3                 }
 545   2                else
 546   2                 {
 547   3                      key = key &= 0xfb ;
 548   3                 }
 549   2               }
 550   1         else if(DOWN_KEY == 0)
 551   1          {
 552   2               if(key_bak == 0)
 553   2                 {
 554   3                   key = key |= 0x08;
 555   3                   key_bak = 1; 
 556   3                 }
 557   2                else
 558   2                 {
 559   3                      key = key &= 0xf7 ;
 560   3                 }
 561   2               }
 562   1       
 563   1         return key;
 564   1      }
 565          /*******************************
 566          
 567          ********************************/
 568          unsigned  int DO_TC_TYPE(void)
 569          {
 570   1          unsigned int Code_Value,TC_Value,TT_Value,TA_Value ;
 571   1               unsigned char key;
 572   1      
 573   1            key = Get_Key();
 574   1               
 575   1                if(key == 0x01)
 576   1                {
 577   2                   Func_Type = 4;
 578   2                }
C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 21  

 579   1         else
 580   1           { 
 581   2                if(Temp_Flag != 0 ){Temp_m = Temp_offset;}
 582   2            if (Soft_Timer[TEMP_TIME] == 0)
 583   2              {
 584   3                        Soft_Timer[TEMP_TIME] = 4;
 585   3                     Data_Value[n_code] = Temp_Read() ;
 586   3                     if(n_code < 4){n_code++;}
 587   3                    else{ Temp_m = (Data_Value[3]/4+Data_Value[2]/4+Data_Value[1]/4+Data_Value[0]/4) ;
 588   4                                        n_code = 0 ;
 589   4                                   if(Temp_Flag != 0){Temp_Flag-- ;} }
 590   3                      }
 591   2                      if (Soft_Timer[ADC_READ_TIME] == 0) 
 592   2                        {
 593   3                            Soft_Timer[ADC_READ_TIME] = 16;
 594   3                               Data_Value[t_code] = Read_AD3421_Value();
 595   3      
 596   3                               if(t_code < 13)
 597   3                                  {t_code++; Code_Value = Data_Value[13];}
 598   3                               else{ Data_Value[13] = (Data_Value[12]/5+Data_Value[11]/5+Data_Value[10]/5+Data_Value[9]/5+Data_Value[
             -8]/5) ;
 599   4                                        t_code = 8;}
 600   3      
 601   3                          if (TC_Type == K_TYPE)
 602   3                    { 
 603   4                                  Temp_sp =  (Temp_m*24)/10;    //ok
 604   4                                  TT_Value = Check_Type_Offset(Code_Value); 
 605   4                                  TC_Value = Get_K_Slope(TT_Value);
 606   4                                      TT_Value = TC_Value/48.8 ;
 607   4                                      TA_Value = (TC_Value/38+163) ;
 608   4                                      if (C_F_Type == 0) TC_Value = TEMP_F_TO_C(TC_Value); //
 609   4                        }
 610   3                  else if (TC_Type == J_TYPE)
 611   3                    { 
 612   4                                  Temp_sp = (Temp_m*20)/10;    //30 ok
 613   4                                  TT_Value = Check_Type_Offset(Code_Value);
 614   4                                      TC_Value = Get_J_Slope(TT_Value);
 615   4                                  TT_Value = TC_Value/27.4 ;
 616   4                                  TA_Value = (TC_Value/21.4+163) ;
 617   4                                      if (C_F_Type == 0) TC_Value = TEMP_F_TO_C(TC_Value); //
 618   4                        }
 619   3                  else if (TC_Type == T_TYPE)
 620   3                    {
 621   4                                  Temp_sp = (Temp_m*23)/10;     //231.044
 622   4                                  TT_Value = Check_Type_Offset(Code_Value);
 623   4                                  TC_Value = Get_T_Slope(TT_Value);
 624   4                              TT_Value = TC_Value/7.5 ;
 625   4                                      TA_Value = (TC_Value/6+163) ;
 626   4                                      if (C_F_Type == 0) TC_Value = TEMP_F_TO_C(TC_Value); // 
 627   4                        }
 628   3                  else if (TC_Type == E_TYPE)
 629   3                    { 
 630   4                                  Temp_sp = (Temp_m*14)/10;   //35 1.54 /0k
 631   4                              TT_Value = Check_Type_Offset(Code_Value);
 632   4                                  TC_Value = Get_E_Slope(TT_Value);
 633   4                                  TT_Value = TC_Value/28.3 ;
 634   4                                  TA_Value = (TC_Value/22.5+163) ;
 635   4                                 if (C_F_Type == 0) TC_Value = TEMP_F_TO_C(TC_Value);  //
 636   4                        }
 637   3                  else if (TC_Type == R_TYPE)
 638   3                   {  NP_COD = 1;
 639   4                                  Temp_sp = (Temp_m*3)/10;//Temp_offset/12;
C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 22  

 640   4                                      TT_Value = Check_Type_Offset(Code_Value);
 641   4                                  TC_Value = Get_R_Slope(TT_Value);
 642   4                                  TT_Value = TC_Value/56.8 ;
 643   4                                  TA_Value = (TC_Value/44.5+163) ;
 644   4                                 if (C_F_Type == 0)  TC_Value = TEMP_F_TO_C(TC_Value);
 645   4                        }
 646   3                  else if (TC_Type == S_TYPE)
 647   3                    {    NP_COD = 1;
 648   4                                   Temp_sp = (Temp_m*3)/10;//Temp_offset/12;
 649   4                                       TT_Value = Check_Type_Offset(Code_Value);
 650   4                                       TC_Value = Get_S_Slope(TT_Value);
 651   4                                   TT_Value = TC_Value/56.8 ;
 652   4                                       TA_Value = (TC_Value/44.5+163) ;
 653   4                                      if (C_F_Type == 0)      TC_Value = TEMP_F_TO_C(TC_Value); 
 654   4                        }
 655   3                        }
 656   2                  if (Soft_Timer[RTC_READ_TIME] == 0)
 657   2                     {
 658   3                               RTC_READ_SET();
 659   3                               Soft_Timer[RTC_READ_TIME] = 8;
 660   3                         }
 661   2                  if (Soft_Timer[DISPLAY_SEND_TIME] == 0)
 662   2                    {
 663   3                           Soft_Timer[DISPLAY_SEND_TIME] = 32;        
 664   3                                 LED_Disp(1,TC_Value);
 665   3      //                         LED_Disp(1,Temp_m);
 666   3                          if ((TC_Value > alarm_Low_set)&&(TC_Value < alarm_Hi_set))
 667   3                        { BEEP_OUT = 1; }
 668   3                              else
 669   3                                { BEEP_OUT = 0; }
 670   3                        }
 671   2                  if (Soft_Timer[MV_SEND_TIME] == 0)
 672   2                   {
 673   3                         if( P04 == 0) Set_mV(TT_Value);
 674   3      
 675   3                         if( P05 == 0) Set_mA(TA_Value);
 676   3                         Soft_Timer[MV_SEND_TIME] = 16;
 677   3                       }
 678   2                  if (Soft_Timer[UART_SEND_TIME] == 0)
 679   2                   {
 680   3                        if(tran == 0)
 681   3                          {
 682   4                              SBUF = TC_Value ;
 683   4                               tran = 1 ;
 684   4                               Soft_Timer[UART_SEND_TIME] = 1;
 685   4                     }
 686   3                   else
 687   3                    { 
 688   4                      SBUF = TC_Value >> 8 ;
 689   4                      tran = 0;
 690   4                              Soft_Timer[UART_SEND_TIME] = 59 ;
 691   4                        }
 692   3                      TI = 1;
 693   3                }
 694   2              }
 695   1          return  TC_Value;
 696   1      }
 697          /*************************************************************************************/
 698          unsigned int Check_Type_Offset(unsigned int Code_Value)
 699          {
 700   1          unsigned int Count_Value;
 701   1           if (NG_COD == 0)
C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 23  

 702   1             {
 703   2                  if (AV_COD == 0)
 704   2                        {
 705   3                         if(Code_Value >= TC_Zero_offset)        
 706   3                           {
 707   4                        if((Code_Value - TC_Zero_offset) >= Temp_sp)
 708   4                           { Count_Value = (Code_Value - TC_Zero_offset) - Temp_sp ;}
 709   4                         else
 710   4                                   {Count_Value = (Temp_sp + TC_Zero_offset)- Code_Value; AV_COD = 1 ; }
 711   4                        }
 712   3                               else
 713   3                                {   
 714   4                             if((TC_Zero_offset - Code_Value) >= Temp_sp)
 715   4                                  {Count_Value = TC_Zero_offset - (Code_Value + Temp_sp);AV_COD = 1 ;}
 716   4                         else
 717   4                          { Count_Value =  (Temp_sp + TC_Zero_offset) - Code_Value; AV_COD = 1 ; }
 718   4                            }
 719   3                         }
 720   2                else    // AV_COD = 1  NG_COD = 0
 721   2                     {
 722   3                           if(Code_Value >= TC_Zero_offset)
 723   3                                 {
 724   4                                  if((Code_Value - TC_Zero_offset) >= Temp_sp)
 725   4                                { Code_Value = (Code_Value + TC_Zero_offset) + Temp_sp;}
 726   4                                  else
 727   4                                    { Code_Value =  Temp_sp + ( Code_Value + TC_Zero_offset);}
 728   4                                 }
 729   3                           else
 730   3                                 {      // AV_COD = 1  NG_COD = 0
 731   4                                  if((TC_Zero_offset- Code_Value ) >= Temp_sp)
 732   4                                { Code_Value = ( Code_Value + TC_Zero_offset) + Temp_sp;}
 733   4                                  else
 734   4                                    { Code_Value = Temp_sp + (Code_Value + TC_Zero_offset) ;}
 735   4                                 }
 736   3                         }
 737   2                 }
 738   1            else
 739   1                 {
 740   2                   if(AV_COD == 0)  // AV_COD = 0      NG_COD = 1
 741   2                         {
 742   3                               Count_Value = Code_Value + TC_Zero_offset ;
 743   3                          if(Count_Value >= Temp_sp)
 744   3                           { Count_Value =  Count_Value - Temp_sp ;}
 745   3                      else
 746   3                       {Count_Value = Temp_sp  - Count_Value; AV_COD = 1; }
 747   3                     }
 748   2                else    // AV_COD = 1  NG_COD = 1
 749   2                     {
 750   3                           if(Code_Value >= TC_Zero_offset)
 751   3                                 {
 752   4                                       Count_Value = Code_Value - TC_Zero_offset ;
 753   4      
 754   4                                  if(Count_Value >= Temp_sp)
 755   4                                { Count_Value = Count_Value + Temp_sp;} 
 756   4                                  else
 757   4                                    { Count_Value = Temp_sp + Count_Value;}
 758   4                                 }
 759   3                           else
 760   3                                 {
 761   4                                       Count_Value = TC_Zero_offset - Code_Value;
 762   4                                  if( Count_Value >= Temp_sp)
 763   4                                { Count_Value =  Count_Value - Temp_sp ; AV_COD = 0;}
C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 24  

 764   4                                  else
 765   4                                    { Count_Value = Temp_sp -Count_Value; AV_COD = 1;}
 766   4                                 }                                                                                                               
 767   3                         }
 768   2                 }
 769   1      
 770   1         if(ADD_COD == 1 ) 
 771   1               { Count_Value = Count_Value + (Count_Value/TC_Span_Value); }     //TC_Span_Value
 772   1         else
 773   1               { Count_Value = Count_Value - (Count_Value/TC_Span_Value);}
 774   1                 
 775   1              if(OVER_COD == 1){ Count_Value = 0xffff;}
 776   1      
 777   1        return Count_Value;
 778   1      }
 779          /***********************************************
 780          RTD=  2 27.6    40      48      56      58
 781          131072                                  
 782          3200 2600 1950    950  40
 783          1300 2200  3250  4100    5000 5750      6450
 784          7350 7950  8700  9300  9900     10500    11150
 785          11700 12300     12850   13400 
 786          *************************************************/
 787          unsigned int DO_RTD_TYPE(void)
 788          {
 789   1        unsigned int RTD_Value; 
 790   1        unsigned char key;     
 791   1      
 792   1            key = Get_Key();
 793   1               
 794   1                if(key == 0x01)
 795   1                {
 796   2                   Func_Type =  4;
 797   2                }
 798   1              else
 799   1                {
 800   2                      if (Soft_Timer[ADC_READ_TIME] == 0) 
 801   2                         {
 802   3                               Soft_Timer[ADC_READ_TIME] = 16;
 803   3      
 804   3                                RTD_Value = Read_AD3421_Value();
 805   3      
 806   3                               if((NG_COD == 1)&&(AV_COD == 1))
 807   3                                 {
 808   4                                                if( RTD_Value >= RTD_Zero_offset)
 809   4                                                  {
 810   5                                                   RTD_Value = RTD_Value - RTD_Zero_offset;
 811   5                                                      }
 812   4                                                 else
 813   4                                                  {
 814   5                                                       RTD_Value = RTD_Zero_offset -RTD_Value;
 815   5                                                       AV_COD = 0;
 816   5                                                      }
 817   4                                      }
 818   3                                else if((NG_COD == 1)&&(AV_COD == 0))
 819   3                                  {
 820   4                                                   RTD_Value = RTD_Value + RTD_Zero_offset;
 821   4                                  }                   
 822   3                                else if((NG_COD == 0)&&(AV_COD == 1))
 823   3                                  {
 824   4                                                   RTD_Value = RTD_Value + RTD_Zero_offset;
 825   4                                  }   
C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 25  

 826   3                                else if((NG_COD == 0)&&(AV_COD == 0))
 827   3                                  {
 828   4                                             if( RTD_Value >= RTD_Zero_offset)
 829   4                                                  {
 830   5                                                   RTD_Value = RTD_Value - RTD_Zero_offset;
 831   5                                                      }
 832   4                                                 else
 833   4                                                  {
 834   5                                                       RTD_Value = RTD_Zero_offset -RTD_Value;
 835   5                                                   AV_COD = 1 ;
 836   5                                                      }
 837   4                                      }
 838   3                                         if(RTD_Span_offset > 0x44e4)
 839   3                                               {  RTD_Value = RTD_Value +(RTD_Value/RTD_Span_Value);}
 840   3                                        else
 841   3                                               {  RTD_Value = RTD_Value - (RTD_Value/RTD_Span_Value);}
 842   3                                       if(OVER_COD == 1) RTD_Value = 0xffff;
 843   3                    RTD_Value = Get_RTD_Slope(RTD_Value);
 844   3       
 845   3                       if (C_F_Type == 0)     RTD_Value = TEMP_F_TO_C(RTD_Value);
 846   3                     }
 847   2               if (Soft_Timer[DISPLAY_SEND_TIME] == 0)
 848   2                {
 849   3                         LED_Disp(1,RTD_Value);
 850   3                         Soft_Timer[DISPLAY_SEND_TIME] = 16 ;
 851   3      
 852   3                               if ((RTD_Value > alarm_Low_set)&&(RTD_Value < alarm_Hi_set))
 853   3                        { BEEP_OUT = 1; }
 854   3                              else
 855   3                                { BEEP_OUT = 0; }
 856   3                        }
 857   2                  if (Soft_Timer[MV_SEND_TIME] == 0)
 858   2                    {
 859   3                         if( P04 == 0) Set_mV(RTD_Value);
 860   3                         if( P05 == 0) Set_mA(RTD_Value);
 861   3      
 862   3                         Soft_Timer[MV_SEND_TIME] = 2;
 863   3                        }
 864   2                  if (Soft_Timer[RTC_READ_TIME] == 0)
 865   2                   {
 866   3                         RTC_READ_SET();
 867   3                         Soft_Timer[RTC_READ_TIME] = 8 ;
 868   3                       }
 869   2                  if (Soft_Timer[UART_SEND_TIME] == 0)
 870   2                    {
 871   3                         if(tran == 0)
 872   3                          {
 873   4                              SBUF = RTD_Value ;
 874   4                               tran = 1 ;
 875   4                               Soft_Timer[UART_SEND_TIME] = 1;
 876   4                     }
 877   3                   else
 878   3                    { 
 879   4                      SBUF = RTD_Value >> 8 ;
 880   4                      tran = 0;
 881   4                              Soft_Timer[UART_SEND_TIME] = 59 ;
 882   4                        }
 883   3                      TI = 1;
 884   3                 }
 885   2          }
 886   1         return RTD_Value;
 887   1      }
C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 26  

 888          /***********************************************
 889          
 890          ************************************************/
 891          unsigned  int DO_mV_TYPE(void)
 892          {
 893   1           unsigned int mV_Value;
 894   1               unsigned char key;
 895   1      
 896   1            key = Get_Key();
 897   1               
 898   1                if(key == 0x01)
 899   1                  {
 900   2                    Func_Type = 4;
 901   2                  }
 902   1                else 
 903   1                  {
 904   2                       if (Soft_Timer[ADC_READ_TIME] == 0) 
 905   2                        {
 906   3                          Soft_Timer[ADC_READ_TIME] = 16;
 907   3      
 908   3                          mV_Value = Read_AD3421_Value();
 909   3      
 910   3                               
 911   3                               if((NG_COD == 1)&&(AV_COD == 1))
 912   3                                 {
 913   4                                                if( mV_Value > mV_Zero_offset)                
 914   4                                                  {
 915   5                                                   mV_Value = mV_Value - mV_Zero_offset;
 916   5                                                      }
 917   4                                                 else
 918   4                                                  {
 919   5                                                       mV_Value = mV_Zero_offset -mV_Value;
 920   5                                                       AV_COD = 0;
 921   5                                                      }
 922   4                                      }
 923   3                                else if((NG_COD == 1)&&(AV_COD == 0))
 924   3                                  {
 925   4                                                   mV_Value = mV_Value + mV_Zero_offset;
 926   4                                  }                   
 927   3                                else if((NG_COD == 0)&&(AV_COD == 1))
 928   3                                  {
 929   4                                                   mV_Value = mV_Value + mV_Zero_offset;
 930   4                                  }   
 931   3                                else if((NG_COD == 0)&&(AV_COD == 0))
 932   3                                  {
 933   4                                             if( mV_Value >= mV_Zero_offset)
 934   4                                                  {
 935   5                                                   mV_Value = mV_Value - mV_Zero_offset;
 936   5                                                      }
 937   4                                                 else
 938   4                                                  {
 939   5                                                       mV_Value = mV_Zero_offset -mV_Value;
 940   5                                                   AV_COD = 1 ;
 941   5                                                      }
 942   4                                      }
 943   3                                         if(mV_Span_offset > 0x0c80)
 944   3                                               { mV_Value = mV_Value + (mV_Value/mV_Span_Value); }
 945   3                                        else
 946   3                                               { mV_Value = mV_Value - (mV_Value/mV_Span_Value); }
 947   3      
 948   3      //                                      mV_Value = 0x7d00 ;
 949   3      //                                              mV_Value = 0 ;
C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 27  

 950   3                       
 951   3                                      mV_Value = mV_Value/3.2;
 952   3      //                      mV_Value = mV_Value/5.29;
 953   3                              if(OVER_COD == 1) mV_Value = 0xffff;     
 954   3                       }
 955   2                 if (Soft_Timer[DISPLAY_SEND_TIME] == 0)
 956   2                   {
 957   3                          LED_Disp(1,mV_Value);
 958   3                          Soft_Timer[DISPLAY_SEND_TIME] = 8 ;
 959   3      
 960   3                               if ((mV_Value > alarm_Low_set)&&(mV_Value < alarm_Hi_set))
 961   3                        { BEEP_OUT = 1; }
 962   3                              else
 963   3                                { BEEP_OUT = 0; }
 964   3                   }
 965   2                 if (Soft_Timer[MV_SEND_TIME] == 0)
 966   2                   {
 967   3                         if( P04 == 0)  Set_mV(mV_Value);
 968   3                         if( P05 == 0)  Set_mA(mV_Value);
 969   3      
 970   3                         Soft_Timer[MV_SEND_TIME] = 2;
 971   3                       }
 972   2                if (Soft_Timer[RTC_READ_TIME] == 0)
 973   2                  {
 974   3                        RTC_READ_SET();
 975   3                        Soft_Timer[RTC_READ_TIME] = 8 ;
 976   3                      }
 977   2                 if (Soft_Timer[UART_SEND_TIME] == 0)
 978   2                   {
 979   3                         if(tran == 0)
 980   3                          {
 981   4                              SBUF = mV_Value ;
 982   4                               tran = 1 ;
 983   4                               Soft_Timer[UART_SEND_TIME] = 1;
 984   4                     }
 985   3                   else
 986   3                    { 
 987   4                      SBUF = mV_Value >> 8 ;
 988   4                      tran = 0;
 989   4                              Soft_Timer[UART_SEND_TIME] = 59 ;
 990   4                        }
 991   3                      TI = 1;
 992   3                       }
 993   2                }
 994   1               return mV_Value ;
 995   1      }
 996          /***********************************************
 997          
 998          *************************************************/
 999          unsigned int DO_mA_TYPE(void)
1000          {
1001   1           unsigned int mA_Value;
1002   1               unsigned char key;
1003   1      
1004   1            key = Get_Key();
1005   1               
1006   1                if(key == 0x01)
1007   1                  {
1008   2                    Func_Type = 4 ;
1009   2                  }
1010   1                else 
1011   1                  {
C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 28  

1012   2                       if (Soft_Timer[ADC_READ_TIME] == 0) 
1013   2                         {
1014   3                                   Soft_Timer[ADC_READ_TIME] = 16;
1015   3      
1016   3                                       mA_Value = Read_AD3421_Value();
1017   3      
1018   3                               if((NG_COD == 1)&&(AV_COD == 1))
1019   3                                 {
1020   4                                                if( mA_Value >= mA_Zero_offset)
1021   4                                                  {
1022   5                                                   mA_Value = mA_Value - mA_Zero_offset;
1023   5                                                      }
1024   4                                                 else
1025   4                                                  {
1026   5                                                       mA_Value = mA_Zero_offset -mA_Value;
1027   5                                                       AV_COD = 0;
1028   5                                                      }
1029   4                                      }
1030   3                                else if((NG_COD == 1)&&(AV_COD == 0))
1031   3                                  {
1032   4                                                   mA_Value = mA_Value + mA_Zero_offset;
1033   4                                  }                   
1034   3                                else if((NG_COD == 0)&&(AV_COD == 1))
1035   3                                  {
1036   4                                                   mA_Value = mA_Value + mA_Zero_offset;
1037   4                                  }   
1038   3                                else if((NG_COD == 0)&&(AV_COD == 0))
1039   3                                  {
1040   4                                             if( mA_Value >= mA_Zero_offset)
1041   4                                                  {
1042   5                                                   mA_Value = mA_Value - mA_Zero_offset;
1043   5                                                      }
1044   4                                                 else
1045   4                                                  {
1046   5                                                       mA_Value = mA_Zero_offset -mA_Value;
1047   5                                                   AV_COD = 1 ;
1048   5                                                      }
1049   4                                      }
1050   3                                         if(mA_Span_offset >  0x1900)
1051   3                                               { mA_Value = mA_Value + (mA_Value/mA_Span_Value); }
1052   3                                        else
1053   3                                               { mA_Value = mA_Value - (mA_Value/mA_Span_Value); }
1054   3      
1055   3                                       mA_Value = mA_Value/3.2 ;
1056   3      
1057   3                                       if(OVER_COD == 1) mA_Value = 0xffff;
1058   3                        }
1059   2                 if (Soft_Timer[DISPLAY_SEND_TIME] == 0)
1060   2                   {
1061   3                          LED_Disp(1,mA_Value);
1062   3                          Soft_Timer[DISPLAY_SEND_TIME] = 16 ;
1063   3      
1064   3                               if ((mA_Value > alarm_Low_set)&&(mA_Value < alarm_Hi_set))
1065   3                        { BEEP_OUT = 1; }
1066   3                              else
1067   3                                { BEEP_OUT = 0; }
1068   3                   }
1069   2                 if (Soft_Timer[MV_SEND_TIME] == 0)
1070   2                   {
1071   3                         if( P04 == 0)  Set_mV(mA_Value);
1072   3                         if( P05 == 0)  Set_mA(mA_Value);
1073   3      
C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 29  

1074   3                         Soft_Timer[MV_SEND_TIME] = 2;
1075   3                       }
1076   2                 if (Soft_Timer[RTC_READ_TIME] == 0)
1077   2                  {
1078   3                        RTC_READ_SET();
1079   3                        Soft_Timer[RTC_READ_TIME] = 8 ;
1080   3                      }
1081   2                 if (Soft_Timer[UART_SEND_TIME] == 0)
1082   2                   {
1083   3                         if(tran == 0)
1084   3                          {
1085   4                              SBUF = mA_Value ;
1086   4                               tran = 1 ;
1087   4                               Soft_Timer[UART_SEND_TIME] = 1;
1088   4                     }
1089   3                   else
1090   3                    { 
1091   4                      SBUF = mA_Value >> 8 ;
1092   4                      tran = 0;
1093   4                              Soft_Timer[UART_SEND_TIME] = 59 ;
1094   4                        }
1095   3                      TI = 1;
1096   3                       }
1097   2               }
1098   1        return mA_Value;
1099   1      }
1100          /*************************************************/
1101          unsigned int Read_AD3421_Value(void)
1102          {
1103   1         unsigned int  AD3421_Value;
1104   1         unsigned char ssta;
1105   1      
1106   1                       ssta = Get_AD3421_Value();
1107   1                if (ssta == 0)
1108   1                  {
1109   2                               AD_Hi =  AD_Hi & 0x03;
1110   2                    if(AD_Hi >= 2)
1111   2                         {
1112   3                            AV_COD = 1;
1113   3                                AD3421_Value = AD_Hi & 0x03;    
1114   3                                AD3421_Value = AD3421_Value << 8 ;
1115   3                                AD3421_Value = AD3421_Value + AD_Mid ;
1116   3                                AD3421_Value = AD3421_Value << 7 ;
1117   3                                AD_Lo = AD_Lo >> 1;
1118   3                                AD3421_Value = AD3421_Value + AD_Lo ;  
1119   3                                AD3421_Value = ~ AD3421_Value; 
1120   3                                if( AD3421_Value >= 0xf000){OVER_COD = 1;} else{OVER_COD = 0;}
1121   3                         }
1122   2                        else
1123   2                         {
1124   3                                AV_COD = 0;
1125   3                                AD3421_Value = AD_Hi & 0x03;    
1126   3                                AD3421_Value = AD3421_Value << 8 ;
1127   3                                AD3421_Value = AD3421_Value + AD_Mid ;
1128   3                                AD3421_Value = AD3421_Value << 7 ;
1129   3                                AD_Lo = AD_Lo >> 1;
1130   3                                AD3421_Value = AD3421_Value + AD_Lo;
1131   3                                if( AD3421_Value >= 0xf000){OVER_COD = 1;} else{OVER_COD = 0;}
1132   3                         }
1133   2                 }
1134   1         return AD3421_Value;
1135   1      }
C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 30  

1136          /*************************************************/     
1137          void DO_SETUP_TYPE(void)
1138          {
1139   1              unsigned char set_key = 0, times = 0, Itemm = 0; 
1140   1              unsigned char item_key,confrom_key, up_key,don_key;
1141   1              unsigned int  value_cal = 0;
1142   1              
1143   1      
1144   1                    SETUP_LED_Disp(Itemm,value_cal);
1145   1      
1146   1                         while (CAIT)
1147   1                                  {
1148   2                                     set_key = Get_Key();
1149   2      
1150   2                                                            if((set_key & 0x01) == 1)
1151   2                                                              { item_key = 1 ;}
1152   2                                                             else
1153   2                                                              { item_key = 0 ;}
1154   2      
1155   2                                                            if((set_key & 0x02) == 2)
1156   2                                                              {confrom_key = 1 ;}
1157   2                                                             else
1158   2                                                              { confrom_key = 0 ;}
1159   2      
1160   2                                                            if((set_key & 0x04) == 4)
1161   2                                                              { up_key = 1 ;}
1162   2                                                             else
1163   2                                                              { up_key = 0 ;}
1164   2      
1165   2                                                if((set_key & 0x08) == 8)
1166   2                                                              { don_key = 1 ;}
1167   2                                                              else
1168   2                                                              { don_key = 0 ;}
1169   2      
1170   2                                                         if (item_key == 1) 
1171   2                                                           {
1172   3                                                                Itemm ++;
1173   3                                                                times=0;
1174   3                                                               }
1175   2                                                         if (Itemm > 0x13)
1176   2                                                               {
1177   3                                                                   Itemm = 0; 
1178   3                                                                       CAIT = 0;
1179   3                                                               } 
1180   2                                                        if(up_key == 1)   value_cal++;
1181   2                                                        if(don_key == 1)  value_cal--;
1182   2      
1183   2      
1184   2                                                 if (Soft_Timer[ADC_READ_TIME] == 0) 
1185   2                                                   {
1186   3                                                        Soft_Timer[ADC_READ_TIME] = 4 ;
1187   3                                                     Data_Value[t_code] = Read_AD3421_Value();
1188   3                                                                  if(t_code < 12)
1189   3                                                                        {t_code++;}
1190   3                                                                        else
1191   3                                                                         {
1192   4                                                                          Data_Value[14] = (Data_Value[12]/5+Data_Value[11]/5+Data_Value[10]/5+Data_Value[9]/5+Data_Valu
             -e[8]/5);
1193   4                                                                              t_code = 8 ;
1194   4                                                                         }
1195   3                                                        }
1196   2                                                  else
C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 31  

1197   2                                                    {
1198   3                                                            Data_Value[14] = Data_Value[t_code] ;
1199   3                                                        }
1200   2                              if (Itemm == MODE_CAL)                  //tc,rtd,mV,mA
1201   2                                {
1202   3                                                          SETUP_LED_Disp(Itemm,Work_Type);
1203   3                                                                 Work_Type = Work_Type + value_cal;
1204   3                                                                   value_cal = 0;
1205   3                                                                if(Work_Type >= 4)
1206   3                                                                  {
1207   4                                                                       Work_Type = 0;
1208   4                                                                       value_cal = 0;
1209   4                                                                      }        
1210   3                                                                if(confrom_key == 1)
1211   3                                                                  { 
1212   4                                                                        EEPROM_write_byte(Mode_Select,Work_Type);
1213   4                                                                        SETUP_LED_Disp(22,0);
1214   4                                                                        delay(2500);
1215   4                                                                        times ++;
1216   4                                                                      }
1217   3                                              }
1218   2                                      else if (Itemm == C_F_CAL)
1219   2                                  {
1220   3                                               if (Work_Type >= 2) {Itemm = Itemm + 1;}
1221   3                                              else{   SETUP_LED_Disp(Itemm,C_F_Type);
1222   4                                                                C_F_Type = C_F_Type + value_cal;
1223   4                                                                  value_cal = 0;
1224   4                                                             
1225   4                                                                 if(C_F_Type >= 2 )
1226   4                                                                         {
1227   5                                                                          C_F_Type = 0 ;
1228   5                                                                          value_cal = 0;
1229   5                                                                         }
1230   4                                                                 if(confrom_key == 1)
1231   4                                                                  { 
1232   5                                                                         EEPROM_write_byte(C_F_Select,C_F_Type);  //C,F
1233   5                                                                         times ++; SETUP_LED_Disp(22,0);delay(2500);
1234   5                                                                      }
1235   4                                                         }
1236   3                                              }
1237   2                               else if (Itemm == TYPE_CAL)
1238   2                                  {
1239   3                                                  if (Work_Type != 0)
1240   3                                                        {     Itemm = Itemm + 1;}
1241   3                                                      else{   TC_Type = TC_Type + value_cal; 
1242   4                                                                        value_cal = 0;
1243   4                                                                if (TC_Type >= 6)
1244   4                                                                  {
1245   5                                                                    TC_Type = 0 ;
1246   5                                                                        value_cal = 0;
1247   5                                                                  }              
1248   4                                                                   SETUP_LED_Disp(Itemm,TC_Type);
1249   4      
1250   4                                                                      if(confrom_key == 1)
1251   4                                                                   {
1252   5                                                                         EEPROM_write_byte(Type_Select,TC_Type);  //K,J,T,E,R,B,S
1253   5                                                                         times ++; SETUP_LED_Disp(22,0);delay(2500);
1254   5                                                                       }
1255   4                                                           }
1256   3                                               }              
1257   2                                      else if (Itemm == TC_ZERO_CAL)
1258   2                                                {
C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 32  

1259   3                                                 if (Work_Type != 0){ Itemm = Itemm + 1;}
1260   3                                               else{
1261   4                                                                 SETUP_LED_Disp(Itemm, Data_Value[14]);
1262   4                                                                 if(confrom_key == 1)
1263   4                                                                  {
1264   5                                                                        Temp_Flag = 3 ;
1265   5                                                                        Temp_offset = Temp_m;
1266   5                                                                       if ((Temp_m*24)/10 >= Data_Value[14])
1267   5                                                                         {
1268   6                                                                           if( AV_COD == 1)
1269   6                                                                             { TC_Zero_offset = (Temp_m*24)/10 + Data_Value[14]; NG_COD = 1;use_flag = use_flag|0x01;}
1270   6                                                                           else{ TC_Zero_offset = (Temp_m*24)/10 - Data_Value[14]; NG_COD = 1;use_flag = use_flag|0x01;}
1271   6                                                                         }
1272   5                                                                       else
1273   5                                                                         {  
1274   6                                                                               if( AV_COD == 1)
1275   6                                                                             { TC_Zero_offset = Data_Value[14] + (Temp_m*24)/10 ;  NG_COD = 1;use_flag = use_flag|0x01;}
1276   6                                                                           else {TC_Zero_offset = Data_Value[14] - (Temp_m*24)/10;  NG_COD = 0;use_flag = use_flag&0xfe;
             -}
1277   6                                                                         }
1278   5                                                                        EEPROM_write_byte(Status_flag,(use_flag));
1279   5                                                                        EEPROM_write_word(TC_Zero,TC_Zero_offset); 
1280   5                                                                        EEPROM_write_word(60,Temp_offset);                                                                              
1281   5                                                                  delay(50);
1282   5                                                                      times ++; SETUP_LED_Disp(22,0);delay(2500);
1283   5                                                                }
1284   4                                                       }
1285   3                                               }
1286   2                            else if (Itemm == TC_SPAN_CAL)
1287   2                                  {
1288   3                                                if (Work_Type != 0) { Itemm = Itemm + 1; }
1289   3                                               else
1290   3                                                {
1291   4                                                 SETUP_LED_Disp(Itemm,Data_Value[14]);
1292   4                                                if(confrom_key == 1)
1293   4                                                  { 
1294   5                                                       if( NG_COD == 1)
1295   5                                                          {TC_Span_offset = Data_Value[14] + TC_Zero_offset;}
1296   5                                                  else {TC_Span_offset = Data_Value[14] - TC_Zero_offset;}
1297   5                                                              EEPROM_write_word(TC_Span,TC_Span_offset);  
1298   5      
1299   5                                                   if(TC_Span_offset >= 0xc8ca )
1300   5                                                         { TC_Span_Value = (TC_Span_offset + TC_Zero_offset) /(TC_Span_offset - 0xc8ca);use_flag = use_fla
             -g|0x10;}
1301   5                                                       else
1302   5                                                         { TC_Span_Value = (TC_Span_offset + TC_Zero_offset) /(0xc8ca - TC_Span_offset);use_flag = use_fla
             -g&0xef;}
1303   5      
1304   5                                                                          EEPROM_write_word(TC_Span_Per,TC_Span_Value);
1305   5                                                                              delay(50);
1306   5                                                                              EEPROM_write_byte(Status_flag,use_flag);
1307   5                                                                        times ++; SETUP_LED_Disp(22,0);delay(2500);
1308   5                                                        }
1309   4                                                        }
1310   3                                                 }
1311   2                            else if (Itemm == RTD_ZERO_CAL)
1312   2                                    {
1313   3                                                  if (Work_Type != 1) {       Itemm = Itemm + 1;}
1314   3                                                      else{
1315   4                                                               if( AV_COD == 1){ NG_COD = 1;}else{ NG_COD = 0;}
1316   4                                                                SETUP_LED_Disp(Itemm,Data_Value[14]);
1317   4                                                                if(confrom_key == 1)
C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 33  

1318   4                                                                  {
1319   5                                                                        RTD_Zero_offset = Data_Value[14] ;
1320   5                                                                       EEPROM_write_word(RTD_Zero,RTD_Zero_offset);  //rtd
1321   5                                                                        delay(50);
1322   5                                                                       if( NG_COD == 1){ EEPROM_write_byte(Status_flag,(use_flag|0x02));}
1323   5                                                                       else { EEPROM_write_byte(Status_flag,(use_flag&0xfd));}
1324   5                                                                        times ++; SETUP_LED_Disp(22,0);delay(2500);
1325   5                                                                      }
1326   4                                                          }
1327   3                                                }
1328   2                                 else if (Itemm == RTD_SPAN_CAL)
1329   2                                    {
1330   3                                                  if (Work_Type != 1) {Itemm = Itemm + 1;}
1331   3                                                      else{    
1332   4                                                                SETUP_LED_Disp(Itemm,Data_Value[14]);
1333   4                                                                if(confrom_key == 1)
1334   4                                                                  {
1335   5                                                                       RTD_Span_offset = Data_Value[14] ;
1336   5                                                                       EEPROM_write_word(RTD_Span,RTD_Span_offset);  //rtd
1337   5      
1338   5                                                                       if( NG_COD == 1)
1339   5                                                                         { if ((RTD_Span_offset + RTD_Zero_offset) > 0x44e4 )
1340   6                                                                              { RTD_Span_Value = ((RTD_Span_offset + RTD_Zero_offset)/((RTD_Span_offset + RTD_Zero_offse
             -t)-0x44e4));}
1341   6                                                                               else
1342   6                                                                                 { RTD_Span_Value = ((RTD_Span_offset + RTD_Zero_offset)/(0x44e4 - (RTD_Span_offset + RTD_Zero_
             -offset)));}
1343   6                                                                         }
1344   5                                                                       else
1345   5                                                                         { if ((RTD_Span_offset - RTD_Zero_offset) > 0x44e4 )
1346   6                                                                              { RTD_Span_Value = ((RTD_Span_offset - RTD_Zero_offset)/((RTD_Span_offset - RTD_Zero_offse
             -t)-0x44e4));}
1347   6                                                                               else
1348   6                                                                                  { RTD_Span_Value = ((RTD_Span_offset - RTD_Zero_offset)/(0x44e4 - (RTD_Span_offset - RTD_Zero
             -_offset)));}
1349   6                                                                         }
1350   5                                                                          EEPROM_write_word(RTD_Span_Per,RTD_Span_Value);
1351   5                                                                       times ++;      SETUP_LED_Disp(22,0);delay(2500);
1352   5                                                                      }
1353   4                                                         }
1354   3                                               }
1355   2                                  else if (Itemm == mV_ZERO_CAL)
1356   2                                     {
1357   3                                                  if (Work_Type != 2)   {     Itemm = Itemm + 1;}
1358   3                                                      else{
1359   4                                                               if( AV_COD == 1){ NG_COD = 1;}else{ NG_COD = 0;}
1360   4                                                                SETUP_LED_Disp(Itemm,Data_Value[14]);
1361   4                                                                if(confrom_key == 1)
1362   4                                                                  {
1363   5                                                                       mV_Zero_offset = Data_Value[14] ;
1364   5                                                                       EEPROM_write_word(mV_Zero,mV_Zero_offset);  
1365   5                                                                        delay(50);
1366   5                                                                       if( NG_COD == 1){ EEPROM_write_byte(Status_flag,(use_flag|0x04));}
1367   5                                                                       else { EEPROM_write_byte(Status_flag,(use_flag&0xfb));}
1368   5                                                                       times ++; SETUP_LED_Disp(22,0);        delay(2500);
1369   5                                                                      }
1370   4                                                         }
1371   3                                                }
1372   2                                  else if (Itemm == mV_SPAN_CAL)
1373   2                                       {
1374   3                                                         if (Work_Type != 2) {        Itemm = Itemm + 1;}
1375   3                                                        else{ 
C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 34  

1376   4                                                                SETUP_LED_Disp(Itemm,Data_Value[14]);
1377   4                                                                if(confrom_key == 1)
1378   4                                                                  {
1379   5                                                                        mV_Span_offset = Data_Value[14] ;
1380   5      
1381   5                                                                       EEPROM_write_word(mV_Span,mV_Span_offset);  
1382   5      
1383   5                                                                       if( NG_COD == 1)
1384   5                                                                         { if ((mV_Span_offset + mV_Zero_offset) > 0x7d00 )            
1385   6                                                                              { mV_Span_Value = ((mV_Span_offset + mV_Zero_offset)/((mV_Span_offset + mV_Zero_offset)-0x
             -7d00));}
1386   6                                                                               else
1387   6                                                                                  { mV_Span_Value = ((mV_Span_offset + mV_Zero_offset)/(0x7d00 - (mV_Span_offset + mV_Zero_offs
             -et)));}
1388   6                                                                         }
1389   5                                                                       else
1390   5                                                                         { if ((mV_Span_offset - mV_Zero_offset) > 0x7d00)
1391   6                                                                              { mV_Span_Value = ((mV_Span_offset - mV_Zero_offset)/((mV_Span_offset - mV_Zero_offset)-0x
             -7d00));}
1392   6                                                                               else
1393   6                                                                                  { mV_Span_Value = ((mV_Span_offset - mV_Zero_offset)/(0x7d00 - (mV_Span_offset - mV_Zero_offs
             -et)));}
1394   6                                                                         }
1395   5                                                                          EEPROM_write_word(mV_Span_Per,mV_Span_Value);
1396   5                                                                       times ++;      SETUP_LED_Disp(22,0);delay(2500);
1397   5                                                                      }
1398   4                                                         }
1399   3                                               }
1400   2                                 else if (Itemm == mA_ZERO_CAL)
1401   2                                     {
1402   3                                                   if (Work_Type != 3)  {     Itemm = Itemm + 1;}
1403   3                                                      else{
1404   4                                                                if( AV_COD == 1){ NG_COD = 1;}else{ NG_COD = 0;}
1405   4                                                                SETUP_LED_Disp(Itemm,Data_Value[14]);
1406   4                                                                if(confrom_key == 1)
1407   4                                                                  {
1408   5                                         delay(50);
1409   5                                                                       mA_Zero_offset = Data_Value[14];
1410   5                                                                       EEPROM_write_word(mA_Zero,mA_Zero_offset);  
1411   5                                                                         delay(50);
1412   5                                                                      if( NG_COD == 1){ EEPROM_write_byte(Status_flag,(use_flag|0x08));}
1413   5                                                                       else { EEPROM_write_byte(Status_flag,(use_flag&0xf7));}
1414   5                                                                       times ++; SETUP_LED_Disp(22,0);delay(25000);
1415   5                                                                      }
1416   4                                                         }
1417   3                                               }
1418   2                                  else if (Itemm == mA_SPAN_CAL)
1419   2                                      {
1420   3                                                        if (Work_Type != 3)  {Itemm = Itemm + 1;}
1421   3                                                      else{
1422   4                                                               SETUP_LED_Disp(Itemm,Data_Value[14]);
1423   4                                                                if(confrom_key == 1)
1424   4                                                                  {
1425   5                                                                       mA_Span_offset = Data_Value[14]; 
1426   5                                                                       EEPROM_write_word(mA_Span,mA_Span_offset);  
1427   5                                                                       delay(50);
1428   5                                                                       if( NG_COD == 1)
1429   5                                                                         { if ((mA_Span_offset + mA_Zero_offset) > 0x1900 )   
1430   6                                                                              { mA_Span_Value = ((mA_Span_offset + mA_Zero_offset)/((mA_Span_offset + mA_Zero_offset)- 0
             -x1900));}
1431   6                                                                               else
1432   6                                                                                  { mA_Span_Value = ((mA_Span_offset + mA_Zero_offset)/( 0x1900 - (mA_Span_offset + mA_Zero_off
C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 35  

             -set)));}
1433   6                                                                         }
1434   5                                                                       else
1435   5                                                                         { if ((mA_Span_offset - mA_Zero_offset) > 0x1900 )
1436   6                                                                              { mA_Span_Value = ((mA_Span_offset - mA_Zero_offset)/((mA_Span_offset - mA_Zero_offset)- 0
             -x1900));}
1437   6                                                                               else
1438   6                                                                                  { mA_Span_Value = ((mA_Span_offset - mA_Zero_offset)/( 0x1900 - (mA_Span_offset - mA_Zero_off
             -set)));}
1439   6                                                                         }
1440   5                                                                               EEPROM_write_word(mA_Span_Per,mA_Span_Value);
1441   5                                                                           times ++; SETUP_LED_Disp(22,0);    delay(2500);
1442   5                                                                      }
1443   4                                                         }
1444   3                                                 }
1445   2                                               
1446   2                                 else if (Itemm == ALARM_LO_CAL)
1447   2                                       {
1448   3                                     alarm_Low_set = alarm_Low_set + value_cal*10 ;
1449   3                                                                                value_cal = 0;
1450   3                                                                SETUP_LED_Disp(Itemm,alarm_Low_set);
1451   3                                                                if((up_key == 1)||(don_key == 1))
1452   3                                                                  {
1453   4                                                                   if(alarm_Low_set > 9999){value_cal = 0;alarm_Low_set = 0;}
1454   4                                                                       if(confrom_key == 1)
1455   4                                                                    {
1456   5                                                              EEPROM_write_word(Alarm_Low,alarm_Low_set);  //alarm
1457   5                                                                              times ++; SETUP_LED_Disp(22,0);delay(2500);
1458   5                                                                        } 
1459   4                                                                  }
1460   3                                                      }
1461   2                                   else if (Itemm == ALARM_HI_CAL)
1462   2                                      { 
1463   3                                                                 alarm_Hi_set = alarm_Hi_set + value_cal*10 ;
1464   3                                                                  value_cal = 0;
1465   3                                                                 SETUP_LED_Disp(Itemm,alarm_Hi_set);
1466   3                                                                if((up_key == 1)||(don_key == 1))
1467   3                                                                  {
1468   4                                                                        if(alarm_Hi_set > 9999){value_cal = 0;alarm_Hi_set = 0;}
1469   4      
1470   4                                                                        if(confrom_key == 1)
1471   4                                                                    {
1472   5                                                              EEPROM_write_word(Alarm_Hi,alarm_Hi_set);  //alarm
1473   5                                                                              times ++; SETUP_LED_Disp(22,0);delay(2500);
1474   5                                                                        }
1475   4                                                                  }
1476   3                                                      }
1477   2                                   else if (Itemm == YEAR_DATE_CAL)
1478   2                                      {   
1479   3                                                         if(value_cal >= 200)
1480   3                                                           {
1481   4                                                                 if(use_year == 0) {use_year = 0x99; value_cal = 0 ;}
1482   4                                                                 else
1483   4                                                                  { if((use_year&0x0f) == 0){use_year = (((use_year-0x10)&0xf0)|0x09); value_cal = 0 ; }
1484   5                                                                        else { use_year = use_year -0x01; value_cal = 0 ;}
1485   5                                                                  }
1486   4                                                               }
1487   3                                                              else
1488   3                                                               {
1489   4                                                                if(value_cal == 1) 
1490   4                                                                 {
1491   5                                                                    if(use_year >= 0x9a) { use_year = 0; value_cal = 0;}
C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 36  

1492   5                                                                       else{if((use_year&0x0f) == 0x09) {use_year = ((use_year+0x10)&0xf0);value_cal = 0; } 
1493   6                                                                            else { use_year = use_year + 0x01; value_cal = 0;} } 
1494   5                                                             } 
1495   4                                                                }     
1496   3                                                        SETUP_LED_Disp(Itemm,use_year + 0x2000);
1497   3                                                                                                                                               
1498   3                                                               if(confrom_key == 1)
1499   3                                                                 {
1500   4                                                                    RTC_write_byte(6,use_year);
1501   4                                                                      EEPROM_write_byte(Year_Date,use_year); 
1502   4                                                                              times ++;SETUP_LED_Disp(22,0);delay(2500);
1503   4                                                                 }
1504   3                                                           
1505   3                                                 }
1506   2                                 else if (Itemm == MON_DATE_CAL)
1507   2                                     {
1508   3                                                     if(value_cal >= 200)
1509   3                                                           {
1510   4                                                                 if(use_mon <= 0x01){use_mon = 0x12; value_cal = 0 ;}
1511   4                                                            else
1512   4                                                                 { if((use_mon&0x0f) == 0) {use_mon = (((use_mon-0x10)&0xf0)|0x09); value_cal = 0 ; }
1513   5                                                                           else{use_mon = use_mon - 0x01; value_cal = 0 ;}
1514   5                                                                 }
1515   4                                                               }
1516   3                                                        else
1517   3                                                               {
1518   4                                                                if(value_cal == 1) 
1519   4                                                                  {
1520   5                                                                        if(use_mon == 0x12){use_mon = 0x01; value_cal = 0 ;}
1521   5                                                                       else {if((use_mon&0x0f) == 0x09) {use_mon = ((use_mon+0x10)&0xf0); value_cal = 0;}
1522   6                                                                          else { use_mon = use_mon + 0x01; value_cal = 0 ;}}
1523   5                                                                      }
1524   4                                                               }
1525   3                                                                SETUP_LED_Disp(Itemm,use_mon);
1526   3      
1527   3                                                               if(confrom_key == 1)
1528   3                                                                 {
1529   4                                                                   RTC_write_byte(5,use_mon);
1530   4                                                                       EEPROM_write_byte(Mon_Date,use_mon);
1531   4                                                                       times ++;  SETUP_LED_Disp(22,0);delay(2500);
1532   4                                                                 }
1533   3                                                      }
1534   2                                 else if (Itemm == DAY_DATE_CAL)                      //add week setup
1535   2                                    {
1536   3                                                       if(value_cal >= 200)
1537   3                                                         {
1538   4                                                           if((use_day == 1)&&(use_mon == 0x02)&&(use_year%4 == 0)) { use_day = 0x29 ;  value_cal = 0 ; }
1539   4                                                          else if((use_day == 1)&&(use_mon == 0x02)&&(use_year%4 != 0)) { use_day = 0x28 ; value_cal = 0 ;
             - }
1540   4                                                          else if((use_day == 1)&&((use_mon == 1)||(use_mon == 3)||(use_mon == 5)||(use_mon == 7)||(use_mo
             -n == 0x08)||(use_mon ==0x10)||(use_mon == 0x12))) { use_day =0x31;value_cal = 0;}
1541   4                                                          else if((use_day == 1)&&((use_mon == 4)||(use_mon == 6)||(use_mon == 0x09)||(use_mon == 0x11))) 
             -{ use_day = 0x30 ;  value_cal = 0 ; }
1542   4                                                              else if((use_day&0x0f) == 0) {use_day = (((use_day-0x10)&0xf0)|0x09);value_cal = 0;}
1543   4                                                               else {use_day = use_day -1; value_cal = 0;}
1544   4                                                        }
1545   3                                                 else
1546   3                                                       {
1547   4                                                       if(value_cal == 1)
1548   4                                                         {
1549   5                                                               if((use_mon == 2)&&(use_year%4 == 0)&&(use_day == 0x29)) { use_day = 1; value_cal = 0;}
1550   5                                                              else if((use_mon == 2)&&(use_year%4 != 0)&&(use_day == 0x28)) { use_day = 1; value_cal = 0;}
C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 37  

1551   5                                                              else if(((use_mon == 1)||(use_mon == 3)||(use_mon == 5)||(use_mon == 7)||(use_mon == 8)||(use_mon =
             -= 0x10)||(use_mon == 0x12))&&(use_day == 0x31)) { use_day = 1;value_cal = 0;}
1552   5                                                              else if(((use_mon == 4)||(use_mon == 6)||(use_mon == 9)||(use_mon == 0x11))&&(use_day == 0x30)) { u
             -se_day = 1; value_cal = 0;}
1553   5                                                              else if((use_day&0x0f) == 0x09) {use_day = ((use_day + 0x10)&0xf0); value_cal = 0;}
1554   5                                                                 else{use_day = use_day + 1; value_cal = 0;}                 
1555   5                                                         }
1556   4                                                       }
1557   3                                               SETUP_LED_Disp(Itemm,use_day);
1558   3      
1559   3                                                       if(confrom_key == 1)
1560   3                                                         {
1561   4                                                           RTC_write_byte(4,use_day);
1562   4                                                               EEPROM_write_byte(Day_Date,use_day);
1563   4                                                                       times ++;      SETUP_LED_Disp(22,0);delay(250);
1564   4                                                         }
1565   3                                              }
1566   2                                else if (Itemm == HOUR_DATE_CAL)
1567   2                                   {
1568   3                                                        if(value_cal >= 200)
1569   3                                                         {
1570   4                                                          if (use_hour == 0){use_hour = 0x23; value_cal = 0;}
1571   4                                                          else 
1572   4                                                               { if((use_hour&0x0f) == 0x00) {use_hour = ((use_hour-0x10)&0xf0)|0x09; value_cal = 0;}  
1573   5                                                                 else {use_hour = use_hour - 0x01; value_cal = 0;}
1574   5                                                               }
1575   4                                                         }
1576   3                                                       else
1577   3                                                         {
1578   4                                                          if(value_cal == 1)
1579   4                                                           {
1580   5                                                                 if(use_hour == 0x23) {use_hour = 0; value_cal = 0;}
1581   5                                                                 else
1582   5                                                                  { if((use_hour&0x0f) == 0x09) {use_hour = (use_hour+0x10)&0xf0; value_cal = 0;}
1583   6                                                                        else {use_hour = use_hour + 0x01; value_cal = 0;}
1584   6                                                                      }    
1585   5                                                               }
1586   4                                                          }
1587   3                                                         SETUP_LED_Disp(Itemm,use_hour);
1588   3                                                         if(confrom_key == 1)
1589   3                                                               {
1590   4                                                                   RTC_write_byte(2,use_hour);
1591   4                                                                      EEPROM_write_byte(Hour_Date,use_hour);
1592   4                                                                       times ++;      SETUP_LED_Disp(22,0);delay(250);
1593   4                                                               }
1594   3                                               }
1595   2                             else if (Itemm == MIN_DATE_CAL)
1596   2                                   {
1597   3                                                   if(value_cal >= 200)
1598   3                                                         {
1599   4                                                           if(use_min == 0) { use_min = 0x59; value_cal = 0;}
1600   4                                                              else 
1601   4                                                               {
1602   5                                                                  if((use_min&0x0f) == 0) {use_min = ((use_min - 0x10)&0xf0)|0x09; value_cal = 0;} 
1603   5                                                                 else { use_min = use_min - 0x01; value_cal = 0;}
1604   5                                                               }
1605   4                                                        }
1606   3                                                      else
1607   3                                                        {     
1608   4                                                           if (value_cal == 1) 
1609   4                                                                 {
1610   5                                                                    if(use_min == 0x59) {use_min = 0; value_cal = 0;}
C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 38  

1611   5                                                                        else
1612   5                                                                         {  if((use_min&0x0f) == 0x09) {use_min = (use_min+0x10)&0xf0; value_cal = 0;}
1613   6                                                                            else { use_min = use_min + 0x01; value_cal = 0;}
1614   6                                                                         }
1615   5                                                                 }
1616   4                                                        }
1617   3                                          SETUP_LED_Disp(Itemm,use_min );
1618   3                                                        if(confrom_key == 1)
1619   3                                                          {
1620   4                                                                   RTC_write_byte(1,use_min );
1621   4                                                                       EEPROM_write_byte(Min_Date,use_min);
1622   4                                                                       times ++;SETUP_LED_Disp(22,0); delay(250);
1623   4                                                              }
1624   3                                            }
1625   2                                          else if (Itemm >= PRODUCT_RESET)
1626   2                                                 { 
1627   3                                                                Itemm = 0 ;
1628   3                                                                CAIT  = 0 ;
1629   3                                                 }
1630   2                                       }
1631   1                      Check_PCB();                    
1632   1      }
1633          //*******************************
1634          void RTC_ON(void)
1635          { 
1636   1         use_week = RTC_read_byte(0x03);
1637   1         RTC_write_byte(0x07,SQWE);
1638   1         RTC_write_byte(0x03,use_week|0x08);    
1639   1                                   
1640   1          if((use_week&OSC_EN) == OSC_EN) {;}       // if oscillator = already running, do nothing. 
1641   1          else
1642   1               { 
1643   2             RTC_write_byte(0x06,use_year)   ;     // initialize YEAR  register           
1644   2             RTC_write_byte(0x05,use_mon)    ;     // initialize MONTH register  
1645   2             RTC_write_byte(0x04,use_day)    ;     // initialize DATE  register  
1646   2             RTC_write_byte(0x03,use_week|0x08);
1647   2             RTC_write_byte(0x02,use_hour)   ;     // initialize HOUR  register  
1648   2             RTC_write_byte(0x01,use_min)    ;     // initialize MIN   register  
1649   2             RTC_write_byte(0x00,use_sec|0x80) ;
1650   2               } 
1651   1       
1652   1      }
1653          /************************************************/
1654          void RTC_WRITE_SET(void)
1655          {
1656   1      
1657   1         RTC_write_byte(0x00,(use_sec|0x80));
1658   1      
1659   1         RTC_write_byte(0x01,use_min);
1660   1      
1661   1         RTC_write_byte(0x02,use_hour);
1662   1      
1663   1         RTC_write_byte(0x03,use_week|0x08);
1664   1      
1665   1         RTC_write_byte(0x04,use_day);
1666   1      
1667   1         RTC_write_byte(0x05,use_mon);
1668   1      
1669   1         RTC_write_byte(0x06,use_year);
1670   1      
1671   1         RTC_write_byte(0x07,0x40);
1672   1      }
C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 39  

1673          /*****************************************/
1674          void RTC_READ_SET(void)
1675          { 
1676   1       use_sec  = RTC_read_byte(0x00)&0x7f ;
1677   1       use_min  = RTC_read_byte(0x01) ;
1678   1       use_hour = RTC_read_byte(0x02) ;
1679   1       use_week = RTC_read_byte(0x03)&0x07 ;
1680   1       use_day  = RTC_read_byte(0x04);
1681   1       use_mon  = RTC_read_byte(0x05);
1682   1       use_year = RTC_read_byte(0x06);
1683   1      
1684   1       if((use_mon&0x03) == 0x01)
1685   1       { 
1686   2         EEPROM_write_byte(Year_Date,use_year);
1687   2         EEPROM_write_byte(Mon_Date, use_mon);
1688   2         EEPROM_write_byte(Day_Date, use_day);
1689   2         EEPROM_write_byte(Week_Date, use_week);
1690   2         EEPROM_write_byte(Hour_Date,use_hour);
1691   2         EEPROM_write_byte(Min_Date, use_min);
1692   2         EEPROM_write_byte(sec_Date, use_sec);
1693   2       }
1694   1      }
1695          //*******************************
1696          void EEPROM_WriteDefault(void)
1697          {
1698   1          Check_PCB();
1699   1          EEPROM_write_byte(Mode_Select,Work_Type); //setup mode
1700   1          EEPROM_write_byte(C_F_Select, 0);  //c
1701   1              EEPROM_write_byte(Type_Select,0);  //Type define k=0.j=1,t=2
1702   1      
1703   1              EEPROM_write_word(TC_Zero, 0);  
1704   1              EEPROM_write_word(TC_Span, 1400);
1705   1              EEPROM_write_word(RTD_Zero, 0);
1706   1              EEPROM_write_word(RTD_Span, 850);
1707   1              EEPROM_write_word(mV_Zero, 0);
1708   1              EEPROM_write_word(mV_Span, 5000);
1709   1              EEPROM_write_word(mA_Zero, 40); 
1710   1          EEPROM_write_word(mA_Span, 200);
1711   1              EEPROM_write_word(Alarm_Low, 0);
1712   1              EEPROM_write_word(Alarm_Hi, 5000);
1713   1      
1714   1          EEPROM_write_byte(Year_Date,0x15);
1715   1          EEPROM_write_byte(Mon_Date, 0x01);
1716   1          EEPROM_write_byte(Day_Date, 0x01);
1717   1              EEPROM_write_byte(Week_Date,0x04);
1718   1          EEPROM_write_byte(Hour_Date,0x12);
1719   1          EEPROM_write_byte(Min_Date, 0x01);
1720   1              EEPROM_write_byte(sec_Date, 0x01);
1721   1              EEPROM_write_byte(Status_flag, 0);
1722   1              EEPROM_write_word(TC_Span_Per, 1);
1723   1              EEPROM_write_word(RTD_Span_Per, 1);
1724   1              EEPROM_write_word(mV_Span_Per, 1);
1725   1              EEPROM_write_word(mA_Span_Per, 1);
1726   1              EEPROM_write_word(60,0);
1727   1              EEPROM_write_word(EEP_ADR, 64);         //eep start code
1728   1          RTC_ON();
1729   1      }
1730          /*****************************************************/
1731          void DO_RESET_TYPE(void)
1732          {
1733   1           EEPROM_WriteDefault();
1734   1           LED_Fill();                                     //  LED all light
C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 40  

1735   1               Work_Type = EEPROM_read_byte(Mode_Select);
1736   1               C_F_Type = EEPROM_read_byte(C_F_Select);
1737   1               TC_Type = EEPROM_read_byte(Type_Select);       //Type define k=0.j=1,t=2
1738   1               TC_Zero_offset = EEPROM_read_word(TC_Zero);    
1739   1               TC_Span_offset = EEPROM_read_word(TC_Span);
1740   1               RTD_Zero_offset = EEPROM_read_word(RTD_Zero);
1741   1               RTD_Span_offset = EEPROM_read_word(RTD_Span);
1742   1               mA_Zero_offset = EEPROM_read_word(mA_Zero);
1743   1               mA_Span_offset = EEPROM_read_word(mA_Span);
1744   1      
1745   1               mV_Zero_offset = EEPROM_read_word(mV_Zero);    
1746   1           mV_Span_offset = EEPROM_read_word(mV_Span);
1747   1               alarm_Low_set = EEPROM_read_word(Alarm_Low);
1748   1               alarm_Hi_set = EEPROM_read_word(Alarm_Hi);
1749   1           use_year = EEPROM_read_word(Year_Date);
1750   1      
1751   1           use_mon =  EEPROM_read_byte(Mon_Date);
1752   1           use_day =  EEPROM_read_byte(Day_Date);
1753   1               use_week = EEPROM_read_byte(Week_Date);
1754   1           use_hour = EEPROM_read_byte(Hour_Date);
1755   1           use_min =  EEPROM_read_byte(Min_Date);
1756   1               use_sec =  EEPROM_read_byte(sec_Date);
1757   1               use_flag =     EEPROM_read_byte(Status_flag);
1758   1               TC_Span_Value = EEPROM_read_word(TC_Span_Per);
1759   1               RTD_Span_Value = EEPROM_read_word(RTD_Span_Per);
1760   1               mV_Span_Value = EEPROM_read_word(mV_Span_Per);
1761   1               mA_Span_Value = EEPROM_read_word(mA_Span_Per);
1762   1               Temp_offset  = EEPROM_read_word(60);
1763   1      //       eep_count = EEPROM_read_byte(EEP_ADR);
1764   1      }
1765          /***********************************
1766          ****      System_Start          ****
1767          ***********************************/ 
1768          main(void)
1769          {
1770   1         TR0 = 0;
1771   1         TMOD = TMOD |= 0x01;
1772   1         TH0  = 0xDC; //use timer0 to delay 5ms
1773   1         TL0  = 0;
1774   1         TF0  = 0; 
1775   1      
1776   1         IFMT = 0x07 ; //#AUXRA_Rd ;set read AUXRA command
1777   1         SCMD = 0x46; //h
1778   1         SCMD = 0xB9; //h
1779   1         IFD  = IFD |= 0x08; //;
1780   1         IFMT = 0x06;  // #AUXRA_Wr ;set write AUXRA command
1781   1         SCMD = 0x46; // #46h
1782   1         SCMD = 0xB9; //h
1783   1         TR0  = 1 ;  //;timer0 run
1784   1         while( ~TF0 ) 
1785   1            {   }
1786   1         TF0 = 0;  //
1787   1         TR0  = 0; //;timer0 stop
1788   1         IFMT = 0x07 ; //#AUXRA_Rd ;set read AUXRA command
1789   1         SCMD = 0x46 ; //h
1790   1         SCMD = 0xB9 ; //h
1791   1         IFD  = IFD |= 0x03 ;
1792   1         IFMT = 0x06; // #AUXRA_Wr ;set write AUXRA command
1793   1         SCMD = 0x46; // h
1794   1         SCMD = 0xB9; //h
1795   1         IFMT = 0x07; //#AUXRA_Rd ;set read AUXRA command
1796   1         SCMD = 0x46; //h
C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 41  

1797   1         SCMD = 0xB9; //h
1798   1         IFD = IFD &= 0xFB; //
1799   1         IFMT = 0x06; //, #AUXRA_Wr ;set write AUXRA command
1800   1         SCMD = 0x46; //h
1801   1         SCMD = 0x0B9; //h
1802   1      
1803   1              P0M0 = 0xFF;      //00=Qb,01=pull output, 10= input only,11=open drain
1804   1              P0M1 = 0x00;     //P0= ALL INPUT  00
1805   1              P0   = 0xff;
1806   1      
1807   1              P1M0 = 0x00;     //P1= ALL OUTPUT//00
1808   1              P1M1 = 0xFF;     //SETUP P1 ALL LO //  define P1.3 P1.4 P1.5 as push-pull
1809   1          P1   = 0x00;
1810   1          
1811   1              P2M0 = 0x24;     //P2= ALL OUTOUT        04 
1812   1              P2M1 = 0xFF;     //SETUP P2 ALL LO       df
1813   1              P2  =  0x00;
1814   1      
1815   1          P3M0 = 0xED;         //     ed  
1816   1              P3M1 = 0x13;    // 13
1817   1              P3   = 0x2C;    // 2c
1818   1      
1819   1      //      PORT_Init();
1820   1              RTC_SCL = 1;
1821   1              RTC_SDA = 1;
1822   1              EEPROM_Init();
1823   1              LED_Init();
1824   1              T0_Init();
1825   1              T1_Init();
1826   1              AD3421_Init();
1827   1              InitUart();
1828   1          Set_mA(0);
1829   1          LED_Fill();
1830   1              Set_mV(0);
1831   1              Buzzer(OFF);
1832   1              Soft_Timer_Enable = 0;
1833   1      
1834   1              if((EEPROM_read_byte(0) != 'N')||(EEPROM_read_byte(1) != 'E')||(EEPROM_read_byte(2) != 'W')||(EEPROM_read
             -_byte(3) != JOHNSON)||(EEPROM_read_byte(4) != LIN))
1835   1           {
1836   2                      EEPROM_write_byte(0, 'N');      
1837   2                      EEPROM_write_byte(1, 'E');
1838   2                      EEPROM_write_byte(2, 'W');
1839   2                      EEPROM_write_byte(3, JOHNSON);  
1840   2                      EEPROM_write_byte(4, LIN);
1841   2                      RTC_ON();       
1842   2                      EEPROM_WriteDefault();
1843   2           }
1844   1             LED_Fill(); 
1845   1                 Work_Type = EEPROM_read_byte(Mode_Select);           
1846   1                 C_F_Type = EEPROM_read_byte(C_F_Select);
1847   1                 TC_Type  = EEPROM_read_byte(Type_Select);       //Type define k=0.j=1,t=2
1848   1                 TC_Zero_offset = EEPROM_read_word(TC_Zero);  
1849   1                 TC_Span_offset = EEPROM_read_word(TC_Span);
1850   1                 RTD_Zero_offset = EEPROM_read_word(RTD_Zero);
1851   1                 RTD_Span_offset = EEPROM_read_word(RTD_Span);
1852   1                 mV_Zero_offset = EEPROM_read_word(mV_Zero);
1853   1                 mV_Span_offset = EEPROM_read_word(mV_Span);
1854   1                 mA_Zero_offset = EEPROM_read_word(mA_Zero);  
1855   1             mA_Span_offset = EEPROM_read_word(mA_Span);
1856   1                 alarm_Low_set = EEPROM_read_word(Alarm_Low);
1857   1                 alarm_Hi_set = EEPROM_read_word(Alarm_Hi);
C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 42  

1858   1             use_year = EEPROM_read_byte(Year_Date);
1859   1             use_mon = EEPROM_read_byte(Mon_Date);
1860   1             use_day = EEPROM_read_byte(Day_Date);
1861   1             use_hour = EEPROM_read_byte(Hour_Date);
1862   1             use_min = EEPROM_read_byte(Min_Date);
1863   1                 use_sec = EEPROM_read_byte(sec_Date);
1864   1      
1865   1                 use_flag =   EEPROM_read_byte(Status_flag);
1866   1      
1867   1                 TC_Span_Value = EEPROM_read_word(TC_Span_Per);
1868   1                 RTD_Span_Value = EEPROM_read_word(RTD_Span_Per);
1869   1                 mV_Span_Value = EEPROM_read_word(mV_Span_Per);
1870   1                 mA_Span_Value = EEPROM_read_word(mA_Span_Per);
1871   1                 Temp_offset  = EEPROM_read_word(60);
1872   1      //         eep_count = EEPROM_read_byte(EEP_ADR);
1873   1                 Disp_year = use_year+0x2000;
1874   1                 RTC_ON();
1875   1        
1876   1      
1877   1               ET0 = 1;
1878   1               TR0 = 1;
1879   1               ET1 = 1;
1880   1               TR1 = 1;
1881   1               EA  = 1;
1882   1               MAIN_SW = 1 ;
1883   1      
1884   1           Check_PCB();
1885   1      
1886   1              if(Work_Type == 0)
1887   1                { if(use_flag & 0x01) NG_COD = 1 ;}
1888   1              else if(Work_Type == 1)
1889   1                { if(use_flag & 0x02) NG_COD = 1 ;}
1890   1              else if(Work_Type == 2)
1891   1                { if(use_flag &0x04)  NG_COD = 1 ;}
1892   1              else if(Work_Type == 3)
1893   1                { if(use_flag & 0x08) NG_COD = 1 ;}
1894   1      
1895   1      //***************************************
1896   1              while (1)
1897   1              {
1898   2                      switch (Func_Type)
1899   2                        {
1900   3                              case TC_FUNCTION:
1901   3                          if(Work_Type == 0)
1902   3                            { if(use_flag & 0x0010) {ADD_COD = 1;}else{ADD_COD = 0;}}
1903   3                                      DO_TC_TYPE();
1904   3                                      break;
1905   3      
1906   3                              case RTD_FUNCTION:
1907   3                              DO_RTD_TYPE();
1908   3                                      break;
1909   3      
1910   3                              case mV_FUNCTION:
1911   3                                      DO_mV_TYPE();
1912   3                                      break;
1913   3      
1914   3                              case mA_FUNCTION:
1915   3                                  DO_mA_TYPE();
1916   3                                      break;
1917   3                              
1918   3                              case SETUP_FUNCTION:
1919   3                                              CAIT = 1 ;
C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 43  

1920   3                                      DO_SETUP_TYPE();
1921   3                              
1922   3                                      break;
1923   3      
1924   3                              case CLEAR_FUNCTION:
1925   3                                      DO_RESET_TYPE();
1926   3                                      break;
1927   3                     }
1928   2               }
1929   1      }
C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 44  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


R485_RX. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B0H  1
CCF2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DAH  1
TB80 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009BH  1
PCAPWM4. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F6H  1
P1M0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0091H  1
P0M1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0094H  1
_RTC_read_byte . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
non3 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0097H  1
CCF3 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DBH  1
TB81 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009BH  1
PCAPWM5. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F7H  1
P2M0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0095H  1
P1M1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0092H  1
P0 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0080H  1
f_half_sec . . . . . . . . . . . . . .  PUBLIC   DATA   BIT      0000H  1
AD_Mid . . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0000H  1
ADD_COD. . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0001H  1
R485_TX. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B1H  1
CCF4 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DCH  1
SM00 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009FH  1
P3M0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B1H  1
P2M1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0096H  1
P1 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0090H  1
CCF5 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DDH  1
SM01 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009FH  1
SM10 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009EH  1
P4M0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B3H  1
P3M1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B2H  1
P2 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A0H  1
Soft_Timer . . . . . . . . . . . . . .  PUBLIC   IDATA  ARRAY    0000H  9
DO_RTD_TYPE. . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  RTD_Value. . . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
  key. . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
SM11 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009EH  1
SM20 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009DH  1
ISPCR. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E7H  1
P5M0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B5H  1
P4M1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B4H  1
P3 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B0H  1
XICON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C0H  1
EEPROM_WriteDefault. . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
serial . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
Temp_offset. . . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0002H  2
mA_Span_Value. . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0004H  2
EEPROM_SDA . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A2H  1
DOWN_KEY . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0087H  1
T0 . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B4H  1
SM21 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009DH  1
AC . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D6H  1
EVRCR. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0097H  1
P5M1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B6H  1
P4 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E8H  1
_TEMP_F_TO_C . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  tc_tmp . . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
  ttmp . . . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0002H  2
Key_backup . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0006H  1
T1 . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B5H  1
C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 45  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


SPCON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0085H  1
P5 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F8H  1
EIE1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00ADH  1
_Buzzer. . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  status . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
TC_Zero_offset . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0007H  2
T2 . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0090H  1
EA . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AFH  1
SFRPI. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00ACH  1
WDTCR. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E1H  1
P6 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C8H  1
mV_SCL . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A4H  1
KBI0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A0H  1
SPI_MOSI . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0095H  1
SPI_MISO . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0096H  1
mA_OUT . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0085H  1
KBI1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A1H  1
SPCTL. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0085H  1
KBI2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A2H  1
AIN0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0090H  1
CF . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DFH  1
AUXIP. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00AEH  1
KBI3 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A3H  1
AIN1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0091H  1
KBI4 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A4H  1
AIN2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0092H  1
FE . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009FH  1
CH . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F9H  1
KBI5 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A5H  1
AIN3 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0093H  1
KBI6 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A6H  1
AIN4 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0094H  1
EEPROM_SCL . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A3H  1
RTD_C. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0081H  1
KBI7 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A7H  1
AIN5 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0095H  1
IE . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A8H  1
mA_Span_offset . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0009H  2
AIN6 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0096H  1
CL . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E9H  1
Read_AD3421_Value. . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  AD3421_Value . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
  ssta . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
_RTC_write_byte. . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
AIN7 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0097H  1
CEX0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0092H  1
CCAP0H . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FAH  1
ADCH . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C6H  1
_delay . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0004H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0006H  2
  j. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0005H  1
size_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
CEX1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0093H  1
CCAP1H . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FBH  1
IP0H . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B7H  1
INT0_Init. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
Func_Type. . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   000BH  1
C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 46  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


ALL_SDA. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A2H  1
CEX2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0094H  1
CCAP2H . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FCH  1
OFFSET_KEY . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B3H  1
CEX3 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0095H  1
CCAP3H . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FDH  1
CEX4 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0096H  1
CR . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DEH  1
CCAP4H . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FEH  1
CCAP0L . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EAH  1
ADCL . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BEH  1
RD . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B7H  1
CEX5 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0097H  1
EXF2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CEH  1
REN0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009CH  1
CCAP5H . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FFH  1
CCAP1L . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EBH  1
CCAPM0 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DAH  1
IP0L . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B8H  1
Check_PCB. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
AD_Hi. . . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   000CH  1
REN1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009CH  1
CCAP2L . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00ECH  1
CCAPM1 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DBH  1
IT2H . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C3H  1
ES . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ACH  1
TSTWD. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0097H  1
CCAP3L . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EDH  1
CCAPM2 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DCH  1
mV_Span_Value. . . . . . . . . . . . .  PUBLIC   DATA   U_INT    000DH  2
IT3H . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C7H  1
CCAP4L . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EEH  1
CCAPM3 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DDH  1
IP . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B8H  1
CCAP5L . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EFH  1
CCAPM4 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DEH  1
RI . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0098H  1
CCAPM5 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DFH  1
TC_Type. . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   000FH  1
INT0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B2H  1
CY . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D7H  1
DO_RESET_TYPE. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
mA_Zero_offset . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0010H  2
BEEP . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B4H  1
mV_OUT . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0084H  1
INT1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B3H  1
TI . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0099H  1
EEP_SCL. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A3H  1
INT2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EBH  1
Volt_Ctrl. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
INT3 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EAH  1
ADCV . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C6H  1
STRETCH. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008FH  1
AD_Lo. . . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0012H  1
PT0L . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B9H  1
CAIT . . . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0013H  1
PT1L . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BBH  1
C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 47  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


RCAP2H . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CBH  1
RTC_SDA. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A2H  1
PS . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BCH  1
PT2L . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BDH  1
SP . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0081H  1
mV_Span_offset . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0014H  2
T2EX . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0091H  1
CMOD . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D9H  1
CCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D8H  1
SCFG . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009AH  1
RTC_WRITE_SET. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
PX0L . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B8H  1
OV . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D2H  1
Disp_year. . . . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0016H  2
PX1L . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BAH  1
RCAP2L . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CAH  1
main . . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
PX2L . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BEH  1
SPI_CLK. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0097H  1
PX3L . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BFH  1
SCMD . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E6H  1
WR . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B6H  1
C_T2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C9H  1
Work_Type. . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0018H  1
DO_SETUP_TYPE. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  set_key. . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0000H  1
  times. . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0001H  1
  Itemm. . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0002H  1
  item_key . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0003H  1
  confrom_key. . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0004H  1
  up_key . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0005H  1
  don_key. . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0006H  1
  value_cal. . . . . . . . . . . . . .  AUTO     DATA   U_INT    0007H  2
T0_cnt . . . . . . . . . . . . . . . .  PUBLIC   IDATA  U_CHAR   0009H  1
SPISTAT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0084H  1
T1_cnt . . . . . . . . . . . . . . . .  PUBLIC   IDATA  U_CHAR   000AH  1
Get_Key. . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
T2_cnt . . . . . . . . . . . . . . . .  PUBLIC   IDATA  U_CHAR   000BH  1
_Get_E_Slope . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
RTC_SCL. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0096H  1
RCLK . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CDH  1
Soft_Timer_Enable. . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0019H  1
DO_TC_TYPE . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Code_Value . . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
  TC_Value . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0002H  2
  TT_Value . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0004H  2
  TA_Value . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0006H  2
  key. . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
TCLK . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CCH  1
P00. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0080H  1
IFADRH . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E3H  1
MAIN_SW. . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   001AH  1
_Check_Type_Offset . . . . . . . . . .  PUBLIC   CODE   PROC     001AH  -----
  Code_Value . . . . . . . . . . . . .  * REG *  DATA   U_INT    0006H  2
  Count_Value. . . . . . . . . . . . .  * REG *  DATA   U_INT    0002H  2
P10. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0090H  1
P01. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0081H  1
C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 48  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


IFMT . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E5H  1
PCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0087H  1
SBUF . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0099H  1
mV_Zero_offset . . . . . . . . . . . .  PUBLIC   DATA   U_INT    001BH  2
_Get_J_Slope . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
P20. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A0H  1
P11. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0091H  1
P02. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0082H  1
_Get_K_Slope . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
Get_AD3421_Value . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
P30. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B0H  1
P21. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A1H  1
P12. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0092H  1
P03. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0083H  1
FUNCTION_KEY . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B2H  1
P40. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00E8H  1
P31. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B1H  1
P22. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A2H  1
P13. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0093H  1
P04. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0084H  1
IFADRL . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E4H  1
SCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0098H  1
InitUart . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
RTC_READ_SET . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
P50. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00F8H  1
P41. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00E9H  1
P32. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B2H  1
P23. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A3H  1
P14. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0094H  1
P05. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0085H  1
TMOD . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0089H  1
TCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0088H  1
P60. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C8H  1
P51. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00F9H  1
P42. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EAH  1
P33. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B3H  1
P24. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A4H  1
P15. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0095H  1
P06. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0086H  1
tran . . . . . . . . . . . . . . . . .  PUBLIC   DATA   BIT      0001H  1
TEMP . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A5H  1
P61. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C9H  1
P52. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00FAH  1
P43. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EBH  1
P34. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B4H  1
P25. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A5H  1
P16. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0096H  1
P07. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0087H  1
P53. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00FBH  1
P44. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ECH  1
P35. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B5H  1
P26. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A6H  1
P17. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0097H  1
Value_SDA. . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A0H  1
P45. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EDH  1
P36. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B6H  1
P27. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A7H  1
C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 49  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


_Get_R_Slope . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
TC_C . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0080H  1
P46. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EEH  1
P37. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B7H  1
ex_int0. . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
_Get_S_Slope . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
P47. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EFH  1
KBMASK . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D7H  1
_Get_T_Slope . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_Set_mA. . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_SETUP_LED_Disp. . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
OUT_SCL. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A4H  1
PORT_Init. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
AD_SDA . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A0H  1
IE0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0089H  1
LED_Fill . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
IE1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008BH  1
RTD_Span_Value . . . . . . . . . . . .  PUBLIC   DATA   U_INT    001DH  2
LED1_SDA . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0090H  1
IE2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C1H  1
EEPROM_Init. . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
LED2_SDA . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0093H  1
IE3. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C5H  1
GF4. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AEH  1
AUXR . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008EH  1
B. . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F0H  1
KBPATN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D5H  1
Value_SCL. . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A1H  1
ReceiveFlag. . . . . . . . . . . . . .  PUBLIC   DATA   BIT      0002H  1
CP_RL2 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C8H  1
NONE_4 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A6H  1
DO_mA_TYPE . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  mA_Value . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
  key. . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
NONE_5 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A7H  1
AD3421_Init. . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
NONE_6 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B6H  1
SPIDAT . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0086H  1
ACC. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E0H  1
ReceiveDate. . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   001FH  1
_LED_Disp. . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
NONE_7 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B7H  1
AD_SCL . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A1H  1
ES0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ACH  1
PCB_SETUP. . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0020H  1
ET0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A9H  1
key. . . . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0021H  1
LED1_SCL . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0092H  1
TF0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008DH  1
ET1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ABH  1
use_flag . . . . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0022H  2
RTD_Span_offset. . . . . . . . . . . .  PUBLIC   DATA   U_INT    0024H  2
LED2_SCL . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0094H  1
TF1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008FH  1
RI0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0098H  1
ET2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ADH  1
NG_COD . . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0026H  1
C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 50  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


LED_Init . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
TF2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CFH  1
RI1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0098H  1
RB8. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009AH  1
TH0. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008CH  1
IT0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0088H  1
TI0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0099H  1
EX0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A8H  1
TH1. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008DH  1
AV_COD . . . . . . . . . . . . . . . .  EXTERN   DATA   U_CHAR   -----  1
IT1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008AH  1
TI1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0099H  1
TB8. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009BH  1
EX1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AAH  1
SPICON . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0085H  1
TH2. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CDH  1
IT2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C0H  1
EX2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C2H  1
P. . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D0H  1
alarm_Hi_set . . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0027H  2
IT3. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C4H  1
EX3. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C6H  1
SM0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009FH  1
TL0. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008AH  1
_Set_mV. . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
mA_C . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0083H  1
XOUT . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C8H  1
ECI. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0091H  1
SM1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009EH  1
SPICTL . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0085H  1
TL1. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008BH  1
AUXIPH . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00AFH  1
alarm_Low_set. . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0029H  2
ALE. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EEH  1
SM2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009DH  1
TL2. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CCH  1
_Get_RTD_Slope . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
IFD. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E2H  1
PT0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B9H  1
NP_COD . . . . . . . . . . . . . . . .  EXTERN   DATA   U_CHAR   -----  1
R485_DE_RE . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B5H  1
PT1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BBH  1
RS0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D3H  1
TR0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008CH  1
PT2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BDH  1
RS1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D4H  1
TR1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008EH  1
TR2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CAH  1
PX0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B8H  1
EIP1H. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00AFH  1
RTD_Zero_offset. . . . . . . . . . . .  PUBLIC   DATA   U_INT    002BH  2
PX1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BAH  1
key_bak. . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   002DH  1
PX2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C3H  1
DO_mV_TYPE . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  mV_Value . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
  key. . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 51  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


PX3. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C7H  1
Temp_sp. . . . . . . . . . . . . . . .  PUBLIC   DATA   U_INT    002EH  2
Data_Value . . . . . . . . . . . . . .  PUBLIC   IDATA  ARRAY    000CH  30
EIP1L. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00AEH  1
DPH. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0083H  1
use_week . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0030H  1
CKO. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C8H  1
_EEPROM_read_byte. . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
DPL. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0082H  1
time0. . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Value_code . . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
PCON0. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0087H  1
SPSTAT . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0084H  1
SBUF0. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0099H  1
IPH. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B7H  1
time1. . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
use_year . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0031H  1
T0CKO. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B4H  1
PCON1. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0097H  1
SBUF1. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0099H  1
T1CKO. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B5H  1
EXEN2. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CBH  1
PCON2. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C7H  1
S2BUF. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009AH  1
SCON0. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0098H  1
Temp_m . . . . . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0032H  2
REN. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009CH  1
SCON1. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0098H  1
mV_C . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0082H  1
ADCON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C5H  1
RTC_ON . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
mA_SDA . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A2H  1
T2MOD. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C9H  1
T2CON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C8H  1
Zero_f . . . . . . . . . . . . . . . .  PUBLIC   DATA   BIT      0003H  1
_EEPROM_read_word. . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
ADCTL. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C5H  1
n_code . . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0034H  1
use_sec. . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0035H  1
ADCVL. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BEH  1
TC_Span_Value. . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0036H  2
wchar_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  CHAR     -----  1
SADEN. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B9H  1
AD_Status. . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0038H  1
C_F_Type . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0039H  1
S1BRT. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009AH  1
use_day. . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   003AH  1
RXD. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B0H  1
KBCON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D6H  1
use_hour . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   003BH  1
UP_KEY . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0086H  1
XIN. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C9H  1
PSL. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BCH  1
SADDR. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A9H  1
_EEPROM_write_byte . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
TXD. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B1H  1
t_code . . . . . . . . . . . . . . . .  PUBLIC   IDATA  U_CHAR   002AH  1
C51 COMPILER V9.02   MAIN                                                                  05/27/2015 12:23:08 PAGE 52  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


mA_SCL . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A4H  1
AUXR0. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008EH  1
AUXR1. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A2H  1
SPI_SS . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0094H  1
AUXR2. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A6H  1
use_min. . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   003CH  1
Temp_Flag. . . . . . . . . . . . . . .  PUBLIC   IDATA  U_CHAR   002BH  1
OVER_COD . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   003DH  1
S2RXD. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0092H  1
F0 . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D5H  1
Temp_Read. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Temp_Count . . . . . . . . . . . . .  * REG *  DATA   U_INT    0002H  2
  P_count. . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0082H  2
BEEP_OUT . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B4H  1
S2TXD. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0093H  1
F1 . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D1H  1
TC_Span_offset . . . . . . . . . . . .  PUBLIC   DATA   U_INT    003EH  2
_EEPROM_write_word . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
LED1_LE. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0091H  1
LED2_LE. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0095H  1
T0_Init. . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
use_mon. . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0040H  1
PCAPWM0. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F2H  1
PSW. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D0H  1
T1_Init. . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
PCAPWM1. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F3H  1
T2_Init. . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
mV_SDA . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A2H  1
CCF0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D8H  1
RB80 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009AH  1
PCAPWM2. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F4H  1
CCF1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D9H  1
RB81 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009AH  1
PCAPWM3. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F5H  1
SPDAT. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0086H  1
P0M0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0093H  1
AUXIE. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00ADH  1


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   8292    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     65      31
   IDATA SIZE       =     44    ----
   BIT SIZE         =      4    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
