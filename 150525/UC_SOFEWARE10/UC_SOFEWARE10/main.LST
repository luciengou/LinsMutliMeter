C51 COMPILER V9.02   MAIN                                                                  05/22/2015 15:09:11 PAGE 1   


C51 COMPILER V9.02, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c OMF2 BROWSE DEBUG LISTINCLUDE SYMBOLS

line level    source

   1          /***********************************************
   2            PRODUCT FOR NEWCAL MIX_TEMP FUNCTION
   3             CPU : MPC82G516
   4             BEGIN DATE: 2013.11.01
   5             FINISHED  : 2014.01.25
   6             WRITEBY   :JOHNSON LIN
   7             AD111  setup   SET 1001 0000 FOR A0 TYPE 
   8              8CH =  pga =1 ,32767BITS
   9          **************************************************/
  10          #include <MG82FE564.H>
   1      =1  // (System)
   2      =1  sfr ACC       = 0xE0;
   3      =1  sfr B         = 0xF0;
   4      =1  sfr SP        = 0x81;
   5      =1  sfr DPL       = 0x82;
   6      =1  sfr DPH       = 0x83;
   7      =1  sfr PSW       = 0xD0;
   8      =1  
   9      =1  // (Interrupt)
  10      =1  sfr IE        = 0xA8;
  11      =1  sfr EIE1      = 0xAD;
  12      =1  sfr AUXIE     = 0xAD;
  13      =1  sfr XICON     = 0xC0;
  14      =1  sfr IP0L      = 0xB8;
  15      =1  sfr IP        = 0xB8;
  16      =1  sfr IP0H      = 0xB7;
  17      =1  sfr IPH       = 0xB7;
  18      =1  sfr EIP1L     = 0xAE;
  19      =1  sfr AUXIP     = 0xAE;
  20      =1  sfr EIP1H     = 0xAF;
  21      =1  sfr AUXIPH    = 0xAF;
  22      =1  
  23      =1  // (I/O Port)
  24      =1  sfr P0        = 0x80;
  25      =1  sfr P1        = 0x90;
  26      =1  sfr P2        = 0xA0;
  27      =1  sfr P3        = 0xB0;
  28      =1  sfr P4        = 0xE8;
  29      =1  sfr P5        = 0xF8;
  30      =1  sfr P6        = 0xC8;                            // Page F
  31      =1  sfr P0M0      = 0x93;
  32      =1  sfr P0M1      = 0x94;
  33      =1  sfr P1M0      = 0x91;
  34      =1  sfr P1M1      = 0x92;
  35      =1  sfr P2M0      = 0x95;
  36      =1  sfr P2M1      = 0x96;
  37      =1  sfr P3M0      = 0xB1;
  38      =1  sfr P3M1      = 0xB2;
  39      =1  sfr P4M0      = 0xB3;
  40      =1  sfr P4M1      = 0xB4;
  41      =1  sfr P5M0      = 0xB5;
  42      =1  sfr P5M1      = 0xB6;
  43      =1  
  44      =1  // (Timer)
  45      =1  sfr TCON      = 0x88;
C51 COMPILER V9.02   MAIN                                                                  05/22/2015 15:09:11 PAGE 2   

  46      =1  sfr TMOD      = 0x89;
  47      =1  sfr T2CON     = 0xC8;
  48      =1  sfr T2MOD     = 0xC9;
  49      =1  sfr RCAP2L    = 0xCA;
  50      =1  sfr RCAP2H    = 0xCB;
  51      =1  sfr TL0       = 0x8A;
  52      =1  sfr TL1       = 0x8B;
  53      =1  sfr TH0       = 0x8C;
  54      =1  sfr TH1       = 0x8D;
  55      =1  sfr TL2       = 0xCC;
  56      =1  sfr TH2       = 0xCD;
  57      =1  
  58      =1  // (Serial Port)
  59      =1  sfr SCON      = 0x98;
  60      =1  sfr SCON0     = 0x98;
  61      =1  sfr SCON1     = 0x98;                            // Page 1
  62      =1  sfr SBUF      = 0x99;
  63      =1  sfr SBUF0     = 0x99;
  64      =1  sfr SBUF1     = 0x99;                            // Page 1
  65      =1  sfr SADDR     = 0xA9;
  66      =1  sfr SADEN     = 0xB9;
  67      =1  sfr SCFG      = 0x9A;
  68      =1  sfr S1BRT     = 0x9A;
  69      =1  sfr S2BUF     = 0x9A;                            // Page 1
  70      =1  
  71      =1  // (ADC)
  72      =1  sfr ADCON     = 0xC5;
  73      =1  sfr ADCTL     = 0xC5;
  74      =1  sfr ADCV      = 0xC6;
  75      =1  sfr ADCH      = 0xC6;
  76      =1  sfr ADCVL     = 0xBE;
  77      =1  sfr ADCL      = 0xBE;
  78      =1  
  79      =1  // (Keypad Interrupt)
  80      =1  sfr KBCON     = 0xD6;
  81      =1  sfr KBPATN    = 0xD5;
  82      =1  sfr KBMASK    = 0xD7;
  83      =1  
  84      =1  // (SPI)
  85      =1  sfr SPSTAT    = 0x84;
  86      =1  sfr SPCON     = 0x85;
  87      =1  sfr SPDAT     = 0x86;
  88      =1  sfr SPISTAT   = 0x84;
  89      =1  sfr SPICON    = 0x85;
  90      =1  sfr SPIDAT    = 0x86;
  91      =1  sfr SPCTL     = 0x85;
  92      =1  sfr SPICTL    = 0x85;
  93      =1  
  94      =1  // (PCA)
  95      =1  sfr CCON      = 0xD8;
  96      =1  sfr CMOD      = 0xD9;
  97      =1  sfr CL        = 0xE9;
  98      =1  sfr CH        = 0xF9;
  99      =1  sfr CCAPM0    = 0xDA;
 100      =1  sfr CCAPM1    = 0xDB;
 101      =1  sfr CCAPM2    = 0xDC;
 102      =1  sfr CCAPM3    = 0xDD;
 103      =1  sfr CCAPM4    = 0xDE;
 104      =1  sfr CCAPM5    = 0xDF;
 105      =1  sfr CCAP0H    = 0xFA;
 106      =1  sfr CCAP0L    = 0xEA;
 107      =1  sfr CCAP1H    = 0xFB;
C51 COMPILER V9.02   MAIN                                                                  05/22/2015 15:09:11 PAGE 3   

 108      =1  sfr CCAP1L    = 0xEB;
 109      =1  sfr CCAP2H    = 0xFC;
 110      =1  sfr CCAP2L    = 0xEC;
 111      =1  sfr CCAP3H    = 0xFD;
 112      =1  sfr CCAP3L    = 0xED;
 113      =1  sfr CCAP4H    = 0xFE;
 114      =1  sfr CCAP4L    = 0xEE;
 115      =1  sfr CCAP5H    = 0xFF;
 116      =1  sfr CCAP5L    = 0xEF;
 117      =1  sfr PCAPWM0   = 0xF2;
 118      =1  sfr PCAPWM1   = 0xF3;
 119      =1  sfr PCAPWM2   = 0xF4;
 120      =1  sfr PCAPWM3   = 0xF5;
 121      =1  sfr PCAPWM4   = 0xF6;
 122      =1  sfr PCAPWM5   = 0xF7;
 123      =1  
 124      =1  // (Others)
 125      =1  sfr PCON      = 0x87;
 126      =1  sfr PCON0     = 0x87;
 127      =1  sfr PCON1     = 0x97;
 128      =1  sfr EVRCR     = 0x97;
 129      =1  sfr PCON2     = 0xC7;
 130      =1  sfr AUXR      = 0x8E;
 131      =1  sfr AUXR0     = 0x8E;
 132      =1  sfr AUXR1     = 0xA2;
 133      =1  sfr AUXR2     = 0xA6;
 134      =1  sfr STRETCH   = 0x8F;
 135      =1  sfr WDTCR     = 0xE1;
 136      =1  sfr TSTWD     = 0x97;
 137      =1  sfr SFRPI     = 0xAC;
 138      =1  
 139      =1  // (ISP)
 140      =1  sfr ISPCR     = 0xE7;
 141      =1  sfr IFMT      = 0xE5;
 142      =1  sfr IFD       = 0xE2;
 143      =1  sfr IFADRH    = 0xE3;
 144      =1  sfr IFADRL    = 0xE4;
 145      =1  sfr SCMD      = 0xE6;
 146      =1  
 147      =1  // (bits in PSW)
 148      =1  sbit CY       = PSW^7;
 149      =1  sbit AC       = PSW^6;
 150      =1  sbit F0       = PSW^5;
 151      =1  sbit RS1      = PSW^4;
 152      =1  sbit RS0      = PSW^3;
 153      =1  sbit OV       = PSW^2;
 154      =1  sbit F1       = PSW^1;
 155      =1  sbit P        = PSW^0;
 156      =1  
 157      =1  // (bits in IE)
 158      =1  sbit EA       = IE^7;
 159      =1  sbit GF4      = IE^6;
 160      =1  sbit ET2      = IE^5;
 161      =1  sbit ES       = IE^4;
 162      =1  sbit ES0      = IE^4;
 163      =1  sbit ET1      = IE^3;
 164      =1  sbit EX1      = IE^2;
 165      =1  sbit ET0      = IE^1;
 166      =1  sbit EX0      = IE^0;
 167      =1  
 168      =1  // (bits in IP0L)
 169      =1  sbit PX3L     = IP0L^7;
C51 COMPILER V9.02   MAIN                                                                  05/22/2015 15:09:11 PAGE 4   

 170      =1  sbit PX2L     = IP0L^6;
 171      =1  sbit PT2L     = IP0L^5;
 172      =1  sbit PSL      = IP0L^4;
 173      =1  sbit PT1L     = IP0L^3;
 174      =1  sbit PX1L     = IP0L^2;
 175      =1  sbit PT0L     = IP0L^1;
 176      =1  sbit PX0L     = IP0L^0;
 177      =1  
 178      =1  sbit PT2      = IP^5;
 179      =1  sbit PS       = IP^4;
 180      =1  sbit PT1      = IP^3;
 181      =1  sbit PX1      = IP^2;
 182      =1  sbit PT0      = IP^1;
 183      =1  sbit PX0      = IP^0;
 184      =1  
 185      =1  //(bits in SCON0)
 186      =1  sbit FE       = SCON0^7;
 187      =1  sbit SM00     = SCON0^7;
 188      =1  sbit SM10     = SCON0^6;
 189      =1  sbit SM20     = SCON0^5;
 190      =1  sbit REN0     = SCON0^4;
 191      =1  sbit TB80     = SCON0^3;
 192      =1  sbit RB80     = SCON0^2;
 193      =1  sbit TI0      = SCON0^1;
 194      =1  sbit RI0      = SCON0^0;
 195      =1  
 196      =1  sbit SM0      = SCON^7;
 197      =1  sbit SM1      = SCON^6;
 198      =1  sbit SM2      = SCON^5;
 199      =1  sbit REN      = SCON^4;
 200      =1  sbit TB8      = SCON^3;
 201      =1  sbit RB8      = SCON^2;
 202      =1  sbit TI       = SCON^1;
 203      =1  sbit RI       = SCON^0;
 204      =1  
 205      =1  //(bits in SCON1)
 206      =1  sbit SM01     = SCON1^7;
 207      =1  sbit SM11     = SCON1^6;
 208      =1  sbit SM21     = SCON1^5;
 209      =1  sbit REN1     = SCON1^4;
 210      =1  sbit TB81     = SCON1^3;
 211      =1  sbit RB81     = SCON1^2;
 212      =1  sbit TI1      = SCON1^1;
 213      =1  sbit RI1      = SCON1^0;
 214      =1  
 215      =1  // (bits in TCON)
 216      =1  sbit TF1      = TCON^7;
 217      =1  sbit TR1      = TCON^6;
 218      =1  sbit TF0      = TCON^5;
 219      =1  sbit TR0      = TCON^4;
 220      =1  sbit IE1      = TCON^3;
 221      =1  sbit IT1      = TCON^2;
 222      =1  sbit IE0      = TCON^1;
 223      =1  sbit IT0      = TCON^0;
 224      =1  
 225      =1  // (bits in T2CON)
 226      =1  sbit TF2      = T2CON^7;
 227      =1  sbit EXF2     = T2CON^6;
 228      =1  sbit RCLK     = T2CON^5;
 229      =1  sbit TCLK     = T2CON^4;
 230      =1  sbit EXEN2    = T2CON^3;
 231      =1  sbit TR2      = T2CON^2;
C51 COMPILER V9.02   MAIN                                                                  05/22/2015 15:09:11 PAGE 5   

 232      =1  sbit C_T2     = T2CON^1;
 233      =1  sbit CP_RL2   = T2CON^0;
 234      =1  
 235      =1  // (bits in CCON)
 236      =1  sbit CF       = CCON^7;
 237      =1  sbit CR       = CCON^6;
 238      =1  sbit CCF5     = CCON^5;
 239      =1  sbit CCF4     = CCON^4;
 240      =1  sbit CCF3     = CCON^3;
 241      =1  sbit CCF2     = CCON^2;
 242      =1  sbit CCF1     = CCON^1;
 243      =1  sbit CCF0     = CCON^0;
 244      =1  
 245      =1  // (bits in XICON)
 246      =1  sbit PX3      = XICON^7;
 247      =1  sbit IT3H     = XICON^7;
 248      =1  sbit EX3      = XICON^6;
 249      =1  sbit IE3      = XICON^5;
 250      =1  sbit IT3      = XICON^4;
 251      =1  sbit PX2      = XICON^3;
 252      =1  sbit IT2H     = XICON^3;
 253      =1  sbit EX2      = XICON^2;
 254      =1  sbit IE2      = XICON^1;
 255      =1  sbit IT2      = XICON^0;
 256      =1  
 257      =1  // (bits in P0)
 258      =1  sbit P07      = P0^7;
 259      =1  sbit P06      = P0^6;
 260      =1  sbit P05      = P0^5;
 261      =1  sbit P04      = P0^4;
 262      =1  sbit P03      = P0^3;
 263      =1  sbit P02      = P0^2;
 264      =1  sbit P01      = P0^1;
 265      =1  sbit P00      = P0^0;
 266      =1  
 267      =1  // (bits in P1)
 268      =1  sbit P17      = P1^7;
 269      =1  sbit P16      = P1^6;
 270      =1  sbit P15      = P1^5;
 271      =1  sbit P14      = P1^4;
 272      =1  sbit P13      = P1^3;
 273      =1  sbit P12      = P1^2;
 274      =1  sbit P11      = P1^1;
 275      =1  sbit P10      = P1^0;
 276      =1  
 277      =1  // (bits in P2)
 278      =1  sbit P27      = P2^7;
 279      =1  sbit P26      = P2^6;
 280      =1  sbit P25      = P2^5;
 281      =1  sbit P24      = P2^4;
 282      =1  sbit P23      = P2^3;
 283      =1  sbit P22      = P2^2;
 284      =1  sbit P21      = P2^1;
 285      =1  sbit P20      = P2^0;
 286      =1  
 287      =1  // (bits in P3)
 288      =1  sbit P37      = P3^7;
 289      =1  sbit P36      = P3^6;
 290      =1  sbit P35      = P3^5;
 291      =1  sbit P34      = P3^4;
 292      =1  sbit P33      = P3^3;
 293      =1  sbit P32      = P3^2;
C51 COMPILER V9.02   MAIN                                                                  05/22/2015 15:09:11 PAGE 6   

 294      =1  sbit P31      = P3^1;
 295      =1  sbit P30      = P3^0;
 296      =1  
 297      =1  // (bits in P4)
 298      =1  sbit P47      = P4^7;
 299      =1  sbit P46      = P4^6;
 300      =1  sbit P45      = P4^5;
 301      =1  sbit P44      = P4^4;
 302      =1  sbit P43      = P4^3;
 303      =1  sbit P42      = P4^2;
 304      =1  sbit P41      = P4^1;
 305      =1  sbit P40      = P4^0;
 306      =1  
 307      =1  // (bits in P5)
 308      =1  sbit P53      = P5^3;
 309      =1  sbit P52      = P5^2;
 310      =1  sbit P51      = P5^1;
 311      =1  sbit P50      = P5^0;
 312      =1  
 313      =1  // (bits in P6)
 314      =1  sbit P61      = P6^1;
 315      =1  sbit P60      = P6^0;
 316      =1  
 317      =1  // (bits in P1, alternate)
 318      =1  sbit T2EX     = P1^1;
 319      =1  sbit T2       = P1^0;
 320      =1  sbit S2TXD    = P1^3;
 321      =1  sbit S2RXD    = P1^2;
 322      =1  
 323      =1  sbit SPI_CLK  = P1^7;
 324      =1  sbit SPI_MISO = P1^6;
 325      =1  sbit SPI_MOSI = P1^5;
 326      =1  sbit SPI_SS   = P1^4;
 327      =1  
 328      =1  sbit CEX5     = P1^7;
 329      =1  sbit CEX4     = P1^6;
 330      =1  sbit CEX3     = P1^5;
 331      =1  sbit CEX2     = P1^4;
 332      =1  sbit CEX1     = P1^3;
 333      =1  sbit CEX0     = P1^2;
 334      =1  sbit ECI      = P1^1;
 335      =1  
 336      =1  sbit AIN7     = P1^7;
 337      =1  sbit AIN6     = P1^6;
 338      =1  sbit AIN5     = P1^5;
 339      =1  sbit AIN4     = P1^4;
 340      =1  sbit AIN3     = P1^3;
 341      =1  sbit AIN2     = P1^2;
 342      =1  sbit AIN1     = P1^1;
 343      =1  sbit AIN0     = P1^0;
 344      =1  
 345      =1  //(bits in P2, alternate)
 346      =1  sbit KBI7     = P2^7;
 347      =1  sbit KBI6     = P2^6;
 348      =1  sbit KBI5     = P2^5;
 349      =1  sbit KBI4     = P2^4;
 350      =1  sbit KBI3     = P2^3;
 351      =1  sbit KBI2     = P2^2;
 352      =1  sbit KBI1     = P2^1;
 353      =1  sbit KBI0     = P2^0;
 354      =1  
 355      =1  // (bits in P3, alternate)
C51 COMPILER V9.02   MAIN                                                                  05/22/2015 15:09:11 PAGE 7   

 356      =1  sbit RD       = P3^7;
 357      =1  sbit WR       = P3^6;
 358      =1  sbit T1       = P3^5;
 359      =1  sbit T0       = P3^4;
 360      =1  sbit INT1     = P3^3;
 361      =1  sbit INT0     = P3^2;
 362      =1  sbit TXD      = P3^1;
 363      =1  sbit RXD      = P3^0;
 364      =1  sbit T1CKO    = P3^5;
 365      =1  sbit T0CKO    = P3^4;
 366      =1  
 367      =1  // (bits in P4, alternate)
 368      =1  sbit INT2     = P4^3;
 369      =1  sbit INT3     = P4^2;
 370      =1  
 371      =1  sbit ALE      = P4^6;
 372      =1  
 373      =1  // (bits in P6, alternate)
 374      =1  sbit CKO      = P6^0;
 375      =1  sbit XOUT     = P6^0;
 376      =1  sbit XIN      = P6^1;
  11          #include <IO_DEFINE.h>
   1      =1  #ifndef IO_DEFINE_h_ 
   2      =1  #define IO_DEFINE_h_
   3      =1  
   4      =1  sbit TC_C    = P0^0;    //k=0x00;j=0x01;t=0x02;e=0x03; 
   5      =1  sbit RTD_C   = P0^1;    //r=0x04;s=0x05;b=0x06;n=0x07;
   6      =1  sbit mV_C    = P0^2;
   7      =1  sbit mA_C    = P0^3;     //tc= 000 00xxx;  rtd=000 01xxx;    mV=000 10xxx
   8      =1  sbit mV_OUT  = P0^4;     //mA= 000 11xxx;
   9      =1  sbit mA_OUT  = P0^5;
  10      =1  sbit UP_KEY   = P0^6;
  11      =1  sbit DOWN_KEY = P0^7;
  12      =1  
  13      =1  sbit LED1_SDA = P1^0;
  14      =1  sbit LED1_SCL = P1^2;
  15      =1  sbit LED1_LE  = P1^1;
  16      =1  sbit LED2_SDA  = P1^3;
  17      =1  sbit LED2_SCL  = P1^4;
  18      =1  sbit LED2_LE   = P1^5;
  19      =1  sbit RTC_SCL   = P1^6;
  20      =1  sbit non3      = P1^7;
  21      =1  
  22      =1  sbit AD_SDA   = P2^0;
  23      =1  sbit AD_SCL   = P2^1;
  24      =1  sbit ALL_SDA  = P2^2;
  25      =1  sbit EEP_SCL  = P2^3;
  26      =1  sbit OUT_SCL  = P2^4;
  27      =1  sbit TEMP    = P2^5;
  28      =1  sbit NONE_4   = P2^6;
  29      =1  sbit NONE_5   = P2^7;
  30      =1  sbit RTC_SDA  = P2^2;
  31      =1  
  32      =1  sbit R485_RX           = P3^0;
  33      =1  sbit R485_TX           = P3^1;
  34      =1  sbit FUNCTION_KEY      = P3^2;
  35      =1  sbit OFFSET_KEY        = P3^3;
  36      =1  sbit BEEP_OUT          = P3^4;   //for relay
  37      =1  sbit R485_DE_RE        = P3^5;
  38      =1  sbit NONE_6            = P3^6;
  39      =1  sbit NONE_7            = P3^7;
  40      =1  //------------------------
C51 COMPILER V9.02   MAIN                                                                  05/22/2015 15:09:11 PAGE 8   

  41      =1  sbit EEPROM_SDA = P2^2;
  42      =1  sbit EEPROM_SCL = P2^3;
  43      =1  
  44      =1  sbit Value_SDA  = P2^0;
  45      =1  sbit Value_SCL  = P2^1;
  46      =1  sbit BEEP       = P3^4;  //for relay
  47      =1  
  48      =1  sbit mV_SDA   = P2^2;
  49      =1  sbit mV_SCL   = P2^4;
  50      =1  sbit mA_SDA   = P2^2;
  51      =1  sbit mA_SCL   = P2^4;
  52      =1  
  53      =1  #endif
  12          #include <LED.h>
   1      =1  #ifndef LED_h_ 
   2      =1  #define LED_h_ 
   3      =1  
   4      =1  
   5      =1  void LED_Disp(unsigned char LEDs, unsigned  int disp_value);
   6      =1  void SETUP_LED_Disp(unsigned char SETUP_SELECT, unsigned int disp_value);
   7      =1  void LED_DATA_Write(unsigned char prt,unsigned char D5,unsigned char D4,unsigned char D3,unsigned char D2,
             -unsigned char D1,unsigned char D0);
   8      =1  void DAY_LED_Disp(unsigned char DD,unsigned char HH, unsigned char MM);
   9      =1  void LED_Init(void);
  10      =1  void LED_Cls(void);
  11      =1  void LED_Fill(void);
  12      =1  #endif
  13          #include <AD3421.h>
   1      =1  /************************************************************************
   2      =1  * FileName     : i2c.h
   3      =1  * Description  : Default MPC82G516 to ctrl AD111A0 IC function.
   4      =1  *
   5      =1  *
   6      =1  * Version control:
   7      =1  ***************************************************************************/
   8      =1  #ifndef __AD3421_H__
   9      =1  #define __AD3421_H__
  10      =1  
  11      =1  
  12      =1  void AD3421_Init(void);
  13      =1  void AD3421_start(void);
  14      =1  void AD3421_stop(void);
  15      =1  void AD3421_write_byte(unsigned char bt);
  16      =1  unsigned char AD3421_read_byte(unsigned char lastbyte);         
  17      =1  void AD3421_write_com(unsigned char dev_id, unsigned char reg_addr);
  18      =1  unsigned char AD3421_read_com(unsigned char dev_id);
  19      =1  void S_Delay(unsigned int n);
  20      =1  unsigned char Get_AD3421_Value(void);
  21      =1  
  22      =1  unsigned int  SetmA(unsigned int mA_Value);
  23      =1  unsigned int  SetmV(unsigned int mV_Value);       
  24      =1  
  25      =1  
  26      =1  void DAC_write(unsigned char ch_id, unsigned int ma);
  27      =1  void Clear_key_delay(void);
  28      =1  unsigned char EEPROM_write(unsigned char reg_addr, unsigned int reg_data);
  29      =1  unsigned char   EEPROM_read_byte(unsigned char reg_addr);
  30      =1  unsigned char KeyScan(void);
  31      =1  unsigned char voicePlay(unsigned char id, unsigned char vol);
  32      =1  unsigned char Get_Key(void);
  33      =1  
  34      =1  #define         TRUE    1
C51 COMPILER V9.02   MAIN                                                                  05/22/2015 15:09:11 PAGE 9   

  35      =1  #define         FALSE   0
  36      =1  
  37      =1  #endif 
  14          #include <DAC6571_mV.h>
   1      =1  /************************************************************************
   2      =1  * FileName     : i2c.h
   3      =1  * Description  : Default MPC82G516 to ctrl AD111A0 IC function.
   4      =1  *
   5      =1  *
   6      =1  * Version control:
   7      =1  ***************************************************************************/
   8      =1  #ifndef __DAC6571_mV_H__
   9      =1  #define __DAC6571_mV_H__
  10      =1  
  11      =1  void DAC6571mV_Init(void);
  12      =1  void DAC6571mV_start(void);
  13      =1  void DAC6571mV_stop(void);
  14      =1  void DAC6571mV_write_byte(unsigned char bt);
  15      =1  void mV_Delay(unsigned int n);
  16      =1  void Set_mV(unsigned int mV_V);   
  17      =1  
  18      =1  #define         TRUE    1
  19      =1  #define         FALSE   0
  20      =1  
  21      =1  #endif 
  15          #include <DAC6571_mA.h>
   1      =1  /************************************************************************
   2      =1  * FileName     : i2c.h
   3      =1  * Description  : Default MPC82G516 to ctrl AD111A0 IC function.
   4      =1  *
   5      =1  *
   6      =1  * Version control:
   7      =1  ***************************************************************************/
   8      =1  #ifndef __DAC6571_mA_H__
   9      =1  #define __DAC6571_mA_H__
  10      =1  
  11      =1  
  12      =1  void DAC6571mA_Init(void);
  13      =1  void DAC6571mA_start(void);
  14      =1  void DAC6571mA_stop(void);
  15      =1  void DAC6571mA_write_byte(unsigned char bt);
  16      =1  void mA_Delay(unsigned int n);
  17      =1  void Set_mA(unsigned int mA_Value);
  18      =1  
  19      =1  #define         TRUE    1
  20      =1  #define         FALSE   0
  21      =1  
  22      =1  #endif 
  16          #include <MCP79411.h>
   1      =1  /********************************
   2      =1  **          RTC.DEVICE     **
   3      =1  *********************************/
   4      =1  #ifndef __mcp79411_H_
   5      =1  #define __mcp79411_H_
   6      =1  
   7      =1  void RTC_Delay(unsigned int i);
   8      =1  void RTC_BitDly(void);  
   9      =1  //void RTC_Init(void);
  10      =1  void RTC_start0(void);  
  11      =1  void RTC_stop0(void);
  12      =1  void RTC_restart0(void);
  13      =1  void RTC_write_byte0(unsigned char bt);
C51 COMPILER V9.02   MAIN                                                                  05/22/2015 15:09:11 PAGE 10  

  14      =1  void RTC_write_byte(unsigned char reg_addr,unsigned char reg_data);
  15      =1  void RTC_write_word(unsigned char addr, unsigned int intdata);
  16      =1  unsigned char RTC_read_byte0(void);
  17      =1  unsigned char RTC_read_byte(unsigned char reg_addr);
  18      =1  unsigned int  RTC_read_word(unsigned char addr);
  19      =1  void RTC_WRITE_SET(void);
  20      =1  void RTC_READ_SET(void);
  21      =1  void RTC_ON(void);
  22      =1  void RTC_Write_Default(void);
  23      =1  
  24      =1  #endif
  17          #include <EEPROM.H>
   1      =1  /********************************
   2      =1  **          EEPROM.DEVICE          **
   3      =1  *********************************/
   4      =1  #ifndef __EEPROM_H
   5      =1  #define __EEPROM_H
   6      =1  
   7      =1  void EEPROM_Delay(unsigned int i);
   8      =1  void EEPROM_BitDly(void);
   9      =1  void EEPROM_Init(void);
  10      =1  void EEPROM_start0(void);
  11      =1  void EEPROM_stop0(void);
  12      =1  void EEPROM_restart0(void);
  13      =1  
  14      =1  void EEPROM_write_byte0(unsigned char bt);
  15      =1  void EEPROM_write_byte(unsigned char reg_addr,unsigned char reg_data);
  16      =1  void EEPROM_write_word(unsigned char addr, unsigned int intdata);
  17      =1  
  18      =1  unsigned char EEPROM_read_byte0(void);
  19      =1  unsigned char EEPROM_read_byte(unsigned char reg_addr);
  20      =1  unsigned int  EEPROM_read_word(unsigned char addr);
  21      =1  void EEPROM_Write_Default(void);
  22      =1  
  23      =1  #endif
  18          #include <STDLIB.H>
   1      =1  /*--------------------------------------------------------------------------
   2      =1  STDLIB.H
   3      =1  
   4      =1  Standard functions.
   5      =1  Copyright (c) 1988-2005 Keil Elektronik GmbH and Keil Software, Inc.
   6      =1  All rights reserved.
   7      =1  --------------------------------------------------------------------------*/
   8      =1  
   9      =1  #ifndef __STDLIB_H__
  10      =1  #define __STDLIB_H__
  11      =1  
  12      =1  #ifndef _SIZE_T
  13      =1   #define _SIZE_T
  14      =1  
  15      =1  typedef unsigned int size_t;
  16      =1  #endif
  17      =1  
  18      =1  #ifndef NULL
  19      =1   #define NULL ((void *) 0L)
  20      =1  #endif
  21      =1  
  22      =1  #ifndef _WCHAR_T_DEFINED_
  23      =1  #define _WCHAR_T_DEFINED_
  24      =1  
  25      =1  typedef char wchar_t;
  26      =1  #endif
C51 COMPILER V9.02   MAIN                                                                  05/22/2015 15:09:11 PAGE 11  

  27      =1  
  28      =1  #ifndef RAND_MAX
  29      =1   #define RAND_MAX  32767u
  30      =1  #endif
  31      =1  
  32      =1  #pragma SAVE
  33      =1  #pragma REGPARMS
  34      =1  
  35      =1  extern int    abs  (int   val);
  36      =1  extern long  labs  (long  val);
  37      =1  
  38      =1  extern float atof (char *s1);
  39      =1  extern long  atol (char *s1);
  40      =1  extern int   atoi (char *s1);
  41      =1  extern int   rand ();
  42      =1  extern void  srand (int);
  43      =1  
  44      =1  extern float         strtod  (char *, char **);
  45      =1  extern long          strtol  (char *, char **, unsigned char);
  46      =1  extern unsigned long strtoul (char *, char **, unsigned char);
  47      =1  
  48      =1  #define _MALLOC_MEM_    xdata
  49      =1  
  50      =1  extern void init_mempool          (void _MALLOC_MEM_ *p, unsigned int size);
  51      =1  extern void _MALLOC_MEM_ *malloc  (unsigned int size);
  52      =1  extern void free                  (void _MALLOC_MEM_ *p);
  53      =1  extern void _MALLOC_MEM_ *realloc (void _MALLOC_MEM_ *p, unsigned int size);
  54      =1  extern void _MALLOC_MEM_ *calloc  (unsigned int size, unsigned int len);
  55      =1  
  56      =1  #pragma RESTORE
  57      =1  
  58      =1  #endif
  19          #include <TYPE_SLOPE.H>
   1      =1  /*************************************
   2      =1   SLOPE FOR PER TYPE AND GAIN 
   3      =1  
   4      =1  **************************************/
   5      =1  #ifndef SLOPE_h_ 
   6      =1  #define SLOPE_h_ 
   7      =1  
   8      =1  unsigned int Get_K_Slope(unsigned  int kt);
   9      =1  unsigned int Get_J_Slope(unsigned  int jt);
  10      =1  unsigned int Get_T_Slope(unsigned  int ts);
  11      =1  unsigned int Get_E_Slope(unsigned  int et);
  12      =1  unsigned int Get_R_Slope(unsigned  int rt);
  13      =1  unsigned int Get_S_Slope(unsigned  int st);
  14      =1  unsigned int Get_B_Slope(unsigned  int bt);
  15      =1  unsigned int Get_N_Slope(unsigned  int nt); 
  16      =1  unsigned int Get_RTD_Slope(unsigned int rtd);
  17      =1  unsigned int DO_RTD_TYPE(void);
  18      =1  unsigned int Read_AD3421_Value(void);
  19      =1  unsigned int Check_Type_Offset(unsigned int ss);
  20      =1  #endif
  20          
  21          #define   BASE_TEMP             32       //F & C Transfor Data
  22          #define   MAX_TEMP              3240     //F 1800C
  23          #define   MAX_VOLT              2048     //mV
  24          #define   EEP_START             60
  25          #define   EEP_END               2000
  26          #define   JOHNSON       0x5a
  27          #define   LIN           0xa5
  28          
C51 COMPILER V9.02   MAIN                                                                  05/22/2015 15:09:11 PAGE 12  

  29          #define   K_TYPE                0               //2466F   54.807mV      P0=0x00
  30          #define   J_TYPE                1               //1368F   42.922mV
  31          #define   T_TYPE            2           //360F    9.286mV
  32          #define   E_TYPE                3               //1440F   61.022mV
  33          #define   R_TYPE                4               //2880F   18.842mV
  34          #define   S_TYPE                5               //2880F   16.771mV
  35          #define   B_TYPE                6               //3240F   13.585mV
  36          #define   N_TYPE            7           //?       ?
  37          
  38          #define TC_FUNCTION             0
  39          #define RTD_FUNCTION    1
  40          #define mV_FUNCTION             2
  41          #define mA_FUNCTION             3
  42          #define SETUP_FUNCTION  4
  43          #define CLEAR_FUNCTION  5
  44          
  45          #define   ON    1
  46          #define   OFF   0
  47          
  48          //timer out work select
  49          #define DISPLAY_SEND_TIME  0     // DISPLAY TIME  
  50          #define ADC_READ_TIME      1     //     ADC_READ_TIME
  51          #define RTC_READ_TIME      2     //     RTC_READ_TIME
  52          #define RTC_SEND_TIME      3     //     RTC_SEND_TIME
  53          #define UART_SEND_TIME     4     //     UART_SEND_TIME
  54          #define MV_SEND_TIME       5     // mV_OUT_ TIME
  55          #define SETUP_TIMEOUT      6     //     FAIL_TIMEOUT
  56          #define TIMEUP_TIME        7     //
  57          #define TEMP_TIME          8     //
  58          
  59          #define NOMAL_FUNCTION    0
  60          #define MODE_CAL          1
  61          #define C_F_CAL           2
  62          #define TYPE_CAL          3
  63          #define TC_ZERO_CAL       4
  64          #define TC_SPAN_CAL       5
  65          #define RTD_ZERO_CAL      6
  66          #define RTD_SPAN_CAL      7
  67          #define mV_ZERO_CAL       8
  68          #define mV_SPAN_CAL       9
  69          #define mA_ZERO_CAL       10
  70          #define mA_SPAN_CAL       11
  71          #define ALARM_LO_CAL      12
  72          #define ALARM_HI_CAL      13
  73          #define YEAR_DATE_CAL     14
  74          #define MON_DATE_CAL      15
  75          #define DAY_DATE_CAL      16
  76          #define HOUR_DATE_CAL     17
  77          #define MIN_DATE_CAL      18
  78          //#define SEC_DATE_CAL      19
  79          #define PRODUCT_RESET     19
  80          #define  SQWE           0x40            //  SQWE = b6  
  81          #define  MFP_01H        0x00 
  82          #define  OSC_EN         0x80                    // day bit 7
  83          
  84          #define  sec     0x00  
  85          #define  min     0x01 
  86          #define  hour    0x02
  87          #define  week    0x03
  88          #define  day     0x04
  89          #define  month   0x05
  90          #define  year    0x06
C51 COMPILER V9.02   MAIN                                                                  05/22/2015 15:09:11 PAGE 13  

  91          #define  ctl     0x07
  92                             
  93          #define  Mode_Select 18    //EEP Address
  94          #define  C_F_Select  19
  95          #define  Type_Select 20
  96          #define  TC_Zero     22   
  97          #define  TC_Span     24
  98          #define  RTD_Zero    26
  99          #define  RTD_Span    28
 100          #define  mV_Zero     30                                                                   
 101          #define  mV_Span     32
 102          #define  mA_Zero     34
 103          #define  mA_Span     36
 104          #define  Alarm_Low   38
 105          #define  Alarm_Hi    40
 106          #define  Year_Date   42
 107          #define  Mon_Date    43
 108          #define  Day_Date    44
 109          #define  Week_Date   45
 110          #define  Hour_Date   46
 111          #define  Min_Date    47
 112          #define  sec_Date    48
 113          #define  Status_flag 50
 114          #define  TC_Span_Per 52
 115          #define  RTD_Span_Per 54
 116          #define  mV_Span_Per 56
 117          #define  mA_Span_Per 58
 118          
 119          #define  EEP_ADR     64
 120          //===============================
 121          extern unsigned char key = 0,key_bak = 0;
 122          extern unsigned char AV_COD ;
 123          extern unsigned char NP_COD ;
 124          unsigned char NG_COD,ADD_COD;
 125          unsigned char OVER_COD = 0 ;
 126          idata unsigned char Soft_Timer[9] = {16,16,4,2,59,2,20,30,2};
 127          idata unsigned char T0_cnt,T2_cnt , T1_cnt;
 128          idata unsigned char Temp_Flag = 3 ;
 129          idata unsigned char  t_code = 8 ;
 130          idata unsigned int  Data_Value[15];
 131          unsigned int  Temp_sp = 0 ;
 132          unsigned char MAIN_SW;
 133          unsigned char Work_Type;
 134          unsigned char C_F_Type;
 135          unsigned char TC_Type;
 136          unsigned int  TC_Zero_offset;
 137          unsigned int  TC_Span_offset;
 138          unsigned int  RTD_Zero_offset;
 139          unsigned int  RTD_Span_offset;
 140          unsigned int  mV_Zero_offset;
 141          unsigned int  mV_Span_offset;
 142          unsigned int  mA_Zero_offset;
 143          unsigned int  mA_Span_offset;
 144          unsigned int  alarm_Low_set;
 145          unsigned int  alarm_Hi_set;
 146          unsigned int  TC_Span_Value = 0;
 147          unsigned int  RTD_Span_Value = 0;
 148          unsigned int  mV_Span_Value = 0;
 149          unsigned int  mA_Span_Value = 0;
 150          unsigned int  Temp_offset = 0 ; 
 151          unsigned int  Temp_m = 0 ;  
 152          unsigned int  use_flag;
C51 COMPILER V9.02   MAIN                                                                  05/22/2015 15:09:11 PAGE 14  

 153          unsigned char  use_year = 0x14;
 154          unsigned char  use_mon  = 0x01;
 155          unsigned char  use_day  = 0x01;
 156          unsigned char  use_week = 0x03;
 157          unsigned char  use_hour = 0x12;
 158          unsigned char  use_min  = 0x01;
 159          unsigned char  use_sec  = 0x01;
 160          //unsigned char  eep_count;
 161          unsigned int   Disp_year;
 162          unsigned char  n_code = 0 ;
 163          unsigned char CAIT = 0x01;
 164          unsigned char Func_Type;
 165          unsigned char AD_Hi;
 166          unsigned char AD_Mid;
 167          unsigned char AD_Lo;
 168          unsigned char AD_Status;
 169          unsigned char PCB_SETUP;
 170          unsigned char Soft_Timer_Enable = 0;
 171          unsigned char Key_backup, ReceiveDate;
 172          
 173          bit f_half_sec;
 174          bit ReceiveFlag = 0;
 175          bit tran = 0 ;
 176          bit Zero_f = 0 ;
 177          /***************************************
 178                     Port In/Out Setting
 179          *****************************************/
 180          void PORT_Init(void)
 181          {
 182   1              P0M0 = 0xFF;      //00=Qb,01=pull output, 10= input only,11=open drain
 183   1              P0M1 = 0x00;     //P0= ALL INPUT
 184   1              P0   = 0xff;
 185   1      
 186   1              P1M0 = 0x00;     //P1= ALL OUTPUT
 187   1              P1M1 = 0xFF;     //SETUP P1 ALL LO //  define P1.3 P1.4 P1.5 as push-pull
 188   1          P1   = 0x00;
 189   1      
 190   1              P2M0 = 0x04;     //P2= ALL OUTOUT
 191   1              P2M1 = 0xDF;     //SETUP P2 ALL LO
 192   1              P2   = 0x00;
 193   1      
 194   1          P3M0 = 0xED;         //
 195   1              P3M1 = 0x13;
 196   1              P3   = 0x2C;
 197   1      }
 198          /*******************************************
 199               interrupt   0
 200          *******************************************/
 201          void ex_int0(void) interrupt 0
 202          {;
 203   1      }
 204          /*******************************************
 205               interrupt   1
 206          *******************************************/
 207          void time0(void) interrupt  1     //   T=1/16 sec 
 208          {
 209   1       unsigned int Value_code;
 210   1              TR0 = 0;
 211   1              T1_cnt++;
 212   1              if ((T1_cnt%8)==0)
 213   1              Value_code = SBUF;
 214   1              TH0 = 0x0B;      //0b
C51 COMPILER V9.02   MAIN                                                                  05/22/2015 15:09:11 PAGE 15  

 215   1              TL0 = 0xDC;
 216   1              TR0 = 1;
 217   1      }
 218          
 219          /*******************************************
 220               interrupt   3
 221          *******************************************/
 222          void time1(void) interrupt  3   //    T=1/16 sec 
 223          {
 224   1              TR1 = 0;
 225   1              T0_cnt++;                                                       
 226   1      
 227   1              if (Soft_Timer[DISPLAY_SEND_TIME] != 0)         Soft_Timer[DISPLAY_SEND_TIME]--;
 228   1              if (Soft_Timer[ADC_READ_TIME] != 0)         Soft_Timer[ADC_READ_TIME]--;
 229   1              if ((T0_cnt%8)==0)      
 230   1                {
 231   2                if (Soft_Timer[RTC_READ_TIME] != 0)   Soft_Timer[RTC_READ_TIME]--;
 232   2                  f_half_sec = 1;
 233   2                }
 234   1              if (T0_cnt == 15)
 235   1              {
 236   2                      T0_cnt = 0;
 237   2                      if (Soft_Timer[UART_SEND_TIME] != 0)    Soft_Timer[UART_SEND_TIME]--;
 238   2                      if (Soft_Timer[MV_SEND_TIME] != 0)          Soft_Timer[MV_SEND_TIME]--;
 239   2                      if (Soft_Timer[SETUP_TIMEOUT] != 0)     Soft_Timer[SETUP_TIMEOUT]--;    
 240   2                      if (Soft_Timer[TIMEUP_TIME] != 0)               Soft_Timer[TIMEUP_TIME]--;
 241   2                      if (Soft_Timer[TEMP_TIME] != 0)             Soft_Timer[TEMP_TIME]--;
 242   2              }               
 243   1              TH1 = 0x0B;
 244   1              TL1 = 0xDC;
 245   1              TR1 = 1;
 246   1       }              
 247          /*******************************************/
 248          void T0_Init(void)
 249          {
 250   1              TR0 = 1;
 251   1              TMOD = 0x11;
 252   1              TH0 = 0x0B;             
 253   1              TL0 = 0xDC;     
 254   1              T0_cnt = 0;
 255   1      }
 256          /*******************************************
 257              
 258          *******************************************/
 259          void T1_Init(void)
 260          {
 261   1              TR1 = 0;
 262   1              TMOD = 0x11;  
 263   1              TH1 = 0x0B;
 264   1              TL1 = 0xDC;
 265   1              T1_cnt = 0;
 266   1       }
 267          /*******************************************
 268              
 269          *******************************************/
 270          void T2_Init(void)
 271          {
 272   1              TR2 = 1;
 273   1              T2MOD = 0x11;  //11  
 274   1              TH2 = 0x0B;
 275   1              TL2 = 0xDC;
 276   1              T2_cnt = 0;
C51 COMPILER V9.02   MAIN                                                                  05/22/2015 15:09:11 PAGE 16  

 277   1      }
 278          /*******************************************
 279              
 280          *******************************************/
 281          void INT0_Init(void)
 282          {
 283   1          INT0 = 1;
 284   1              INT1 = 1;        
 285   1              IE0  = 1;                  
 286   1              IT0  = 1;
 287   1              EX0  = 0;         
 288   1      }
 289          /*******************************************/
 290          void InitUart()    //InitUart use timer2
 291          {
 292   1         SCON |= 0x50;                          /* uart in mode 1 (8 bit), REN=1 50 */
 293   1         T2CON &= 0xF0;               /* EXEN2=0; TR2=0; C/T2#=0; CP/RL2#=0; */
 294   1         T2CON |= 0x30;               /* RCLK = 1; TCLK=1; */
 295   1         TH2=0xFF;                    /* init value */
 296   1         TL2=0xD0;                    /* init value */
 297   1         RCAP2H=0xFF;                 /* reload value, 9600 Bds at 11.059MHz */
 298   1         RCAP2L=0xDC;                /* reload value, 9600 Bds at 11.059MHz */
 299   1         ES = 1;                                                   /* Enable serial interrupt */
 300   1         TR2 = 1;                     /* Timer 2 run */
 301   1      }
 302          /*************************************************/
 303          void serial() interrupt 4
 304          {
 305   1              if(TI==1)
 306   1               {
 307   2                TI = 0 ;
 308   2                }                
 309   1          if(RI==1)
 310   1               {
 311   2                 RI=0;
 312   2                 ReceiveDate = SBUF;
 313   2                 ReceiveFlag = 1;
 314   2               }
 315   1      }
 316          /****************************************/
 317          void delay(unsigned int i)
 318          {
 319   1              unsigned char j;
 320   1              for (; i>0; i--)
 321   1                      for (j=0; j<255; j++);
 322   1      }
 323          /*******************************************
 324              
 325          *******************************************/
 326          void Buzzer(unsigned char status)
 327          {
 328   1              if (status)
 329   1            P3 =      P3 |= 0x10;
 330   1              else
 331   1                P3 = P3 &= ~0x10;
 332   1      }
 333          /*******************************************
 334                CHECK PCB TYPE
 335          *******************************************/
 336          void Check_PCB(void)
 337          {
 338   1                 if(P00 == 0)                //tc
C51 COMPILER V9.02   MAIN                                                                  05/22/2015 15:09:11 PAGE 17  

 339   1                   {
 340   2                           Work_Type = 0x00;
 341   2                               Func_Type = 0x00;
 342   2                               PCB_SETUP = 0x01;
 343   2                           if(P04 == 0)           //mV_out
 344   2                             {PCB_SETUP = 0x11 ;}
 345   2                       if(P05 == 0)   //mA_out
 346   2                             {PCB_SETUP = 0x21 ;}
 347   2                               if(use_flag == 0x0001) { NG_COD = 1;}
 348   2                       }
 349   1                 else if(P01 == 0)           //rtd
 350   1                       {
 351   2                                Work_Type = 0x01;
 352   2                                Func_Type = 0x01;
 353   2                                  PCB_SETUP = 0x02 ;
 354   2                            if(P04 == 0)      //mV_out
 355   2                              {PCB_SETUP = 0x12 ;}
 356   2                            if(P05 == 0)      //mA_out
 357   2                              {PCB_SETUP = 0x22 ;}
 358   2                                 if(use_flag == 0x0002) { NG_COD = 1;}
 359   2                       }
 360   1                else if(P02 == 0)          //mV
 361   1                       {
 362   2                               Work_Type = 0x02 ;
 363   2                               Func_Type = 0x02;
 364   2                                PCB_SETUP = 0x04 ;
 365   2                                if(P04 == 0)  //mV_out
 366   2                              {PCB_SETUP = 0x14 ;}
 367   2                            if(P05 == 0)      //mA_out
 368   2                              {PCB_SETUP = 0x24 ;}
 369   2                                 if(use_flag == 0x0004) { NG_COD = 1;}
 370   2                       } 
 371   1                else if(P03 == 0)             //mA
 372   1                       { 
 373   2                           Work_Type = 0x03 ;
 374   2                               Func_Type = 0x03;
 375   2                                 PCB_SETUP = 0x08 ;
 376   2                               if(P04 == 0)           //mV_out
 377   2                             {PCB_SETUP = 0x18 ;}
 378   2                           if(P05 == 0)       //mA_out
 379   2                             {PCB_SETUP = 0x28 ;}
 380   2                               if(use_flag == 0x0008) { NG_COD = 1;}  
 381   2                       }
 382   1      }
 383          /***********************************************/
 384          unsigned int TEMP_F_TO_C(unsigned int tc_tmp)
 385          {
 386   1       unsigned int ttmp;
 387   1      
 388   1                if(NP_COD == 1)
 389   1                  {
 390   2                       if(tc_tmp >= 32)
 391   2                    {
 392   3                          if(AV_COD == 0)
 393   3                            {
 394   4                              ttmp = (tc_tmp-32)/1.8;
 395   4                            }
 396   3                        else
 397   3                           {
 398   4                                  ttmp = (tc_tmp+32)/1.8; 
 399   4                   }
 400   3                    }
C51 COMPILER V9.02   MAIN                                                                  05/22/2015 15:09:11 PAGE 18  

 401   2                  else
 402   2                    {
 403   3                         if(AV_COD == 0)
 404   3                               {
 405   4                         ttmp = (32-tc_tmp)/1.8;
 406   4                                 AV_COD = 1 ;
 407   4                   }
 408   3                         else
 409   3                           {
 410   4                                ttmp = (32+tc_tmp)/1.8;
 411   4                                
 412   4                               }
 413   3                        }
 414   2            }
 415   1          else
 416   1                {               
 417   2                 if(tc_tmp >= 320)
 418   2                    {
 419   3                          if(AV_COD == 0)
 420   3                            {
 421   4                              ttmp = (tc_tmp-320)/1.8;
 422   4                            }
 423   3                        else
 424   3                           {
 425   4                                  ttmp = (tc_tmp+320)/1.8; 
 426   4                   }
 427   3                    }
 428   2                  else
 429   2                    {
 430   3                         if(AV_COD == 0)
 431   3                               {
 432   4                         ttmp = (320-tc_tmp)/1.8;
 433   4                                       AV_COD = 1 ;
 434   4                   }
 435   3                         else
 436   3                           {
 437   4                                ttmp = (320+tc_tmp)/1.8;
 438   4                               }
 439   3                       }
 440   2                 }
 441   1            return(ttmp);
 442   1      }
 443          /**********************************************/
 444          void Volt_Ctrl(void)
 445          {
 446   1      }
 447          /*********************************
 448              15782,15956,16125,16288,16448,16605,16757,16907,17029,17148,17266,
 449              17380,17493,17593,17692,17789,17884,17978,18060,18141,18221,18299,18377,18443,18509,18573,18637,18700,
             -18756,18811,18865,18919,
 450              18972,19022,19072,19121,19170,19219,19255,19291,19326,19362,19397,19430,19462,19495,19527,19559,19586,
             -19613,19641,19668,19695,
 451              19719,19742,19766,19790,19814,19832,19851,19870,19888,19907,19926,19945,19963,19982,20001,
 452          *******273.5 K *****/                                                                                                                                                     
 453          unsigned int Temp_Read(void)
 454          {
 455   1      unsigned int Temp_Count,P_count;
 456   1                   TEMP = 1;
 457   1                        P_count = 0;
 458   1                        delay(1);
 459   1                      while(TEMP)
 460   1                         { ; P_count = P_count + 1 ;}   
C51 COMPILER V9.02   MAIN                                                                  05/22/2015 15:09:11 PAGE 19  

 461   1                          TEMP = 0 ;
 462   1                   if(P_count > 0x7a10){Temp_Count = 0;}       //7010
 463   1                       else{ Temp_Count = ( 0x7a10 - P_count)/19.4; //9.936 ;1760 2329 
 464   2                         if(Temp_Count > 121)
 465   2                                      { Temp_Count = Temp_Count-(Temp_Count-120)/12 ;  
 466   3                                            if(Temp_Count > 252)
 467   3                                          { Temp_Count = Temp_Count + (Temp_Count-251)/20 ;
 468   4                                                if(Temp_Count > 281)
 469   4                                              { Temp_Count = Temp_Count-(Temp_Count-280)/18 ;
 470   5                                                    if(Temp_Count > 401)                        //1212
 471   5                                                   { Temp_Count = Temp_Count + (Temp_Count-400)/28;
 472   6                                                            if(Temp_Count > 541)
 473   6                                                          { Temp_Count = Temp_Count+(Temp_Count-540)/15; 
 474   7                                                               if(Temp_Count > 641)
 475   7                                                              { Temp_Count = Temp_Count+(Temp_Count-640)/16;
 476   8                                                                if(Temp_Count > 731)                                             
 477   8                                                                     { Temp_Count = Temp_Count+(Temp_Count-730)/11;   //
 478   9                                                                          if(Temp_Count > 861)
 479   9                                                                        { Temp_Count = Temp_Count+(Temp_Count-860)/8;
 480  10                                                                             if(Temp_Count > 941)
 481  10                                                                           { Temp_Count = Temp_Count+(Temp_Count-940)/14;
 482  11                                                                                if(Temp_Count > 1011)
 483  11                                                                              { Temp_Count = Temp_Count+(Temp_Count-1010)/10; 
 484  12                                                                                                                              if(Temp_Count > 1041)
 485  12                                                                                { Temp_Count = Temp_Count-(Temp_Count-1040)/14;
 486  13                                                                                     if(Temp_Count > 1081)
 487  13                                                                                   { Temp_Count = Temp_Count+(Temp_Count-1080)/5;
 488  14                                                                                       if(Temp_Count > 1181)
 489  14                                                                                     { Temp_Count = Temp_Count+(Temp_Count-1180)/9;
 490  15                                                                                          if(Temp_Count > 1271)
 491  15                                                                                        { Temp_Count = Temp_Count+(Temp_Count-1270)/1
             -0;
 492  16                                                                                             if(Temp_Count > 1361)
 493  16                                                                                           { Temp_Count = Temp_Count+(Temp_Count-1360
             -)/6;
 494  17                                                                                               if(Temp_Count > 1491)
 495  17                                                                                         { Temp_Count = Temp_Count + (Temp_Co
             -unt-1490)/8;
 496  18                                                                                                  if(Temp_Count > 1541)
 497  18                                                                                            { Temp_Count = Temp_Count + (Temp
             -_Count-1540)/4;
 498  19                                                                                                                                                                   if(Temp_Count > 1726)
 499  19                                                                                                     { Temp_Count = Temp_Count+(Temp_
             -Count-1720)/10;
 500  20                                                                                                                                                                      }}}}}}}}}} }}}}}}} }
 501   2                  }
 502   1          return(Temp_Count);
 503   1      }
 504          /***********************************************/
 505          unsigned char Get_Key(void)
 506          {
 507   1        if(FUNCTION_KEY == 1 && OFFSET_KEY == 1 && UP_KEY == 1 && DOWN_KEY == 1) 
 508   1          {
 509   2               key_bak  =  0;
 510   2               key = 0 ; 
 511   2              }
 512   1        else if(FUNCTION_KEY == 0 )
 513   1          {
 514   2                if(key_bak == 0)
 515   2                 {
 516   3                   key_bak = 1 ;
 517   3                   key = key |= 0x01 ;
C51 COMPILER V9.02   MAIN                                                                  05/22/2015 15:09:11 PAGE 20  

 518   3                 }
 519   2                else
 520   2                 {
 521   3                      key = key &= 0xfe ;
 522   3                 }
 523   2               }
 524   1         else if(OFFSET_KEY == 0)
 525   1           {
 526   2               if(key_bak == 0)
 527   2                 {
 528   3                   key = key |= 0x02 ;
 529   3                   key_bak = 1; 
 530   3                 }
 531   2                else
 532   2                 {
 533   3                      key = key &= 0xfd ;
 534   3                 }
 535   2               }
 536   1         else if(UP_KEY == 0)
 537   1          {
 538   2               if(key_bak == 0)
 539   2                 {
 540   3                   key = key |= 0x04 ;
 541   3                   key_bak = 1; 
 542   3                 }
 543   2                else
 544   2                 {
 545   3                      key = key &= 0xfb ;
 546   3                 }
 547   2               }
 548   1         else if(DOWN_KEY == 0)
 549   1          {
 550   2               if(key_bak == 0)
 551   2                 {
 552   3                   key = key |= 0x08;
 553   3                   key_bak = 1; 
 554   3                 }
 555   2                else
 556   2                 {
 557   3                      key = key &= 0xf7 ;
 558   3                 }
 559   2               }
 560   1       
 561   1         return key;
 562   1      }
 563          /*******************************
 564          
 565          ********************************/
 566          unsigned  int DO_TC_TYPE(void)
 567          {
 568   1          unsigned int Code_Value,TC_Value,TT_Value,TA_Value ;
 569   1               unsigned char key;
 570   1      
 571   1            key = Get_Key();
 572   1               
 573   1                if(key == 0x01)
 574   1                {
 575   2                   Func_Type = 4;
 576   2                }
 577   1         else
 578   1           { 
 579   2                if(Temp_Flag != 0 ){Temp_m = Temp_offset;}
C51 COMPILER V9.02   MAIN                                                                  05/22/2015 15:09:11 PAGE 21  

 580   2            if (Soft_Timer[TEMP_TIME] == 0)
 581   2              {
 582   3                        Soft_Timer[TEMP_TIME] = 4;
 583   3                     Data_Value[n_code] = Temp_Read() ;
 584   3                     if(n_code < 4){n_code++;}
 585   3                    else{ Temp_m = (Data_Value[3]/4+Data_Value[2]/4+Data_Value[1]/4+Data_Value[0]/4) ;
 586   4                                        n_code = 0 ;
 587   4                                   if(Temp_Flag != 0){Temp_Flag-- ;} }
 588   3                      }
 589   2                      if (Soft_Timer[ADC_READ_TIME] == 0) 
 590   2                        {
 591   3                            Soft_Timer[ADC_READ_TIME] = 16;
 592   3                               Data_Value[t_code] = Read_AD3421_Value();
 593   3      
 594   3                               if(t_code < 13)
 595   3                                  {t_code++; Code_Value = Data_Value[13];}
 596   3                               else{ Data_Value[13] = (Data_Value[12]/5+Data_Value[11]/5+Data_Value[10]/5+Data_Value[9]/5+Data_Value[
             -8]/5) ;
 597   4                                        t_code = 8;}
 598   3      
 599   3                          if (TC_Type == K_TYPE)
 600   3                    { 
 601   4                                  Temp_sp = (Temp_m*24)/10;
 602   4                                  TT_Value = Check_Type_Offset(Code_Value); 
 603   4                                  TC_Value = Get_K_Slope(TT_Value);
 604   4                                      TT_Value = TC_Value/48.8 ;
 605   4                                      TA_Value = (TC_Value/38+163) ;
 606   4                                      if (C_F_Type == 0) TC_Value = TEMP_F_TO_C(TC_Value); //
 607   4                        }
 608   3                  else if (TC_Type == J_TYPE)
 609   3                    { 
 610   4                                  Temp_sp = (Temp_m*30)/10;    //300
 611   4                                  TT_Value = Check_Type_Offset(Code_Value);
 612   4                                      TC_Value = Get_J_Slope(TT_Value);
 613   4                                  TT_Value = TC_Value/27.4 ;
 614   4                                  TA_Value = (TC_Value/21.4+163) ;
 615   4                                      if (C_F_Type == 0) TC_Value = TEMP_F_TO_C(TC_Value); //
 616   4                        }
 617   3                  else if (TC_Type == T_TYPE)
 618   3                    {
 619   4                                  Temp_sp = (Temp_m*23)/10;     //1.044
 620   4                                  TT_Value = Check_Type_Offset(Code_Value);
 621   4                                  TC_Value = Get_T_Slope(TT_Value);
 622   4                              TT_Value = TC_Value/7.5 ;
 623   4                                      TA_Value = (TC_Value/6+163) ;
 624   4                                      if (C_F_Type == 0) TC_Value = TEMP_F_TO_C(TC_Value); // 
 625   4                        }
 626   3                  else if (TC_Type == E_TYPE)
 627   3                    { 
 628   4                                  Temp_sp = (Temp_m*35)/10;   // 1.54
 629   4                              TT_Value = Check_Type_Offset(Code_Value);
 630   4                                  TC_Value = Get_E_Slope(TT_Value);
 631   4                                  TT_Value = TC_Value/28.3 ;
 632   4                                  TA_Value = (TC_Value/22.5+163) ;
 633   4                                 if (C_F_Type == 0) TC_Value = TEMP_F_TO_C(TC_Value);  //
 634   4                        }
 635   3                  else if (TC_Type == R_TYPE)
 636   3                   {  NP_COD = 1;
 637   4                                  Temp_sp = (Temp_m*5)/10;//Temp_offset/12;
 638   4                                      TT_Value = Check_Type_Offset(Code_Value);
 639   4                                  TC_Value = Get_R_Slope(TT_Value);
 640   4                                  TT_Value = TC_Value/56.8 ;
C51 COMPILER V9.02   MAIN                                                                  05/22/2015 15:09:11 PAGE 22  

 641   4                                  TA_Value = (TC_Value/44.5+163) ;
 642   4                                 if (C_F_Type == 0)  TC_Value = TEMP_F_TO_C(TC_Value);
 643   4                        }
 644   3                  else if (TC_Type == S_TYPE)
 645   3                    {    NP_COD = 1;
 646   4                                   Temp_sp = (Temp_m*5)/10;//Temp_offset/12;
 647   4                                       TT_Value = Check_Type_Offset(Code_Value);
 648   4                                       TC_Value = Get_S_Slope(TT_Value);
 649   4                                   TT_Value = TC_Value/56.8 ;
 650   4                                       TA_Value = (TC_Value/44.5+163) ;
 651   4                                      if (C_F_Type == 0)      TC_Value = TEMP_F_TO_C(TC_Value); 
 652   4                        }
 653   3                        }
 654   2                  if (Soft_Timer[RTC_READ_TIME] == 0)
 655   2                     {
 656   3                               RTC_READ_SET();
 657   3                               Soft_Timer[RTC_READ_TIME] = 8;
 658   3                         }
 659   2                  if (Soft_Timer[DISPLAY_SEND_TIME] == 0)
 660   2                    {
 661   3                           Soft_Timer[DISPLAY_SEND_TIME] = 32;        
 662   3                                 LED_Disp(1,TC_Value);
 663   3      //                         LED_Disp(1,Temp_m);
 664   3                          if ((TC_Value > alarm_Low_set)&&(TC_Value < alarm_Hi_set))
 665   3                        { BEEP_OUT = 1; }
 666   3                              else
 667   3                                { BEEP_OUT = 0; }
 668   3                        }
 669   2                  if (Soft_Timer[MV_SEND_TIME] == 0)
 670   2                   {
 671   3                         if( P04 == 0) Set_mV(TT_Value);
 672   3      
 673   3                         if( P05 == 0) Set_mA(TA_Value);
 674   3                         Soft_Timer[MV_SEND_TIME] = 16;
 675   3                       }
 676   2                  if (Soft_Timer[UART_SEND_TIME] == 0)
 677   2                   {
 678   3                        if(tran == 0)
 679   3                          {
 680   4                              SBUF = TC_Value ;
 681   4                               tran = 1 ;
 682   4                               Soft_Timer[UART_SEND_TIME] = 1;
 683   4                     }
 684   3                   else
 685   3                    { 
 686   4                      SBUF = TC_Value >> 8 ;
 687   4                      tran = 0;
 688   4                              Soft_Timer[UART_SEND_TIME] = 59 ;
 689   4                        }
 690   3                      TI = 1;
 691   3                }
 692   2              }
 693   1          return  TC_Value;
 694   1      }
 695          /*************************************************************************************/
 696          unsigned int Check_Type_Offset(unsigned int Code_Value)
 697          {
 698   1          unsigned int Count_Value;
 699   1           if (NG_COD == 0)
 700   1             {
 701   2                  if (AV_COD == 0)
 702   2                        {
C51 COMPILER V9.02   MAIN                                                                  05/22/2015 15:09:11 PAGE 23  

 703   3                         if(Code_Value >= TC_Zero_offset)        
 704   3                           {
 705   4                        if((Code_Value - TC_Zero_offset) >= Temp_sp)
 706   4                           { Count_Value = (Code_Value - TC_Zero_offset) - Temp_sp ;}
 707   4                         else
 708   4                                   {Count_Value = (Temp_sp + TC_Zero_offset)- Code_Value; AV_COD = 1 ; }
 709   4                        }
 710   3                               else
 711   3                                {   
 712   4                             if((TC_Zero_offset - Code_Value) >= Temp_sp)
 713   4                                  {Count_Value = TC_Zero_offset - (Code_Value + Temp_sp);AV_COD = 1 ;}
 714   4                         else
 715   4                          { Count_Value =  (Temp_sp + TC_Zero_offset) - Code_Value; AV_COD = 1 ; }
 716   4                            }
 717   3                         }
 718   2                else    // AV_COD = 1  NG_COD = 0
 719   2                     {
 720   3                           if(Code_Value >= TC_Zero_offset)
 721   3                                 {
 722   4                                  if((Code_Value - TC_Zero_offset) >= Temp_sp)
 723   4                                { Code_Value = (Code_Value + TC_Zero_offset) + Temp_sp;}
 724   4                                  else
 725   4                                    { Code_Value =  Temp_sp + ( Code_Value + TC_Zero_offset);}
 726   4                                 }
 727   3                           else
 728   3                                 {      // AV_COD = 1  NG_COD = 0
 729   4                                  if((TC_Zero_offset- Code_Value ) >= Temp_sp)
 730   4                                { Code_Value = ( Code_Value + TC_Zero_offset) + Temp_sp;}
 731   4                                  else
 732   4                                    { Code_Value = Temp_sp + (Code_Value + TC_Zero_offset) ;}
 733   4                                 }
 734   3                         }
 735   2                 }
 736   1            else
 737   1                 {
 738   2                   if(AV_COD == 0)  // AV_COD = 0      NG_COD = 1
 739   2                         {
 740   3                               Count_Value = Code_Value + TC_Zero_offset ;
 741   3                          if(Count_Value >= Temp_sp)
 742   3                           { Count_Value =  Count_Value - Temp_sp ;}
 743   3                      else
 744   3                       {Count_Value = Temp_sp  - Count_Value; AV_COD = 1; }
 745   3                     }
 746   2                else    // AV_COD = 1  NG_COD = 1
 747   2                     {
 748   3                           if(Code_Value >= TC_Zero_offset)
 749   3                                 {
 750   4                                       Count_Value = Code_Value - TC_Zero_offset ;
 751   4      
 752   4                                  if(Count_Value >= Temp_sp)
 753   4                                { Count_Value = Count_Value + Temp_sp;} 
 754   4                                  else
 755   4                                    { Count_Value = Temp_sp + Count_Value;}
 756   4                                 }
 757   3                           else
 758   3                                 {
 759   4                                       Count_Value = TC_Zero_offset - Code_Value;
 760   4                                  if( Count_Value >= Temp_sp)
 761   4                                { Count_Value =  Count_Value - Temp_sp ; AV_COD = 0;}
 762   4                                  else
 763   4                                    { Count_Value = Temp_sp -Count_Value; AV_COD = 1;}
 764   4                                 }                                                                                                               
C51 COMPILER V9.02   MAIN                                                                  05/22/2015 15:09:11 PAGE 24  

 765   3                         }
 766   2                 }
 767   1      
 768   1         if(ADD_COD == 1 ) 
 769   1               { Count_Value = Count_Value - (Count_Value/81); }        //TC_Span_Value
 770   1         else
 771   1               { Count_Value = Count_Value + (Count_Value/81);}
 772   1                 
 773   1              if(OVER_COD == 1){ Count_Value = 0xffff;}
 774   1      
 775   1        return Count_Value;
 776   1      }
 777          /***********************************************
 778          RTD=  2 27.6    40      48      56      58
 779          131072                                  
 780          3200 2600 1950    950  40
 781          1300 2200  3250  4100    5000 5750      6450
 782          7350 7950  8700  9300  9900     10500    11150
 783          11700 12300     12850   13400 
 784          *************************************************/
 785          unsigned int DO_RTD_TYPE(void)
 786          {
 787   1        unsigned int RTD_Value; 
 788   1        unsigned char key;     
 789   1      
 790   1            key = Get_Key();
 791   1               
 792   1                if(key == 0x01)
 793   1                {
 794   2                   Func_Type =  4;
 795   2                }
 796   1              else
 797   1                {
 798   2                      if (Soft_Timer[ADC_READ_TIME] == 0) 
 799   2                         {
 800   3                               Soft_Timer[ADC_READ_TIME] = 16;
 801   3      
 802   3                                RTD_Value = Read_AD3421_Value();
 803   3      
 804   3                               if((NG_COD == 1)&&(AV_COD == 1))
 805   3                                 {
 806   4                                                if( RTD_Value >= RTD_Zero_offset)
 807   4                                                  {
 808   5                                                   RTD_Value = RTD_Value - RTD_Zero_offset;
 809   5                                                      }
 810   4                                                 else
 811   4                                                  {
 812   5                                                       RTD_Value = RTD_Zero_offset -RTD_Value;
 813   5                                                       AV_COD = 0;
 814   5                                                      }
 815   4                                      }
 816   3                                else if((NG_COD == 1)&&(AV_COD == 0))
 817   3                                  {
 818   4                                                   RTD_Value = RTD_Value + RTD_Zero_offset;
 819   4                                  }                   
 820   3                                else if((NG_COD == 0)&&(AV_COD == 1))
 821   3                                  {
 822   4                                                   RTD_Value = RTD_Value + RTD_Zero_offset;
 823   4                                  }   
 824   3                                else if((NG_COD == 0)&&(AV_COD == 0))
 825   3                                  {
 826   4                                             if( RTD_Value >= RTD_Zero_offset)
C51 COMPILER V9.02   MAIN                                                                  05/22/2015 15:09:11 PAGE 25  

 827   4                                                  {
 828   5                                                   RTD_Value = RTD_Value - RTD_Zero_offset;
 829   5                                                      }
 830   4                                                 else
 831   4                                                  {
 832   5                                                       RTD_Value = RTD_Zero_offset -RTD_Value;
 833   5                                                   AV_COD = 1 ;
 834   5                                                      }
 835   4                                      }
 836   3                                         if(RTD_Span_offset > 0x44e4)
 837   3                                               {  RTD_Value = RTD_Value +(RTD_Value/RTD_Span_Value);}
 838   3                                        else
 839   3                                               {  RTD_Value = RTD_Value - (RTD_Value/RTD_Span_Value);}
 840   3                                       if(OVER_COD == 1) RTD_Value = 0xffff;
 841   3                    RTD_Value = Get_RTD_Slope(RTD_Value);
 842   3       
 843   3                       if (C_F_Type == 0)     RTD_Value = TEMP_F_TO_C(RTD_Value);
 844   3                     }
 845   2               if (Soft_Timer[DISPLAY_SEND_TIME] == 0)
 846   2                {
 847   3                         LED_Disp(1,RTD_Value);
 848   3                         Soft_Timer[DISPLAY_SEND_TIME] = 16 ;
 849   3      
 850   3                               if ((RTD_Value > alarm_Low_set)&&(RTD_Value < alarm_Hi_set))
 851   3                        { BEEP_OUT = 1; }
 852   3                              else
 853   3                                { BEEP_OUT = 0; }
 854   3                        }
 855   2                  if (Soft_Timer[MV_SEND_TIME] == 0)
 856   2                    {
 857   3                         if( P04 == 0) Set_mV(RTD_Value);
 858   3                         if( P05 == 0) Set_mA(RTD_Value);
 859   3      
 860   3                         Soft_Timer[MV_SEND_TIME] = 2;
 861   3                        }
 862   2                  if (Soft_Timer[RTC_READ_TIME] == 0)
 863   2                   {
 864   3                         RTC_READ_SET();
 865   3                         Soft_Timer[RTC_READ_TIME] = 8 ;
 866   3                       }
 867   2                  if (Soft_Timer[UART_SEND_TIME] == 0)
 868   2                    {
 869   3                         if(tran == 0)
 870   3                          {
 871   4                              SBUF = RTD_Value ;
 872   4                               tran = 1 ;
 873   4                               Soft_Timer[UART_SEND_TIME] = 1;
 874   4                     }
 875   3                   else
 876   3                    { 
 877   4                      SBUF = RTD_Value >> 8 ;
 878   4                      tran = 0;
 879   4                              Soft_Timer[UART_SEND_TIME] = 59 ;
 880   4                        }
 881   3                      TI = 1;
 882   3                 }
 883   2          }
 884   1         return RTD_Value;
 885   1      }
 886          /***********************************************
 887          
 888          ************************************************/
C51 COMPILER V9.02   MAIN                                                                  05/22/2015 15:09:11 PAGE 26  

 889          unsigned  int DO_mV_TYPE(void)
 890          {
 891   1           unsigned int mV_Value;
 892   1               unsigned char key;
 893   1      
 894   1            key = Get_Key();
 895   1               
 896   1                if(key == 0x01)
 897   1                  {
 898   2                    Func_Type = 4;
 899   2                  }
 900   1                else 
 901   1                  {
 902   2                       if (Soft_Timer[ADC_READ_TIME] == 0) 
 903   2                        {
 904   3                          Soft_Timer[ADC_READ_TIME] = 16;
 905   3      
 906   3                          mV_Value = Read_AD3421_Value();
 907   3      
 908   3                               
 909   3                               if((NG_COD == 1)&&(AV_COD == 1))
 910   3                                 {
 911   4                                                if( mV_Value > mV_Zero_offset)                
 912   4                                                  {
 913   5                                                   mV_Value = mV_Value - mV_Zero_offset;
 914   5                                                      }
 915   4                                                 else
 916   4                                                  {
 917   5                                                       mV_Value = mV_Zero_offset -mV_Value;
 918   5                                                       AV_COD = 0;
 919   5                                                      }
 920   4                                      }
 921   3                                else if((NG_COD == 1)&&(AV_COD == 0))
 922   3                                  {
 923   4                                                   mV_Value = mV_Value + mV_Zero_offset;
 924   4                                  }                   
 925   3                                else if((NG_COD == 0)&&(AV_COD == 1))
 926   3                                  {
 927   4                                                   mV_Value = mV_Value + mV_Zero_offset;
 928   4                                  }   
 929   3                                else if((NG_COD == 0)&&(AV_COD == 0))
 930   3                                  {
 931   4                                             if( mV_Value >= mV_Zero_offset)
 932   4                                                  {
 933   5                                                   mV_Value = mV_Value - mV_Zero_offset;
 934   5                                                      }
 935   4                                                 else
 936   4                                                  {
 937   5                                                       mV_Value = mV_Zero_offset -mV_Value;
 938   5                                                   AV_COD = 1 ;
 939   5                                                      }
 940   4                                      }
 941   3                                         if(mV_Span_offset > 0x0c80)
 942   3                                               { mV_Value = mV_Value + (mV_Value/mV_Span_Value); }
 943   3                                        else
 944   3                                               { mV_Value = mV_Value - (mV_Value/mV_Span_Value); }
 945   3      
 946   3      //                                      mV_Value = 0x7d00 ;
 947   3      //                                              mV_Value = 0 ;
 948   3                       
 949   3                                      mV_Value = mV_Value/3.2;
 950   3      //                      mV_Value = mV_Value/5.29;
C51 COMPILER V9.02   MAIN                                                                  05/22/2015 15:09:11 PAGE 27  

 951   3                              if(OVER_COD == 1) mV_Value = 0xffff;     
 952   3                       }
 953   2                 if (Soft_Timer[DISPLAY_SEND_TIME] == 0)
 954   2                   {
 955   3                          LED_Disp(1,mV_Value);
 956   3                          Soft_Timer[DISPLAY_SEND_TIME] = 8 ;
 957   3      
 958   3                               if ((mV_Value > alarm_Low_set)&&(mV_Value < alarm_Hi_set))
 959   3                        { BEEP_OUT = 1; }
 960   3                              else
 961   3                                { BEEP_OUT = 0; }
 962   3                   }
 963   2                 if (Soft_Timer[MV_SEND_TIME] == 0)
 964   2                   {
 965   3                         if( P04 == 0)  Set_mV(mV_Value);
 966   3                         if( P05 == 0)  Set_mA(mV_Value);
 967   3      
 968   3                         Soft_Timer[MV_SEND_TIME] = 2;
 969   3                       }
 970   2                if (Soft_Timer[RTC_READ_TIME] == 0)
 971   2                  {
 972   3                        RTC_READ_SET();
 973   3                        Soft_Timer[RTC_READ_TIME] = 8 ;
 974   3                      }
 975   2                 if (Soft_Timer[UART_SEND_TIME] == 0)
 976   2                   {
 977   3                         if(tran == 0)
 978   3                          {
 979   4                              SBUF = mV_Value ;
 980   4                               tran = 1 ;
 981   4                               Soft_Timer[UART_SEND_TIME] = 1;
 982   4                     }
 983   3                   else
 984   3                    { 
 985   4                      SBUF = mV_Value >> 8 ;
 986   4                      tran = 0;
 987   4                              Soft_Timer[UART_SEND_TIME] = 59 ;
 988   4                        }
 989   3                      TI = 1;
 990   3                       }
 991   2                }
 992   1               return mV_Value ;
 993   1      }
 994          /***********************************************
 995          
 996          *************************************************/
 997          unsigned int DO_mA_TYPE(void)
 998          {
 999   1           unsigned int mA_Value;
1000   1               unsigned char key;
1001   1      
1002   1            key = Get_Key();
1003   1               
1004   1                if(key == 0x01)
1005   1                  {
1006   2                    Func_Type = 4 ;
1007   2                  }
1008   1                else 
1009   1                  {
1010   2                       if (Soft_Timer[ADC_READ_TIME] == 0) 
1011   2                         {
1012   3                                   Soft_Timer[ADC_READ_TIME] = 16;
C51 COMPILER V9.02   MAIN                                                                  05/22/2015 15:09:11 PAGE 28  

1013   3      
1014   3                                       mA_Value = Read_AD3421_Value();
1015   3      
1016   3                               if((NG_COD == 1)&&(AV_COD == 1))
1017   3                                 {
1018   4                                                if( mA_Value >= mA_Zero_offset)
1019   4                                                  {
1020   5                                                   mA_Value = mA_Value - mA_Zero_offset;
1021   5                                                      }
1022   4                                                 else
1023   4                                                  {
1024   5                                                       mA_Value = mA_Zero_offset -mA_Value;
1025   5                                                       AV_COD = 0;
1026   5                                                      }
1027   4                                      }
1028   3                                else if((NG_COD == 1)&&(AV_COD == 0))
1029   3                                  {
1030   4                                                   mA_Value = mA_Value + mA_Zero_offset;
1031   4                                  }                   
1032   3                                else if((NG_COD == 0)&&(AV_COD == 1))
1033   3                                  {
1034   4                                                   mA_Value = mA_Value + mA_Zero_offset;
1035   4                                  }   
1036   3                                else if((NG_COD == 0)&&(AV_COD == 0))
1037   3                                  {
1038   4                                             if( mA_Value >= mA_Zero_offset)
1039   4                                                  {
1040   5                                                   mA_Value = mA_Value - mA_Zero_offset;
1041   5                                                      }
1042   4                                                 else
1043   4                                                  {
1044   5                                                       mA_Value = mA_Zero_offset -mA_Value;
1045   5                                                   AV_COD = 1 ;
1046   5                                                      }
1047   4                                      }
1048   3                                         if(mA_Span_offset >  0x1900)
1049   3                                               { mA_Value = mA_Value + (mA_Value/mA_Span_Value); }
1050   3                                        else
1051   3                                               { mA_Value = mA_Value - (mA_Value/mA_Span_Value); }
1052   3      
1053   3                                       mA_Value = mA_Value/3.2 ;
1054   3      
1055   3                                       if(OVER_COD == 1) mA_Value = 0xffff;
1056   3                        }
1057   2                 if (Soft_Timer[DISPLAY_SEND_TIME] == 0)
1058   2                   {
1059   3                          LED_Disp(1,mA_Value);
1060   3                          Soft_Timer[DISPLAY_SEND_TIME] = 16 ;
1061   3      
1062   3                               if ((mA_Value > alarm_Low_set)&&(mA_Value < alarm_Hi_set))
1063   3                        { BEEP_OUT = 1; }
1064   3                              else
1065   3                                { BEEP_OUT = 0; }
1066   3                   }
1067   2                 if (Soft_Timer[MV_SEND_TIME] == 0)
1068   2                   {
1069   3                         if( P04 == 0)  Set_mV(mA_Value);
1070   3                         if( P05 == 0)  Set_mA(mA_Value);
1071   3      
1072   3                         Soft_Timer[MV_SEND_TIME] = 2;
1073   3                       }
1074   2                 if (Soft_Timer[RTC_READ_TIME] == 0)
C51 COMPILER V9.02   MAIN                                                                  05/22/2015 15:09:11 PAGE 29  

1075   2                  {
1076   3                        RTC_READ_SET();
1077   3                        Soft_Timer[RTC_READ_TIME] = 8 ;
1078   3                      }
1079   2                 if (Soft_Timer[UART_SEND_TIME] == 0)
1080   2                   {
1081   3                         if(tran == 0)
1082   3                          {
1083   4                              SBUF = mA_Value ;
1084   4                               tran = 1 ;
1085   4                               Soft_Timer[UART_SEND_TIME] = 1;
1086   4                     }
1087   3                   else
1088   3                    { 
1089   4                      SBUF = mA_Value >> 8 ;
1090   4                      tran = 0;
1091   4                              Soft_Timer[UART_SEND_TIME] = 59 ;
1092   4                        }
1093   3                      TI = 1;
1094   3                       }
1095   2               }
1096   1        return mA_Value;
1097   1      }
1098          /*************************************************/
1099          unsigned int Read_AD3421_Value(void)
1100          {
1101   1         unsigned int  AD3421_Value;
1102   1         unsigned char ssta;
1103   1      
1104   1                       ssta = Get_AD3421_Value();
1105   1                if (ssta == 0)
1106   1                  {
1107   2                               AD_Hi =  AD_Hi & 0x03;
1108   2                    if(AD_Hi >= 2)
1109   2                         {
1110   3                            AV_COD = 1;
1111   3                                AD3421_Value = AD_Hi & 0x03;    
1112   3                                AD3421_Value = AD3421_Value << 8 ;
1113   3                                AD3421_Value = AD3421_Value + AD_Mid ;
1114   3                                AD3421_Value = AD3421_Value << 7 ;
1115   3                                AD_Lo = AD_Lo >> 1;
1116   3                                AD3421_Value = AD3421_Value + AD_Lo ;  
1117   3                                AD3421_Value = ~ AD3421_Value; 
1118   3                                if( AD3421_Value >= 0xf000){OVER_COD = 1;} else{OVER_COD = 0;}
1119   3                         }
1120   2                        else
1121   2                         {
1122   3                                AV_COD = 0;
1123   3                                AD3421_Value = AD_Hi & 0x03;    
1124   3                                AD3421_Value = AD3421_Value << 8 ;
1125   3                                AD3421_Value = AD3421_Value + AD_Mid ;
1126   3                                AD3421_Value = AD3421_Value << 7 ;
1127   3                                AD_Lo = AD_Lo >> 1;
1128   3                                AD3421_Value = AD3421_Value + AD_Lo;
1129   3                                if( AD3421_Value >= 0xf000){OVER_COD = 1;} else{OVER_COD = 0;}
1130   3                         }
1131   2                 }
1132   1         return AD3421_Value;
1133   1      }
1134          /*************************************************/     
1135          void DO_SETUP_TYPE(void)
1136          {
C51 COMPILER V9.02   MAIN                                                                  05/22/2015 15:09:11 PAGE 30  

1137   1              unsigned char set_key = 0, times = 0, Itemm = 0; 
1138   1              unsigned char item_key,confrom_key, up_key,don_key;
1139   1              unsigned int  value_cal = 0;
1140   1              
1141   1      
1142   1                    SETUP_LED_Disp(Itemm,value_cal);
1143   1      
1144   1                         while (CAIT)
1145   1                                  {
1146   2                                     set_key = Get_Key();
1147   2      
1148   2                                                            if((set_key & 0x01) == 1)
1149   2                                                              { item_key = 1 ;}
1150   2                                                             else
1151   2                                                              { item_key = 0 ;}
1152   2      
1153   2                                                            if((set_key & 0x02) == 2)
1154   2                                                              {confrom_key = 1 ;}
1155   2                                                             else
1156   2                                                              { confrom_key = 0 ;}
1157   2      
1158   2                                                            if((set_key & 0x04) == 4)
1159   2                                                              { up_key = 1 ;}
1160   2                                                             else
1161   2                                                              { up_key = 0 ;}
1162   2      
1163   2                                                if((set_key & 0x08) == 8)
1164   2                                                              { don_key = 1 ;}
1165   2                                                              else
1166   2                                                              { don_key = 0 ;}
1167   2      
1168   2                                                         if (item_key == 1) 
1169   2                                                           {
1170   3                                                                Itemm ++;
1171   3                                                                times=0;
1172   3                                                               }
1173   2                                                         if (Itemm > 0x13)
1174   2                                                               {
1175   3                                                                   Itemm = 0; 
1176   3                                                                       CAIT = 0;
1177   3                                                               } 
1178   2                                                        if(up_key == 1)   value_cal++;
1179   2                                                        if(don_key == 1)  value_cal--;
1180   2      
1181   2      
1182   2                                                 if (Soft_Timer[ADC_READ_TIME] == 0) 
1183   2                                                   {
1184   3                                                        Soft_Timer[ADC_READ_TIME] = 4 ;
1185   3                                                     Data_Value[t_code] = Read_AD3421_Value();
1186   3                                                                  if(t_code < 12)
1187   3                                                                        {t_code++;}
1188   3                                                                        else
1189   3                                                                         {
1190   4                                                                          Data_Value[14] = (Data_Value[12]/5+Data_Value[11]/5+Data_Value[10]/5+Data_Value[9]/5+Data_Valu
             -e[8]/5);
1191   4                                                                              t_code = 8 ;
1192   4                                                                         }
1193   3                                                        }
1194   2                                                  else
1195   2                                                    {
1196   3                                                            Data_Value[14] = Data_Value[t_code] ;
1197   3                                                        }
C51 COMPILER V9.02   MAIN                                                                  05/22/2015 15:09:11 PAGE 31  

1198   2                              if (Itemm == MODE_CAL)                  //tc,rtd,mV,mA
1199   2                                {
1200   3                                                          SETUP_LED_Disp(Itemm,Work_Type);
1201   3                                                                 Work_Type = Work_Type + value_cal;
1202   3                                                                   value_cal = 0;
1203   3                                                                if(Work_Type >= 4)
1204   3                                                                  {
1205   4                                                                       Work_Type = 0;
1206   4                                                                       value_cal = 0;
1207   4                                                                      }        
1208   3                                                                if(confrom_key == 1)
1209   3                                                                  { 
1210   4                                                                        EEPROM_write_byte(Mode_Select,Work_Type);
1211   4                                                                        SETUP_LED_Disp(22,0);
1212   4                                                                        delay(2500);
1213   4                                                                        times ++;
1214   4                                                                      }
1215   3                                              }
1216   2                                      else if (Itemm == C_F_CAL)
1217   2                                  {
1218   3                                               if (Work_Type >= 2) {Itemm = Itemm + 1;}
1219   3                                              else{   SETUP_LED_Disp(Itemm,C_F_Type);
1220   4                                                                C_F_Type = C_F_Type + value_cal;
1221   4                                                                  value_cal = 0;
1222   4                                                             
1223   4                                                                 if(C_F_Type >= 2 )
1224   4                                                                         {
1225   5                                                                          C_F_Type = 0 ;
1226   5                                                                          value_cal = 0;
1227   5                                                                         }
1228   4                                                                 if(confrom_key == 1)
1229   4                                                                  { 
1230   5                                                                         EEPROM_write_byte(C_F_Select,C_F_Type);  //C,F
1231   5                                                                         times ++; SETUP_LED_Disp(22,0);delay(2500);
1232   5                                                                      }
1233   4                                                         }
1234   3                                              }
1235   2                               else if (Itemm == TYPE_CAL)
1236   2                                  {
1237   3                                                  if (Work_Type != 0)
1238   3                                                        {     Itemm = Itemm + 1;}
1239   3                                                      else{   TC_Type = TC_Type + value_cal; 
1240   4                                                                        value_cal = 0;
1241   4                                                                if (TC_Type >= 6)
1242   4                                                                  {
1243   5                                                                    TC_Type = 0 ;
1244   5                                                                        value_cal = 0;
1245   5                                                                  }              
1246   4                                                                   SETUP_LED_Disp(Itemm,TC_Type);
1247   4      
1248   4                                                                      if(confrom_key == 1)
1249   4                                                                   {
1250   5                                                                         EEPROM_write_byte(Type_Select,TC_Type);  //K,J,T,E,R,B,S
1251   5                                                                         times ++; SETUP_LED_Disp(22,0);delay(2500);
1252   5                                                                       }
1253   4                                                           }
1254   3                                               }              
1255   2                                      else if (Itemm == TC_ZERO_CAL)
1256   2                                                {
1257   3                                                 if (Work_Type != 0){ Itemm = Itemm + 1;}
1258   3                                               else{
1259   4                                                                 SETUP_LED_Disp(Itemm, Data_Value[14]);
C51 COMPILER V9.02   MAIN                                                                  05/22/2015 15:09:11 PAGE 32  

1260   4                                                                 if(confrom_key == 1)
1261   4                                                                  {
1262   5                                                                        Temp_Flag = 3 ;
1263   5                                                                        Temp_offset = Temp_m;
1264   5                                                                       if ((Temp_m*24)/10 >= Data_Value[14])
1265   5                                                                         {
1266   6                                                                           if( AV_COD == 1)
1267   6                                                                             { TC_Zero_offset = (Temp_m*24)/10 + Data_Value[14]; NG_COD = 1;use_flag = use_flag|0x01;}
1268   6                                                                           else{ TC_Zero_offset = (Temp_m*24)/10 - Data_Value[14]; NG_COD = 1;use_flag = use_flag|0x01;}
1269   6                                                                         }
1270   5                                                                       else
1271   5                                                                         {  
1272   6                                                                               if( AV_COD == 1)
1273   6                                                                             { TC_Zero_offset = Data_Value[14] + (Temp_m*24)/10 ;  NG_COD = 1;use_flag = use_flag|0x01;}
1274   6                                                                           else {TC_Zero_offset = Data_Value[14] - (Temp_m*24)/10;  NG_COD = 0;use_flag = use_flag&0xfe;
             -}
1275   6                                                                         }
1276   5                                                                        EEPROM_write_byte(Status_flag,(use_flag));
1277   5                                                                        EEPROM_write_word(TC_Zero,TC_Zero_offset); 
1278   5                                                                        EEPROM_write_word(60,Temp_offset);                                                                              
1279   5                                                                  delay(50);
1280   5                                                                      times ++; SETUP_LED_Disp(22,0);delay(2500);
1281   5                                                                }
1282   4                                                       }
1283   3                                               }
1284   2                            else if (Itemm == TC_SPAN_CAL)
1285   2                                  {
1286   3                                                if (Work_Type != 0) { Itemm = Itemm + 1; }
1287   3                                               else
1288   3                                                {
1289   4                                                 SETUP_LED_Disp(Itemm,Data_Value[14]);
1290   4                                                if(confrom_key == 1)
1291   4                                                  { 
1292   5                                                       if( NG_COD == 1)
1293   5                                                          {TC_Span_offset = Data_Value[14] + TC_Zero_offset;}
1294   5                                                  else {TC_Span_offset = Data_Value[14] - TC_Zero_offset;}
1295   5                                                              EEPROM_write_word(TC_Span,TC_Span_offset);  
1296   5      
1297   5                                                   if(TC_Span_offset >= 0xc8ca )
1298   5                                                         { TC_Span_Value = TC_Span_offset /(TC_Span_offset - 0xc8ca);use_flag = use_flag|0x10;}
1299   5                                                       else
1300   5                                                         { TC_Span_Value = TC_Span_offset /(0xc8ca - TC_Span_offset);use_flag = use_flag&0xef;}
1301   5      
1302   5                                                                          EEPROM_write_word(TC_Span_Per,TC_Span_Value);
1303   5                                                                              delay(50);
1304   5                                                                              EEPROM_write_byte(Status_flag,use_flag);
1305   5                                                                        times ++; SETUP_LED_Disp(22,0);delay(2500);
1306   5                                                        }
1307   4                                                        }
1308   3                                                 }
1309   2                            else if (Itemm == RTD_ZERO_CAL)
1310   2                                    {
1311   3                                                  if (Work_Type != 1) {       Itemm = Itemm + 1;}
1312   3                                                      else{
1313   4                                                               if( AV_COD == 1){ NG_COD = 1;}else{ NG_COD = 0;}
1314   4                                                                SETUP_LED_Disp(Itemm,Data_Value[14]);
1315   4                                                                if(confrom_key == 1)
1316   4                                                                  {
1317   5                                                                        RTD_Zero_offset = Data_Value[14] ;
1318   5                                                                       EEPROM_write_word(RTD_Zero,RTD_Zero_offset);  //rtd
1319   5                                                                        delay(50);
1320   5                                                                       if( NG_COD == 1){ EEPROM_write_byte(Status_flag,(use_flag|0x02));}
C51 COMPILER V9.02   MAIN                                                                  05/22/2015 15:09:11 PAGE 33  

1321   5                                                                       else { EEPROM_write_byte(Status_flag,(use_flag&0xfd));}
1322   5                                                                        times ++; SETUP_LED_Disp(22,0);delay(2500);
1323   5                                                                      }
1324   4                                                          }
1325   3                                                }
1326   2                                 else if (Itemm == RTD_SPAN_CAL)
1327   2                                    {
1328   3                                                  if (Work_Type != 1) {Itemm = Itemm + 1;}
1329   3                                                      else{    
1330   4                                                                SETUP_LED_Disp(Itemm,Data_Value[14]);
1331   4                                                                if(confrom_key == 1)
1332   4                                                                  {
1333   5                                                                       RTD_Span_offset = Data_Value[14] ;
1334   5                                                                       EEPROM_write_word(RTD_Span,RTD_Span_offset);  //rtd
1335   5      
1336   5                                                                       if( NG_COD == 1)
1337   5                                                                         { if ((RTD_Span_offset + RTD_Zero_offset) > 0x44e4 )
1338   6                                                                              { RTD_Span_Value = ((RTD_Span_offset + RTD_Zero_offset)/((RTD_Span_offset + RTD_Zero_offse
             -t)-0x44e4));}
1339   6                                                                               else
1340   6                                                                                 { RTD_Span_Value = ((RTD_Span_offset + RTD_Zero_offset)/(0x44e4 - (RTD_Span_offset + RTD_Zero_
             -offset)));}
1341   6                                                                         }
1342   5                                                                       else
1343   5                                                                         { if ((RTD_Span_offset - RTD_Zero_offset) > 0x44e4 )
1344   6                                                                              { RTD_Span_Value = ((RTD_Span_offset - RTD_Zero_offset)/((RTD_Span_offset - RTD_Zero_offse
             -t)-0x44e4));}
1345   6                                                                               else
1346   6                                                                                  { RTD_Span_Value = ((RTD_Span_offset - RTD_Zero_offset)/(0x44e4 - (RTD_Span_offset - RTD_Zero
             -_offset)));}
1347   6                                                                         }
1348   5                                                                          EEPROM_write_word(RTD_Span_Per,RTD_Span_Value);
1349   5                                                                       times ++;      SETUP_LED_Disp(22,0);delay(2500);
1350   5                                                                      }
1351   4                                                         }
1352   3                                               }
1353   2                                  else if (Itemm == mV_ZERO_CAL)
1354   2                                     {
1355   3                                                  if (Work_Type != 2)   {     Itemm = Itemm + 1;}
1356   3                                                      else{
1357   4                                                               if( AV_COD == 1){ NG_COD = 1;}else{ NG_COD = 0;}
1358   4                                                                SETUP_LED_Disp(Itemm,Data_Value[14]);
1359   4                                                                if(confrom_key == 1)
1360   4                                                                  {
1361   5                                                                       mV_Zero_offset = Data_Value[14] ;
1362   5                                                                       EEPROM_write_word(mV_Zero,mV_Zero_offset);  
1363   5                                                                        delay(50);
1364   5                                                                       if( NG_COD == 1){ EEPROM_write_byte(Status_flag,(use_flag|0x04));}
1365   5                                                                       else { EEPROM_write_byte(Status_flag,(use_flag&0xfb));}
1366   5                                                                       times ++; SETUP_LED_Disp(22,0);        delay(2500);
1367   5                                                                      }
1368   4                                                         }
1369   3                                                }
1370   2                                  else if (Itemm == mV_SPAN_CAL)
1371   2                                       {
1372   3                                                         if (Work_Type != 2) {        Itemm = Itemm + 1;}
1373   3                                                        else{ 
1374   4                                                                SETUP_LED_Disp(Itemm,Data_Value[14]);
1375   4                                                                if(confrom_key == 1)
1376   4                                                                  {
1377   5                                                                        mV_Span_offset = Data_Value[14] ;
1378   5      
C51 COMPILER V9.02   MAIN                                                                  05/22/2015 15:09:11 PAGE 34  

1379   5                                                                       EEPROM_write_word(mV_Span,mV_Span_offset);  
1380   5      
1381   5                                                                       if( NG_COD == 1)
1382   5                                                                         { if ((mV_Span_offset + mV_Zero_offset) > 0x7d00 )            
1383   6                                                                              { mV_Span_Value = ((mV_Span_offset + mV_Zero_offset)/((mV_Span_offset + mV_Zero_offset)-0x
             -7d00));}
1384   6                                                                               else
1385   6                                                                                  { mV_Span_Value = ((mV_Span_offset + mV_Zero_offset)/(0x7d00 - (mV_Span_offset + mV_Zero_offs
             -et)));}
1386   6                                                                         }
1387   5                                                                       else
1388   5                                                                         { if ((mV_Span_offset - mV_Zero_offset) > 0x7d00)
1389   6                                                                              { mV_Span_Value = ((mV_Span_offset - mV_Zero_offset)/((mV_Span_offset - mV_Zero_offset)-0x
             -7d00));}
1390   6                                                                               else
1391   6                                                                                  { mV_Span_Value = ((mV_Span_offset - mV_Zero_offset)/(0x7d00 - (mV_Span_offset - mV_Zero_offs
             -et)));}
1392   6                                                                         }
1393   5                                                                          EEPROM_write_word(mV_Span_Per,mV_Span_Value);
1394   5                                                                       times ++;      SETUP_LED_Disp(22,0);delay(2500);
1395   5                                                                      }
1396   4                                                         }
1397   3                                               }
1398   2                                 else if (Itemm == mA_ZERO_CAL)
1399   2                                     {
1400   3                                                   if (Work_Type != 3)  {     Itemm = Itemm + 1;}
1401   3                                                      else{
1402   4                                                                if( AV_COD == 1){ NG_COD = 1;}else{ NG_COD = 0;}
1403   4                                                                SETUP_LED_Disp(Itemm,Data_Value[14]);
1404   4                                                                if(confrom_key == 1)
1405   4                                                                  {
1406   5                                         delay(50);
1407   5                                                                       mA_Zero_offset = Data_Value[14];
1408   5                                                                       EEPROM_write_word(mA_Zero,mA_Zero_offset);  
1409   5                                                                         delay(50);
1410   5                                                                      if( NG_COD == 1){ EEPROM_write_byte(Status_flag,(use_flag|0x08));}
1411   5                                                                       else { EEPROM_write_byte(Status_flag,(use_flag&0xf7));}
1412   5                                                                       times ++; SETUP_LED_Disp(22,0);delay(25000);
1413   5                                                                      }
1414   4                                                         }
1415   3                                               }
1416   2                                  else if (Itemm == mA_SPAN_CAL)
1417   2                                      {
1418   3                                                        if (Work_Type != 3)  {Itemm = Itemm + 1;}
1419   3                                                      else{
1420   4                                                               SETUP_LED_Disp(Itemm,Data_Value[14]);
1421   4                                                                if(confrom_key == 1)
1422   4                                                                  {
1423   5                                                                       mA_Span_offset = Data_Value[14]; 
1424   5                                                                       EEPROM_write_word(mA_Span,mA_Span_offset);  
1425   5                                                                       delay(50);
1426   5                                                                       if( NG_COD == 1)
1427   5                                                                         { if ((mA_Span_offset + mA_Zero_offset) > 0x1900 )   
1428   6                                                                              { mA_Span_Value = ((mA_Span_offset + mA_Zero_offset)/((mA_Span_offset + mA_Zero_offset)- 0
             -x1900));}
1429   6                                                                               else
1430   6                                                                                  { mA_Span_Value = ((mA_Span_offset + mA_Zero_offset)/( 0x1900 - (mA_Span_offset + mA_Zero_off
             -set)));}
1431   6                                                                         }
1432   5                                                                       else
1433   5                                                                         { if ((mA_Span_offset - mA_Zero_offset) > 0x1900 )
1434   6                                                                              { mA_Span_Value = ((mA_Span_offset - mA_Zero_offset)/((mA_Span_offset - mA_Zero_offset)- 0
C51 COMPILER V9.02   MAIN                                                                  05/22/2015 15:09:11 PAGE 35  

             -x1900));}
1435   6                                                                               else
1436   6                                                                                  { mA_Span_Value = ((mA_Span_offset - mA_Zero_offset)/( 0x1900 - (mA_Span_offset - mA_Zero_off
             -set)));}
1437   6                                                                         }
1438   5                                                                               EEPROM_write_word(mA_Span_Per,mA_Span_Value);
1439   5                                                                           times ++; SETUP_LED_Disp(22,0);    delay(2500);
1440   5                                                                      }
1441   4                                                         }
1442   3                                                 }
1443   2                                               
1444   2                                 else if (Itemm == ALARM_LO_CAL)
1445   2                                       {
1446   3                                     alarm_Low_set = alarm_Low_set + value_cal*10 ;
1447   3                                                                                value_cal = 0;
1448   3                                                                SETUP_LED_Disp(Itemm,alarm_Low_set);
1449   3                                                                if((up_key == 1)||(don_key == 1))
1450   3                                                                  {
1451   4                                                                   if(alarm_Low_set > 9999){value_cal = 0;alarm_Low_set = 0;}
1452   4                                                                       if(confrom_key == 1)
1453   4                                                                    {
1454   5                                                              EEPROM_write_word(Alarm_Low,alarm_Low_set);  //alarm
1455   5                                                                              times ++; SETUP_LED_Disp(22,0);delay(2500);
1456   5                                                                        } 
1457   4                                                                  }
1458   3                                                      }
1459   2                                   else if (Itemm == ALARM_HI_CAL)
1460   2                                      { 
1461   3                                                                 alarm_Hi_set = alarm_Hi_set + value_cal*10 ;
1462   3                                                                  value_cal = 0;
1463   3                                                                 SETUP_LED_Disp(Itemm,alarm_Hi_set);
1464   3                                                                if((up_key == 1)||(don_key == 1))
1465   3                                                                  {
1466   4                                                                        if(alarm_Hi_set > 9999){value_cal = 0;alarm_Hi_set = 0;}
1467   4      
1468   4                                                                        if(confrom_key == 1)
1469   4                                                                    {
1470   5                                                              EEPROM_write_word(Alarm_Hi,alarm_Hi_set);  //alarm
1471   5                                                                              times ++; SETUP_LED_Disp(22,0);delay(2500);
1472   5                                                                        }
1473   4                                                                  }
1474   3                                                      }
1475   2                                   else if (Itemm == YEAR_DATE_CAL)
1476   2                                      {   
1477   3                                                         if(value_cal >= 200)
1478   3                                                           {
1479   4                                                                 if(use_year == 0) {use_year = 0x99; value_cal = 0 ;}
1480   4                                                                 else
1481   4                                                                  { if((use_year&0x0f) == 0){use_year = (((use_year-0x10)&0xf0)|0x09); value_cal = 0 ; }
1482   5                                                                        else { use_year = use_year -0x01; value_cal = 0 ;}
1483   5                                                                  }
1484   4                                                               }
1485   3                                                              else
1486   3                                                               {
1487   4                                                                if(value_cal == 1) 
1488   4                                                                 {
1489   5                                                                    if(use_year >= 0x9a) { use_year = 0; value_cal = 0;}
1490   5                                                                       else{if((use_year&0x0f) == 0x09) {use_year = ((use_year+0x10)&0xf0);value_cal = 0; } 
1491   6                                                                            else { use_year = use_year + 0x01; value_cal = 0;} } 
1492   5                                                             } 
1493   4                                                                }     
1494   3                                                        SETUP_LED_Disp(Itemm,use_year + 0x2000);
C51 COMPILER V9.02   MAIN                                                                  05/22/2015 15:09:11 PAGE 36  

1495   3                                                                                                                                               
1496   3                                                               if(confrom_key == 1)
1497   3                                                                 {
1498   4                                                                    RTC_write_byte(6,use_year);
1499   4                                                                      EEPROM_write_byte(Year_Date,use_year); 
1500   4                                                                              times ++;SETUP_LED_Disp(22,0);delay(2500);
1501   4                                                                 }
1502   3                                                           
1503   3                                                 }
1504   2                                 else if (Itemm == MON_DATE_CAL)
1505   2                                     {
1506   3                                                     if(value_cal >= 200)
1507   3                                                           {
1508   4                                                                 if(use_mon <= 0x01){use_mon = 0x12; value_cal = 0 ;}
1509   4                                                            else
1510   4                                                                 { if((use_mon&0x0f) == 0) {use_mon = (((use_mon-0x10)&0xf0)|0x09); value_cal = 0 ; }
1511   5                                                                           else{use_mon = use_mon - 0x01; value_cal = 0 ;}
1512   5                                                                 }
1513   4                                                               }
1514   3                                                        else
1515   3                                                               {
1516   4                                                                if(value_cal == 1) 
1517   4                                                                  {
1518   5                                                                        if(use_mon == 0x12){use_mon = 0x01; value_cal = 0 ;}
1519   5                                                                       else {if((use_mon&0x0f) == 0x09) {use_mon = ((use_mon+0x10)&0xf0); value_cal = 0;}
1520   6                                                                          else { use_mon = use_mon + 0x01; value_cal = 0 ;}}
1521   5                                                                      }
1522   4                                                               }
1523   3                                                                SETUP_LED_Disp(Itemm,use_mon);
1524   3      
1525   3                                                               if(confrom_key == 1)
1526   3                                                                 {
1527   4                                                                   RTC_write_byte(5,use_mon);
1528   4                                                                       EEPROM_write_byte(Mon_Date,use_mon);
1529   4                                                                       times ++;  SETUP_LED_Disp(22,0);delay(2500);
1530   4                                                                 }
1531   3                                                      }
1532   2                                 else if (Itemm == DAY_DATE_CAL)                      //add week setup
1533   2                                    {
1534   3                                                       if(value_cal >= 200)
1535   3                                                         {
1536   4                                                           if((use_day == 1)&&(use_mon == 0x02)&&(use_year%4 == 0)) { use_day = 0x29 ;  value_cal = 0 ; }
1537   4                                                          else if((use_day == 1)&&(use_mon == 0x02)&&(use_year%4 != 0)) { use_day = 0x28 ; value_cal = 0 ;
             - }
1538   4                                                          else if((use_day == 1)&&((use_mon == 1)||(use_mon == 3)||(use_mon == 5)||(use_mon == 7)||(use_mo
             -n == 0x08)||(use_mon ==0x10)||(use_mon == 0x12))) { use_day =0x31;value_cal = 0;}
1539   4                                                          else if((use_day == 1)&&((use_mon == 4)||(use_mon == 6)||(use_mon == 0x09)||(use_mon == 0x11))) 
             -{ use_day = 0x30 ;  value_cal = 0 ; }
1540   4                                                              else if((use_day&0x0f) == 0) {use_day = (((use_day-0x10)&0xf0)|0x09);value_cal = 0;}
1541   4                                                               else {use_day = use_day -1; value_cal = 0;}
1542   4                                                        }
1543   3                                                 else
1544   3                                                       {
1545   4                                                       if(value_cal == 1)
1546   4                                                         {
1547   5                                                               if((use_mon == 2)&&(use_year%4 == 0)&&(use_day == 0x29)) { use_day = 1; value_cal = 0;}
1548   5                                                              else if((use_mon == 2)&&(use_year%4 != 0)&&(use_day == 0x28)) { use_day = 1; value_cal = 0;}
1549   5                                                              else if(((use_mon == 1)||(use_mon == 3)||(use_mon == 5)||(use_mon == 7)||(use_mon == 8)||(use_mon =
             -= 0x10)||(use_mon == 0x12))&&(use_day == 0x31)) { use_day = 1;value_cal = 0;}
1550   5                                                              else if(((use_mon == 4)||(use_mon == 6)||(use_mon == 9)||(use_mon == 0x11))&&(use_day == 0x30)) { u
             -se_day = 1; value_cal = 0;}
1551   5                                                              else if((use_day&0x0f) == 0x09) {use_day = ((use_day + 0x10)&0xf0); value_cal = 0;}
C51 COMPILER V9.02   MAIN                                                                  05/22/2015 15:09:11 PAGE 37  

1552   5                                                                 else{use_day = use_day + 1; value_cal = 0;}                 
1553   5                                                         }
1554   4                                                       }
1555   3                                               SETUP_LED_Disp(Itemm,use_day);
1556   3      
1557   3                                                       if(confrom_key == 1)
1558   3                                                         {
1559   4                                                           RTC_write_byte(4,use_day);
1560   4                                                               EEPROM_write_byte(Day_Date,use_day);
1561   4                                                                       times ++;      SETUP_LED_Disp(22,0);delay(250);
1562   4                                                         }
1563   3                                              }
1564   2                                else if (Itemm == HOUR_DATE_CAL)
1565   2                                   {
1566   3                                                        if(value_cal >= 200)
1567   3                                                         {
1568   4                                                          if (use_hour == 0){use_hour = 0x23; value_cal = 0;}
1569   4                                                          else 
1570   4                                                               { if((use_hour&0x0f) == 0x00) {use_hour = ((use_hour-0x10)&0xf0)|0x09; value_cal = 0;}  
1571   5                                                                 else {use_hour = use_hour - 0x01; value_cal = 0;}
1572   5                                                               }
1573   4                                                         }
1574   3                                                       else
1575   3                                                         {
1576   4                                                          if(value_cal == 1)
1577   4                                                           {
1578   5                                                                 if(use_hour == 0x23) {use_hour = 0; value_cal = 0;}
1579   5                                                                 else
1580   5                                                                  { if((use_hour&0x0f) == 0x09) {use_hour = (use_hour+0x10)&0xf0; value_cal = 0;}
1581   6                                                                        else {use_hour = use_hour + 0x01; value_cal = 0;}
1582   6                                                                      }    
1583   5                                                               }
1584   4                                                          }
1585   3                                                         SETUP_LED_Disp(Itemm,use_hour);
1586   3                                                         if(confrom_key == 1)
1587   3                                                               {
1588   4                                                                   RTC_write_byte(2,use_hour);
1589   4                                                                      EEPROM_write_byte(Hour_Date,use_hour);
1590   4                                                                       times ++;      SETUP_LED_Disp(22,0);delay(250);
1591   4                                                               }
1592   3                                               }
1593   2                             else if (Itemm == MIN_DATE_CAL)
1594   2                                   {
1595   3                                                   if(value_cal >= 200)
1596   3                                                         {
1597   4                                                           if(use_min == 0) { use_min = 0x59; value_cal = 0;}
1598   4                                                              else 
1599   4                                                               {
1600   5                                                                  if((use_min&0x0f) == 0) {use_min = ((use_min - 0x10)&0xf0)|0x09; value_cal = 0;} 
1601   5                                                                 else { use_min = use_min - 0x01; value_cal = 0;}
1602   5                                                               }
1603   4                                                        }
1604   3                                                      else
1605   3                                                        {     
1606   4                                                           if (value_cal == 1) 
1607   4                                                                 {
1608   5                                                                    if(use_min == 0x59) {use_min = 0; value_cal = 0;}
1609   5                                                                        else
1610   5                                                                         {  if((use_min&0x0f) == 0x09) {use_min = (use_min+0x10)&0xf0; value_cal = 0;}
1611   6                                                                            else { use_min = use_min + 0x01; value_cal = 0;}
1612   6                                                                         }
1613   5                                                                 }
C51 COMPILER V9.02   MAIN                                                                  05/22/2015 15:09:11 PAGE 38  

1614   4                                                        }
1615   3                                          SETUP_LED_Disp(Itemm,use_min );
1616   3                                                        if(confrom_key == 1)
1617   3                                                          {
1618   4                                                                   RTC_write_byte(1,use_min );
1619   4                                                                       EEPROM_write_byte(Min_Date,use_min);
1620   4                                                                       times ++;SETUP_LED_Disp(22,0); delay(250);
1621   4                                                              }
1622   3                                            }
1623   2                                          else if (Itemm >= PRODUCT_RESET)
1624   2                                                 { 
1625   3                                                                Itemm = 0 ;
1626   3                                                                CAIT  = 0 ;
1627   3                                                 }
1628   2                                       }
1629   1                      Check_PCB();                    
1630   1      }
1631          //*******************************
1632          void RTC_ON(void)
1633          { 
1634   1         use_week = RTC_read_byte(0x03);
1635   1         RTC_write_byte(0x07,SQWE);
1636   1         RTC_write_byte(0x03,use_week|0x08);    
1637   1                                   
1638   1          if((use_week&OSC_EN) == OSC_EN) {;}       // if oscillator = already running, do nothing. 
1639   1          else
1640   1               { 
1641   2             RTC_write_byte(0x06,use_year)   ;     // initialize YEAR  register           
1642   2             RTC_write_byte(0x05,use_mon)    ;     // initialize MONTH register  
1643   2             RTC_write_byte(0x04,use_day)    ;     // initialize DATE  register  
1644   2             RTC_write_byte(0x03,use_week|0x08);
1645   2             RTC_write_byte(0x02,use_hour)   ;     // initialize HOUR  register  
1646   2             RTC_write_byte(0x01,use_min)    ;     // initialize MIN   register  
1647   2             RTC_write_byte(0x00,use_sec|0x80) ;
1648   2               } 
1649   1       
1650   1      }
1651          /************************************************/
1652          void RTC_WRITE_SET(void)
1653          {
1654   1      
1655   1         RTC_write_byte(0x00,(use_sec|0x80));
1656   1      
1657   1         RTC_write_byte(0x01,use_min);
1658   1      
1659   1         RTC_write_byte(0x02,use_hour);
1660   1      
1661   1         RTC_write_byte(0x03,use_week|0x08);
1662   1      
1663   1         RTC_write_byte(0x04,use_day);
1664   1      
1665   1         RTC_write_byte(0x05,use_mon);
1666   1      
1667   1         RTC_write_byte(0x06,use_year);
1668   1      
1669   1         RTC_write_byte(0x07,0x40);
1670   1      }
1671          /*****************************************/
1672          void RTC_READ_SET(void)
1673          { 
1674   1       use_sec  = RTC_read_byte(0x00)&0x7f ;
1675   1       use_min  = RTC_read_byte(0x01) ;
C51 COMPILER V9.02   MAIN                                                                  05/22/2015 15:09:11 PAGE 39  

1676   1       use_hour = RTC_read_byte(0x02) ;
1677   1       use_week = RTC_read_byte(0x03)&0x07 ;
1678   1       use_day  = RTC_read_byte(0x04);
1679   1       use_mon  = RTC_read_byte(0x05);
1680   1       use_year = RTC_read_byte(0x06);
1681   1      
1682   1       if((use_mon&0x03) == 0x01)
1683   1       { 
1684   2         EEPROM_write_byte(Year_Date,use_year);
1685   2         EEPROM_write_byte(Mon_Date, use_mon);
1686   2         EEPROM_write_byte(Day_Date, use_day);
1687   2         EEPROM_write_byte(Week_Date, use_week);
1688   2         EEPROM_write_byte(Hour_Date,use_hour);
1689   2         EEPROM_write_byte(Min_Date, use_min);
1690   2         EEPROM_write_byte(sec_Date, use_sec);
1691   2       }
1692   1      }
1693          //*******************************
1694          void EEPROM_WriteDefault(void)
1695          {
1696   1          Check_PCB();
1697   1          EEPROM_write_byte(Mode_Select,Work_Type); //setup mode
1698   1          EEPROM_write_byte(C_F_Select, 0);  //c
1699   1              EEPROM_write_byte(Type_Select,0);  //Type define k=0.j=1,t=2
1700   1      
1701   1              EEPROM_write_word(TC_Zero, 0);  
1702   1              EEPROM_write_word(TC_Span, 1400);
1703   1              EEPROM_write_word(RTD_Zero, 0);
1704   1              EEPROM_write_word(RTD_Span, 850);
1705   1              EEPROM_write_word(mV_Zero, 0);
1706   1              EEPROM_write_word(mV_Span, 5000);
1707   1              EEPROM_write_word(mA_Zero, 40); 
1708   1          EEPROM_write_word(mA_Span, 200);
1709   1              EEPROM_write_word(Alarm_Low, 0);
1710   1              EEPROM_write_word(Alarm_Hi, 5000);
1711   1      
1712   1          EEPROM_write_byte(Year_Date,0x15);
1713   1          EEPROM_write_byte(Mon_Date, 0x01);
1714   1          EEPROM_write_byte(Day_Date, 0x01);
1715   1              EEPROM_write_byte(Week_Date,0x04);
1716   1          EEPROM_write_byte(Hour_Date,0x12);
1717   1          EEPROM_write_byte(Min_Date, 0x01);
1718   1              EEPROM_write_byte(sec_Date, 0x01);
1719   1              EEPROM_write_byte(Status_flag, 0);
1720   1              EEPROM_write_word(TC_Span_Per, 1);
1721   1              EEPROM_write_word(RTD_Span_Per, 1);
1722   1              EEPROM_write_word(mV_Span_Per, 1);
1723   1              EEPROM_write_word(mA_Span_Per, 1);
1724   1              EEPROM_write_word(60,0);
1725   1              EEPROM_write_word(EEP_ADR, 64);         //eep start code
1726   1          RTC_ON();
1727   1      }
1728          /*****************************************************/
1729          void DO_RESET_TYPE(void)
1730          {
1731   1           EEPROM_WriteDefault();
1732   1           LED_Fill();                                     //  LED all light
1733   1               Work_Type = EEPROM_read_byte(Mode_Select);
1734   1               C_F_Type = EEPROM_read_byte(C_F_Select);
1735   1               TC_Type = EEPROM_read_byte(Type_Select);       //Type define k=0.j=1,t=2
1736   1               TC_Zero_offset = EEPROM_read_word(TC_Zero);    
1737   1               TC_Span_offset = EEPROM_read_word(TC_Span);
C51 COMPILER V9.02   MAIN                                                                  05/22/2015 15:09:11 PAGE 40  

1738   1               RTD_Zero_offset = EEPROM_read_word(RTD_Zero);
1739   1               RTD_Span_offset = EEPROM_read_word(RTD_Span);
1740   1               mA_Zero_offset = EEPROM_read_word(mA_Zero);
1741   1               mA_Span_offset = EEPROM_read_word(mA_Span);
1742   1      
1743   1               mV_Zero_offset = EEPROM_read_word(mV_Zero);    
1744   1           mV_Span_offset = EEPROM_read_word(mV_Span);
1745   1               alarm_Low_set = EEPROM_read_word(Alarm_Low);
1746   1               alarm_Hi_set = EEPROM_read_word(Alarm_Hi);
1747   1           use_year = EEPROM_read_word(Year_Date);
1748   1      
1749   1           use_mon =  EEPROM_read_byte(Mon_Date);
1750   1           use_day =  EEPROM_read_byte(Day_Date);
1751   1               use_week = EEPROM_read_byte(Week_Date);
1752   1           use_hour = EEPROM_read_byte(Hour_Date);
1753   1           use_min =  EEPROM_read_byte(Min_Date);
1754   1               use_sec =  EEPROM_read_byte(sec_Date);
1755   1               use_flag =     EEPROM_read_byte(Status_flag);
1756   1               TC_Span_Value = EEPROM_read_word(TC_Span_Per);
1757   1               RTD_Span_Value = EEPROM_read_word(RTD_Span_Per);
1758   1               mV_Span_Value = EEPROM_read_word(mV_Span_Per);
1759   1               mA_Span_Value = EEPROM_read_word(mA_Span_Per);
1760   1               Temp_offset  = EEPROM_read_word(60);
1761   1      //       eep_count = EEPROM_read_byte(EEP_ADR);
1762   1      }
1763          /***********************************
1764          ****      System_Start          ****
1765          ***********************************/ 
1766          main(void)
1767          {
1768   1         TR0 = 0;
1769   1         TMOD = TMOD |= 0x01;
1770   1         TH0  = 0xDC; //use timer0 to delay 5ms
1771   1         TL0  = 0;
1772   1         TF0  = 0; 
1773   1      
1774   1         IFMT = 0x07 ; //#AUXRA_Rd ;set read AUXRA command
1775   1         SCMD = 0x46; //h
1776   1         SCMD = 0xB9; //h
1777   1         IFD  = IFD |= 0x08; //;
1778   1         IFMT = 0x06;  // #AUXRA_Wr ;set write AUXRA command
1779   1         SCMD = 0x46; // #46h
1780   1         SCMD = 0xB9; //h
1781   1         TR0  = 1 ;  //;timer0 run
1782   1         while( ~TF0 ) 
1783   1            {   }
1784   1         TF0 = 0;  //
1785   1         TR0  = 0; //;timer0 stop
1786   1         IFMT = 0x07 ; //#AUXRA_Rd ;set read AUXRA command
1787   1         SCMD = 0x46 ; //h
1788   1         SCMD = 0xB9 ; //h
1789   1         IFD  = IFD |= 0x03 ;
1790   1         IFMT = 0x06; // #AUXRA_Wr ;set write AUXRA command
1791   1         SCMD = 0x46; // h
1792   1         SCMD = 0xB9; //h
1793   1         IFMT = 0x07; //#AUXRA_Rd ;set read AUXRA command
1794   1         SCMD = 0x46; //h
1795   1         SCMD = 0xB9; //h
1796   1         IFD = IFD &= 0xFB; //
1797   1         IFMT = 0x06; //, #AUXRA_Wr ;set write AUXRA command
1798   1         SCMD = 0x46; //h
1799   1         SCMD = 0x0B9; //h
C51 COMPILER V9.02   MAIN                                                                  05/22/2015 15:09:11 PAGE 41  

1800   1      
1801   1              PORT_Init();
1802   1              RTC_SCL = 1;
1803   1              RTC_SDA = 1;
1804   1              EEPROM_Init();
1805   1              LED_Init();
1806   1              T0_Init();
1807   1              T1_Init();
1808   1              AD3421_Init();
1809   1              InitUart();
1810   1          Set_mA(0);
1811   1          LED_Fill();
1812   1              Set_mV(0);
1813   1              Buzzer(OFF);
1814   1              Soft_Timer_Enable = 0;
1815   1      
1816   1              if((EEPROM_read_byte(0) != 'N')||(EEPROM_read_byte(1) != 'E')||(EEPROM_read_byte(2) != 'W')||(EEPROM_read
             -_byte(3) != JOHNSON)||(EEPROM_read_byte(4) != LIN))
1817   1           {
1818   2                      EEPROM_write_byte(0, 'N');      
1819   2                      EEPROM_write_byte(1, 'E');
1820   2                      EEPROM_write_byte(2, 'W');
1821   2                      EEPROM_write_byte(3, JOHNSON);  
1822   2                      EEPROM_write_byte(4, LIN);
1823   2                      RTC_ON();       
1824   2                      EEPROM_WriteDefault();
1825   2           }
1826   1             LED_Fill(); 
1827   1                 Work_Type = EEPROM_read_byte(Mode_Select);           
1828   1                 C_F_Type = EEPROM_read_byte(C_F_Select);
1829   1                 TC_Type  = EEPROM_read_byte(Type_Select);       //Type define k=0.j=1,t=2
1830   1                 TC_Zero_offset = EEPROM_read_word(TC_Zero);  
1831   1                 TC_Span_offset = EEPROM_read_word(TC_Span);
1832   1                 RTD_Zero_offset = EEPROM_read_word(RTD_Zero);
1833   1                 RTD_Span_offset = EEPROM_read_word(RTD_Span);
1834   1                 mV_Zero_offset = EEPROM_read_word(mV_Zero);
1835   1                 mV_Span_offset = EEPROM_read_word(mV_Span);
1836   1                 mA_Zero_offset = EEPROM_read_word(mA_Zero);  
1837   1             mA_Span_offset = EEPROM_read_word(mA_Span);
1838   1                 alarm_Low_set = EEPROM_read_word(Alarm_Low);
1839   1                 alarm_Hi_set = EEPROM_read_word(Alarm_Hi);
1840   1             use_year = EEPROM_read_byte(Year_Date);
1841   1             use_mon = EEPROM_read_byte(Mon_Date);
1842   1             use_day = EEPROM_read_byte(Day_Date);
1843   1             use_hour = EEPROM_read_byte(Hour_Date);
1844   1             use_min = EEPROM_read_byte(Min_Date);
1845   1                 use_sec = EEPROM_read_byte(sec_Date);
1846   1      
1847   1                 use_flag =   EEPROM_read_byte(Status_flag);
1848   1      
1849   1                 TC_Span_Value = EEPROM_read_word(TC_Span_Per);
1850   1                 RTD_Span_Value = EEPROM_read_word(RTD_Span_Per);
1851   1                 mV_Span_Value = EEPROM_read_word(mV_Span_Per);
1852   1                 mA_Span_Value = EEPROM_read_word(mA_Span_Per);
1853   1                 Temp_offset  = EEPROM_read_word(60);
1854   1      //         eep_count = EEPROM_read_byte(EEP_ADR);
1855   1                 Disp_year = use_year+0x2000;
1856   1                 RTC_ON();
1857   1        
1858   1      
1859   1               ET0 = 1;
1860   1               TR0 = 1;
C51 COMPILER V9.02   MAIN                                                                  05/22/2015 15:09:11 PAGE 42  

1861   1               ET1 = 1;
1862   1               TR1 = 1;
1863   1               EA  = 1;
1864   1               MAIN_SW = 1 ;
1865   1      
1866   1           Check_PCB();
1867   1      
1868   1              if(Work_Type == 0)
1869   1                { if(use_flag & 0x01) NG_COD = 1 ;}
1870   1              else if(Work_Type == 1)
1871   1                { if(use_flag & 0x02) NG_COD = 1 ;}
1872   1              else if(Work_Type == 2)
1873   1                { if(use_flag &0x04)  NG_COD = 1 ;}
1874   1              else if(Work_Type == 3)
1875   1                { if(use_flag & 0x08) NG_COD = 1 ;}
1876   1      
1877   1      //***************************************
1878   1              while (1)
1879   1              {
1880   2                      switch (Func_Type)
1881   2                        {
1882   3                              case TC_FUNCTION:
1883   3                          if(Work_Type == 0)
1884   3                            { if(use_flag & 0x0010) {ADD_COD = 1;}else{ADD_COD = 0;}}
1885   3                                      DO_TC_TYPE();
1886   3                                      break;
1887   3      
1888   3                              case RTD_FUNCTION:
1889   3                              DO_RTD_TYPE();
1890   3                                      break;
1891   3      
1892   3                              case mV_FUNCTION:
1893   3                                      DO_mV_TYPE();
1894   3                                      break;
1895   3      
1896   3                              case mA_FUNCTION:
1897   3                                  DO_mA_TYPE();
1898   3                                      break;
1899   3                              
1900   3                              case SETUP_FUNCTION:
1901   3                                              CAIT = 1 ;
1902   3                                      DO_SETUP_TYPE();
1903   3                              
1904   3                                      break;
1905   3      
1906   3                              case CLEAR_FUNCTION:
1907   3                                      DO_RESET_TYPE();
1908   3                                      break;
1909   3                     }
1910   2               }
1911   1      }
C51 COMPILER V9.02   MAIN                                                                  05/22/2015 15:09:11 PAGE 43  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


R485_RX. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B0H  1
CCF2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DAH  1
TB80 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009BH  1
PCAPWM4. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F6H  1
P1M0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0091H  1
P0M1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0094H  1
_RTC_read_byte . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
non3 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0097H  1
CCF3 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DBH  1
TB81 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009BH  1
PCAPWM5. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F7H  1
P2M0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0095H  1
P1M1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0092H  1
P0 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0080H  1
f_half_sec . . . . . . . . . . . . . .  PUBLIC   DATA   BIT      0000H  1
AD_Mid . . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0000H  1
ADD_COD. . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0001H  1
R485_TX. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B1H  1
CCF4 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DCH  1
SM00 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009FH  1
P3M0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B1H  1
P2M1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0096H  1
P1 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0090H  1
CCF5 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DDH  1
SM01 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009FH  1
SM10 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009EH  1
P4M0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B3H  1
P3M1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B2H  1
P2 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A0H  1
Soft_Timer . . . . . . . . . . . . . .  PUBLIC   IDATA  ARRAY    0000H  9
DO_RTD_TYPE. . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  RTD_Value. . . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
  key. . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
SM11 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009EH  1
SM20 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009DH  1
ISPCR. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E7H  1
P5M0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B5H  1
P4M1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B4H  1
P3 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B0H  1
XICON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C0H  1
EEPROM_WriteDefault. . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
serial . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
Temp_offset. . . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0002H  2
mA_Span_Value. . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0004H  2
EEPROM_SDA . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A2H  1
DOWN_KEY . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0087H  1
T0 . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B4H  1
SM21 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009DH  1
AC . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D6H  1
EVRCR. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0097H  1
P5M1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B6H  1
P4 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E8H  1
_TEMP_F_TO_C . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  tc_tmp . . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
  ttmp . . . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0002H  2
Key_backup . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0006H  1
T1 . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B5H  1
C51 COMPILER V9.02   MAIN                                                                  05/22/2015 15:09:11 PAGE 44  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


SPCON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0085H  1
P5 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F8H  1
EIE1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00ADH  1
_Buzzer. . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  status . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
TC_Zero_offset . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0007H  2
T2 . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0090H  1
EA . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AFH  1
SFRPI. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00ACH  1
WDTCR. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E1H  1
P6 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C8H  1
mV_SCL . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A4H  1
KBI0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A0H  1
SPI_MOSI . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0095H  1
SPI_MISO . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0096H  1
mA_OUT . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0085H  1
KBI1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A1H  1
SPCTL. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0085H  1
KBI2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A2H  1
AIN0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0090H  1
CF . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DFH  1
AUXIP. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00AEH  1
KBI3 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A3H  1
AIN1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0091H  1
KBI4 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A4H  1
AIN2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0092H  1
FE . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009FH  1
CH . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F9H  1
KBI5 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A5H  1
AIN3 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0093H  1
KBI6 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A6H  1
AIN4 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0094H  1
EEPROM_SCL . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A3H  1
RTD_C. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0081H  1
KBI7 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A7H  1
AIN5 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0095H  1
IE . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A8H  1
mA_Span_offset . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0009H  2
AIN6 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0096H  1
CL . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E9H  1
Read_AD3421_Value. . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  AD3421_Value . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
  ssta . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
_RTC_write_byte. . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
AIN7 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0097H  1
CEX0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0092H  1
CCAP0H . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FAH  1
ADCH . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C6H  1
_delay . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0004H  -----
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0006H  2
  j. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0005H  1
size_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
CEX1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0093H  1
CCAP1H . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FBH  1
IP0H . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B7H  1
INT0_Init. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
Func_Type. . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   000BH  1
C51 COMPILER V9.02   MAIN                                                                  05/22/2015 15:09:11 PAGE 45  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


ALL_SDA. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A2H  1
CEX2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0094H  1
CCAP2H . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FCH  1
OFFSET_KEY . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B3H  1
CEX3 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0095H  1
CCAP3H . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FDH  1
CEX4 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0096H  1
CR . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DEH  1
CCAP4H . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FEH  1
CCAP0L . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EAH  1
ADCL . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BEH  1
RD . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B7H  1
CEX5 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0097H  1
EXF2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CEH  1
REN0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009CH  1
CCAP5H . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FFH  1
CCAP1L . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EBH  1
CCAPM0 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DAH  1
IP0L . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B8H  1
Check_PCB. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
AD_Hi. . . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   000CH  1
REN1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009CH  1
CCAP2L . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00ECH  1
CCAPM1 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DBH  1
IT2H . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C3H  1
ES . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ACH  1
TSTWD. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0097H  1
CCAP3L . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EDH  1
CCAPM2 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DCH  1
mV_Span_Value. . . . . . . . . . . . .  PUBLIC   DATA   U_INT    000DH  2
IT3H . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C7H  1
CCAP4L . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EEH  1
CCAPM3 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DDH  1
IP . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B8H  1
CCAP5L . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EFH  1
CCAPM4 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DEH  1
RI . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0098H  1
CCAPM5 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DFH  1
TC_Type. . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   000FH  1
INT0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B2H  1
CY . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D7H  1
DO_RESET_TYPE. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
mA_Zero_offset . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0010H  2
BEEP . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B4H  1
mV_OUT . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0084H  1
INT1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B3H  1
TI . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0099H  1
EEP_SCL. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A3H  1
INT2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EBH  1
Volt_Ctrl. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
INT3 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EAH  1
ADCV . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C6H  1
STRETCH. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008FH  1
AD_Lo. . . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0012H  1
PT0L . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B9H  1
CAIT . . . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0013H  1
PT1L . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BBH  1
C51 COMPILER V9.02   MAIN                                                                  05/22/2015 15:09:11 PAGE 46  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


RCAP2H . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CBH  1
RTC_SDA. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A2H  1
PS . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BCH  1
PT2L . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BDH  1
SP . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0081H  1
mV_Span_offset . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0014H  2
T2EX . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0091H  1
CMOD . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D9H  1
CCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D8H  1
SCFG . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009AH  1
RTC_WRITE_SET. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
PX0L . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B8H  1
OV . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D2H  1
Disp_year. . . . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0016H  2
PX1L . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BAH  1
RCAP2L . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CAH  1
main . . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
PX2L . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BEH  1
SPI_CLK. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0097H  1
PX3L . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BFH  1
SCMD . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E6H  1
WR . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B6H  1
C_T2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C9H  1
Work_Type. . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0018H  1
DO_SETUP_TYPE. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  set_key. . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0000H  1
  times. . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0001H  1
  Itemm. . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0002H  1
  item_key . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0003H  1
  confrom_key. . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0004H  1
  up_key . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0005H  1
  don_key. . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0006H  1
  value_cal. . . . . . . . . . . . . .  AUTO     DATA   U_INT    0007H  2
T0_cnt . . . . . . . . . . . . . . . .  PUBLIC   IDATA  U_CHAR   0009H  1
SPISTAT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0084H  1
T1_cnt . . . . . . . . . . . . . . . .  PUBLIC   IDATA  U_CHAR   000AH  1
Get_Key. . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
T2_cnt . . . . . . . . . . . . . . . .  PUBLIC   IDATA  U_CHAR   000BH  1
_Get_E_Slope . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
RTC_SCL. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0096H  1
RCLK . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CDH  1
Soft_Timer_Enable. . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0019H  1
DO_TC_TYPE . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Code_Value . . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
  TC_Value . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0002H  2
  TT_Value . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0004H  2
  TA_Value . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0006H  2
  key. . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
TCLK . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CCH  1
P00. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0080H  1
IFADRH . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E3H  1
MAIN_SW. . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   001AH  1
_Check_Type_Offset . . . . . . . . . .  PUBLIC   CODE   PROC     001AH  -----
  Code_Value . . . . . . . . . . . . .  * REG *  DATA   U_INT    0006H  2
  Count_Value. . . . . . . . . . . . .  * REG *  DATA   U_INT    0002H  2
P10. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0090H  1
P01. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0081H  1
C51 COMPILER V9.02   MAIN                                                                  05/22/2015 15:09:11 PAGE 47  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


IFMT . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E5H  1
PCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0087H  1
SBUF . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0099H  1
mV_Zero_offset . . . . . . . . . . . .  PUBLIC   DATA   U_INT    001BH  2
_Get_J_Slope . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
P20. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A0H  1
P11. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0091H  1
P02. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0082H  1
_Get_K_Slope . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
Get_AD3421_Value . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
P30. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B0H  1
P21. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A1H  1
P12. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0092H  1
P03. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0083H  1
FUNCTION_KEY . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B2H  1
P40. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00E8H  1
P31. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B1H  1
P22. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A2H  1
P13. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0093H  1
P04. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0084H  1
IFADRL . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E4H  1
SCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0098H  1
InitUart . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
RTC_READ_SET . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
P50. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00F8H  1
P41. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00E9H  1
P32. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B2H  1
P23. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A3H  1
P14. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0094H  1
P05. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0085H  1
TMOD . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0089H  1
TCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0088H  1
P60. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C8H  1
P51. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00F9H  1
P42. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EAH  1
P33. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B3H  1
P24. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A4H  1
P15. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0095H  1
P06. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0086H  1
tran . . . . . . . . . . . . . . . . .  PUBLIC   DATA   BIT      0001H  1
TEMP . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A5H  1
P61. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C9H  1
P52. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00FAH  1
P43. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EBH  1
P34. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B4H  1
P25. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A5H  1
P16. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0096H  1
P07. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0087H  1
P53. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00FBH  1
P44. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ECH  1
P35. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B5H  1
P26. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A6H  1
P17. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0097H  1
Value_SDA. . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A0H  1
P45. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EDH  1
P36. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B6H  1
P27. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A7H  1
C51 COMPILER V9.02   MAIN                                                                  05/22/2015 15:09:11 PAGE 48  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


_Get_R_Slope . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
TC_C . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0080H  1
P46. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EEH  1
P37. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B7H  1
ex_int0. . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
_Get_S_Slope . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
P47. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EFH  1
KBMASK . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D7H  1
_Get_T_Slope . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_Set_mA. . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_SETUP_LED_Disp. . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
OUT_SCL. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A4H  1
PORT_Init. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
AD_SDA . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A0H  1
IE0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0089H  1
LED_Fill . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
IE1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008BH  1
RTD_Span_Value . . . . . . . . . . . .  PUBLIC   DATA   U_INT    001DH  2
LED1_SDA . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0090H  1
IE2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C1H  1
EEPROM_Init. . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
LED2_SDA . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0093H  1
IE3. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C5H  1
GF4. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AEH  1
AUXR . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008EH  1
B. . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F0H  1
KBPATN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D5H  1
Value_SCL. . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A1H  1
ReceiveFlag. . . . . . . . . . . . . .  PUBLIC   DATA   BIT      0002H  1
CP_RL2 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C8H  1
NONE_4 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A6H  1
DO_mA_TYPE . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  mA_Value . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
  key. . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
NONE_5 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A7H  1
AD3421_Init. . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
NONE_6 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B6H  1
SPIDAT . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0086H  1
ACC. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E0H  1
ReceiveDate. . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   001FH  1
_LED_Disp. . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
NONE_7 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B7H  1
AD_SCL . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A1H  1
ES0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ACH  1
PCB_SETUP. . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0020H  1
ET0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A9H  1
key. . . . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0021H  1
LED1_SCL . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0092H  1
TF0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008DH  1
ET1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ABH  1
use_flag . . . . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0022H  2
RTD_Span_offset. . . . . . . . . . . .  PUBLIC   DATA   U_INT    0024H  2
LED2_SCL . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0094H  1
TF1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008FH  1
RI0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0098H  1
ET2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ADH  1
NG_COD . . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0026H  1
C51 COMPILER V9.02   MAIN                                                                  05/22/2015 15:09:11 PAGE 49  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


LED_Init . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
TF2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CFH  1
RI1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0098H  1
RB8. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009AH  1
TH0. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008CH  1
IT0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0088H  1
TI0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0099H  1
EX0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A8H  1
TH1. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008DH  1
AV_COD . . . . . . . . . . . . . . . .  EXTERN   DATA   U_CHAR   -----  1
IT1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008AH  1
TI1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0099H  1
TB8. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009BH  1
EX1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AAH  1
SPICON . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0085H  1
TH2. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CDH  1
IT2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C0H  1
EX2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C2H  1
P. . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D0H  1
alarm_Hi_set . . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0027H  2
IT3. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C4H  1
EX3. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C6H  1
SM0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009FH  1
TL0. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008AH  1
_Set_mV. . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
mA_C . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0083H  1
XOUT . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C8H  1
ECI. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0091H  1
SM1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009EH  1
SPICTL . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0085H  1
TL1. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008BH  1
AUXIPH . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00AFH  1
alarm_Low_set. . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0029H  2
ALE. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EEH  1
SM2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009DH  1
TL2. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CCH  1
_Get_RTD_Slope . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
IFD. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E2H  1
PT0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B9H  1
NP_COD . . . . . . . . . . . . . . . .  EXTERN   DATA   U_CHAR   -----  1
R485_DE_RE . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B5H  1
PT1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BBH  1
RS0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D3H  1
TR0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008CH  1
PT2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BDH  1
RS1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D4H  1
TR1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008EH  1
TR2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CAH  1
PX0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B8H  1
EIP1H. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00AFH  1
RTD_Zero_offset. . . . . . . . . . . .  PUBLIC   DATA   U_INT    002BH  2
PX1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BAH  1
key_bak. . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   002DH  1
PX2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C3H  1
DO_mV_TYPE . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  mV_Value . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
  key. . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
C51 COMPILER V9.02   MAIN                                                                  05/22/2015 15:09:11 PAGE 50  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


PX3. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C7H  1
Temp_sp. . . . . . . . . . . . . . . .  PUBLIC   DATA   U_INT    002EH  2
Data_Value . . . . . . . . . . . . . .  PUBLIC   IDATA  ARRAY    000CH  30
EIP1L. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00AEH  1
DPH. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0083H  1
use_week . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0030H  1
CKO. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C8H  1
_EEPROM_read_byte. . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
DPL. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0082H  1
time0. . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Value_code . . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
PCON0. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0087H  1
SPSTAT . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0084H  1
SBUF0. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0099H  1
IPH. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B7H  1
time1. . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
use_year . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0031H  1
T0CKO. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B4H  1
PCON1. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0097H  1
SBUF1. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0099H  1
T1CKO. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B5H  1
EXEN2. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CBH  1
PCON2. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C7H  1
S2BUF. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009AH  1
SCON0. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0098H  1
Temp_m . . . . . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0032H  2
REN. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009CH  1
SCON1. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0098H  1
mV_C . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0082H  1
ADCON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C5H  1
RTC_ON . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
mA_SDA . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A2H  1
T2MOD. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C9H  1
T2CON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C8H  1
Zero_f . . . . . . . . . . . . . . . .  PUBLIC   DATA   BIT      0003H  1
_EEPROM_read_word. . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
ADCTL. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C5H  1
n_code . . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0034H  1
use_sec. . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0035H  1
ADCVL. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BEH  1
TC_Span_Value. . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0036H  2
wchar_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  CHAR     -----  1
SADEN. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B9H  1
AD_Status. . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0038H  1
C_F_Type . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0039H  1
S1BRT. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009AH  1
use_day. . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   003AH  1
RXD. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B0H  1
KBCON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D6H  1
use_hour . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   003BH  1
UP_KEY . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0086H  1
XIN. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C9H  1
PSL. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BCH  1
SADDR. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A9H  1
_EEPROM_write_byte . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
TXD. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B1H  1
t_code . . . . . . . . . . . . . . . .  PUBLIC   IDATA  U_CHAR   002AH  1
C51 COMPILER V9.02   MAIN                                                                  05/22/2015 15:09:11 PAGE 51  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


mA_SCL . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A4H  1
AUXR0. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008EH  1
AUXR1. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A2H  1
SPI_SS . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0094H  1
AUXR2. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A6H  1
use_min. . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   003CH  1
Temp_Flag. . . . . . . . . . . . . . .  PUBLIC   IDATA  U_CHAR   002BH  1
OVER_COD . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   003DH  1
S2RXD. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0092H  1
F0 . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D5H  1
Temp_Read. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Temp_Count . . . . . . . . . . . . .  * REG *  DATA   U_INT    0002H  2
  P_count. . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0082H  2
BEEP_OUT . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B4H  1
S2TXD. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0093H  1
F1 . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D1H  1
TC_Span_offset . . . . . . . . . . . .  PUBLIC   DATA   U_INT    003EH  2
_EEPROM_write_word . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
LED1_LE. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0091H  1
LED2_LE. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0095H  1
T0_Init. . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
use_mon. . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0040H  1
PCAPWM0. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F2H  1
PSW. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D0H  1
T1_Init. . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
PCAPWM1. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F3H  1
T2_Init. . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
mV_SDA . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A2H  1
CCF0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D8H  1
RB80 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009AH  1
PCAPWM2. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F4H  1
CCF1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D9H  1
RB81 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009AH  1
PCAPWM3. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F5H  1
SPDAT. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0086H  1
P0M0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0093H  1
AUXIE. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00ADH  1


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   8251    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     65      31
   IDATA SIZE       =     44    ----
   BIT SIZE         =      4    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
